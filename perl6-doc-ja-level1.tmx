<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>This document originally summarized Apocalypse 1, which covers the initial design concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 1を要約したもので、初期のデザインコンセプトを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That original summary may be found below under &quot;Random Thoughts&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>原文の概要は &quot;Random Thoughts&quot; 以下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>歴史的資料として凍結されるApocalypsesと違い、SynopsesはPerl 6の設計の更新も反映します 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの更新点は記録されません ― SynopsisがApocalypseと違う場合はSynopsisが正しいと見なして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another assumption has been that if we don't talk about something in these Synopses, it's the same as it is in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つの前提として、これらSynopsesで我々が話題にしないことはPerl5と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Soon we plan to fill in the gaps with the Perl 5 details though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もうすぐ我々はPerl 5の細部とのずれを埋める予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly, we're just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大抵の場合、我々は餌を巣に運ぶアリのような集団に過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主にボランティアによって、多くのグループが適当にこまごまとした仕事を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not attempt to summarize all these subprojects--see the various websites for Parrot and Pugs and Perl 6 for such information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはこれらのサブプロジェクトを全て要約するわけではありません。そのような情報はParrotやPugsやPerl 6のウェブサイトなどを参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が言えることは、Perl 5の場合と違ってこれらのプロジェクトは公式のPerlとは異なるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is anything that passes the official test suite.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公式のテストスイートをパスしたものは全てPerl 6なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This test suite was initially developed under the Pugs project because that project is the furthest along in exploring the high-level semantics of Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>当初、このテストスイートはPugsプロジェクトの元で開発されました。Perl 6の開発に関してPugsプロジェクトが最も先行していたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Other projects are better at other things, such as speed or interoperability.) However, the Pugs project views the test suite as community property, and is working towards platform neutrality, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(他のプロジェクトは速度や相互運用性などの面では優れています。)しかしPugsプロジェクトはテストスイートをコミュニティの所有物と考えており、プラットフォームに対して中立になることを目指しているので、このテストが動作するものをPerl 6とすることにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another aspect of this is the Perl 6 compiler will be self-hosting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の側面は、Perl 6コンパイラをセルフホスティングすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々なコード出力バックエンドが開発されたら、最終的にはコンパイラ自身をコンパイルするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは主にフロントエンドからプラットフォームの依存性を取り除き、バックエンドだけがプラットフォーム固有の問題を気にするようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &quot;apocalypse&quot; historically meant merely &quot;a revealing&quot;, and we're using it in that unexciting sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;apocalypse&quot; という言葉は歴史的には啓示することを意味します。我々はそのありきたりな意味で使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたがRFCを一般人に尋ねたら、興味深いが矛盾した多くのアイデアを得るでしょう。人々の意見は極端に分かれがちで、どのアイデアもお互いに構築することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry's First Law of Language Redesign: Everyone wants the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Larryによる新しい言語設計の最初の秩序：みんながcolonを望む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブ言語のパーサーによる拡張を許容するため、Perlはワンパスの予測的パーサーでパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, lookahead of more than one &quot;longest token&quot; is discouraged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、1つより多くの「最も長いトークン」の先読みは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在知られている例外は、パーサーが以下のことをしなければならない場所:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>印で始まり、ブロックで終わるか終わらない補完された式の終わりに設置しなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recognize that a reduce operator is not really beginning a [...] composer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>減少演算子が[...]の作成者の始まりとは限らないと認識しなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlはユニコードで記述され、論理的には基礎的なテキスト表現に関わらず一貫性のあるユニコードの意味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default Perl presents Unicode in &quot;NFG&quot; formation, where each grapheme counts as one character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの書記素が1文字として数えられる場所では、デフォルトでPerlはユニコードをNFG形式で表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書記素とは初心者ユーザーが日常生活の中で考えると思われるどんな発音記号も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlはユニコードの行とパラグラフのセパレータを行マーカーとして数えることが出来ます。しかし、その振る舞いはあなたのエディタが考えるユニコードの行とPerlの行番号のアイデアとマッチするように設定出来るべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコードの水平空白は空白として数えられます。しかし、単一のトークンに見えるような隣接したトークンを生成するような場所では細い空白を使わないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方でPerlはインデントを文法として使わないので、空白が意味をなす場所ではいくらでも自由に空白を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは常に空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの構文上の目的で、Perlは括弧でないものから括弧文字を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧文字は双方向ミラーリングかPs/Pe/Pi/Pfプロパティのユニコード文字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実用上はPs/Pe/Pi/Pfプロパティの文字を使うのが安全ですが、ASCIIの角括弧はPs/Pe/Pi/Pfセットではないのに双方向なので注目すべき例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する閉じ文字がない文字は括弧の開始と見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはユニコードBidiMirroringデータテーブルの第2セクションを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字が既にPs/Pe/Pi/Pfマッピングで使用されている場合、どのBidiMirroringのエントリも無視されます（前方、後方マッピング両方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POD sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6ではPODセクションは複数行コメントとして確実に使用できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, POD syntax now lets you use =begin comment and =end comment delimit a POD block correctly without the need for =cut.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、=begin commentと=end commentは=cut無しでPODブロックを正しく区切ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In fact, =cut is now gone.) The format name does not have to be comment -- any unrecognized format name will do to make it a comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(現に、=cutは無くなりました)フォーマット名は commentである必要はありません。識別されないフォーマット名はコメントになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, bare =begin and =end probably aren't good enough, because all comments in them will show up in the formatted output.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(しかし、裸の=beginと=endではおそらく不十分です。その中の全てのコメントがフォーマットされて表示されてしまうからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have single paragraph comments with =for comment as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、単独のパラグラフコメント=for commentがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That lets =for keep its meaning as the equivalent of a =begin and =end combined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは=forを=beginと=endが結合したものと同等の意味を持つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with =begin and =end, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>=beginと=endのように、コメントはコードの前から後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みドキュメントの詳細はS26を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except within a string literal, a # character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6では文字列リテラルを除いて、#は常にコメントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two forms of comment based on #.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#のコメントは2つの形態があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments require the # to be followed by one or more opening bracketing characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントは括弧の開始文字に続いた#を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは分割を目的とした改行と同じく空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments are supported as a variant on quoting syntax, introduced by # plus any user-selected bracket characters (as defined in Lexical Conventions above):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントはクォーティング文法の変形としてサポートされ、#とユーザーが選んだ括弧文字(Lexical Conventionsで定義されているもの)で導入されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧は普通の引用括弧と同じにネストするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded comment is not allowed as the first thing on the line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行頭で埋め込みコメントは許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to have a comment there, you must disambiguate it to either an embedded comment or a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそこにコメントを置きたいなら、埋め込みコメントか行コメントの曖昧さをなくす必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put a space in front of it to make it an embedded comment:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントにするために、前に空白を置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can put something other than a single # to make it a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または行コメントにするために単一の#以外のものを置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if you are commenting out a block of code using the line-comment form, we recommend that you use ##, or # followed by some whitespace, preferably a tab to keep any tab formatting consistent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、もしコードブロックを行コメントを使ってコメントアウトするなら、##または空白(できればタブ)が続く#を使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's often better to use pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、PODコメントは暗黙的に行指向なのでそちらの方が良い場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザーが選んだ括弧のクォート構文で、複数の一致する括弧文字を使うことが出来ます。閉じ括弧は同じ数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧のネストは開き括弧と同じ長さでなければ適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that bare circumfix or postcircumfix &lt;&lt;...&gt;&gt; is not a user-selected bracket, but the ASCII variant of the «...» interpolating word list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸のcircumfixまたはpostcircumfix &lt;&lt;...&gt;&gt;はユーザーが使用可能な括弧ではありません。しかしASCIIの変形の«...»補完単語リストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only # and the q-style quoters (including m, s, tr, and rx) enable subsequent user-selected brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#とq-style(m、s、 tr、rx)だけがユーザーが選んだ括弧を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのようないくつかの言語は、行を結合するために改行をエスケープすることを許可しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正規表現のような他の言語はバックスラッシュをを様々な理由で使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はこれをあらゆる種類の空白という概念に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with \.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての連続する空白(コメント含む)は\を前に置くことによってパーサーから隠されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as the &quot;unspace&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&quot;unspace&quot;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはPerlの様々な空白を抑制することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばPerlは名詞と後置演算子の間に空白を無いことを要求しますが、unspaceを使うことで後置演算子をつなげることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別なケースで、後置演算子の所のバックスラッシュはunspaceの縮退した形式と見なします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これの前に空白は置けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will be parsed as a list operator with a Capture argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はCaptureと一緒のリスト演算子とパースされます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、他の形式のunspaceは空白に先行して役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の後置演算子もunspaceを活用できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つの典型的な使い方は、ドット後置演算子を次の行に置くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But unspace is mainly about language extensibility: it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしunspaceは主に言語の拡張性に関するものです。あなたが現在インストールしているパーサーに関わらず、改行がパーサーを混乱させるようなあらゆる場面で行を継続することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、unspaceはパーサーから空白を隠しますが、レクサーからは隠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果として、unspaceはトークンとして許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceが改行を含むなら行として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PODチャンクは空白として数えられるので、unspaceで飲み込むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントの境界は抑制されます。けれども、あなたは過度に長いヒアドキュメントの出だしの行をこのように分割できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントのパーサーは次のようにしか見ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはコメントを含むかもしれませんが、コメントはunspaceを含まないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、行コメントはバックスラッシュを意味のあるものと見なしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に、単一のトークンか他の構文単位と誤解される構造を分離する必要がある場合を除いて、Perl 6では空白は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, Perl 6 follows the standard longest-token principle, or in the cases of large constructs, a prefer shifting to reducing principle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、Perl 6は標準の最も長いトークンの原則、または大きな構文の場合、prefer shifting to reducingの原則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは不変の深いルールです。しかしPerl 6は変化する言語として設計されているので、表面上の影響は様々な演算子に変化し、マクロが言語に加えられるか削除されることを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に項の後の後置演算子と2項演算子の間で競合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし与えられたトークンが後置演算子か2項演算子と解釈されそうなら、2項演算子の前に空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置演算子は間に入る空白を持ちませんが、間に入るドットを持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる分離が望まれ、空白でないものがunspaceか埋め込みコメントの外側に発生するなら、前述のunspaceか埋め込みコメントが使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on $_ where a term is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(クォートで区切るかunspaceを終了することは除いて)項が期待される場所で前に空白を伴うドットは$_のメソッド呼び出しと解釈されます。 それが後置のルールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その点で項が期待されていないなら構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろんドットで始まる2項演算子は有りません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could, for instance, define a Fortranly infix:&lt;.EQ.&gt; if the fit took you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばフォートランっぽいinfix:&lt;.EQ.&gt;を定義して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に以下のように解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの変化形は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし後置のメソッド呼び出しを意味するなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば、続く文字が数字なら、数に続くドットは小数点にしかなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外の場合は後置のドットはいくつかの種類のメソッド呼び出しの開始と解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In support of OO encapsulation, there is a new fundamental datatype: P6opaque.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト指向のカプセル化で、P6opaqueという新しい基本データ型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>opaqueオブジェクトへの外部からのアクセスは常にメソッド呼び出しで行われます。属性でさえそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はより良く動作する安全なコードを書く助けとなる任意的な型システムを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが提供した型からの情報の推測はコンパイラーが自由に行います。しかし型の情報が欠落していても文句は言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は正式には構造的な等価性よりも名前の等価性で比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、我々は名前を考えるのは自由であることを好みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &quot;anonymous&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、(型自体が無名であったとしても)名前は型を定義するモジュールに関連するバージョンと権限を含むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &quot;long name&quot; of the resulting type, so one Array of Int is equivalent to another Array of Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上で、パラメータ付きの型をインスタンス化する場合、引数は結果の型の&quot;長い名前&quot;の一部と考えられるので、あるArray of Intは他のArray of Intと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Another way to look at it is that the type instantiation &quot;factory&quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それを見るもう一つの方法は、インスタンス化する&quot;factory&quot;がメモ化されることです。)型名の別名は元の型と同等と考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the Array of Int syntax is just sugar for Array:of(Int), which is the canonical form of an instantiated generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にArray of Intという構文は単にジェネリックタイプをインスタンス化するArray:of(Int)の標準的なシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このパラメータ付きの型の名前の等価性は不変(または少なくとも不変のパラメータのスナップショットを撮ることが出来る)と考えられるパラメータだけを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは不変と考えられないので、2つの明らかに異なるクラスが同じ属性を持っているとしても同じとは見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of properties on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は様々な種類のオブジェクトでプロパティの概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのクラスではなく個々のオブジェクトに管理されているのを除いて、プロパティはオブジェクトの属性に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S12によれば、プロパティは実際にはミックスインのメカニズムで実装され、そのようなミックスインはオブジェクトに対する個々の無名クラスの生成によって完成します(同一の無名クラスが既に存在し、安全に共有できるのでなければ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティはコンパイル時に構成される変数やクラスのようなオブジェクトに適用され、traitsとも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Traitsは実行時に変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時のプロパティの変更は代わりにミックスインによって行われます。これによってコンパイラーは宣言されたtraitsを元に最適化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンですが、それが不便な時は大抵は必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ファイルハンドルのようないくつかのビルトインの概念はPerl 5以上にオブジェクト指向的になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数の型は変数が含む可能性がある値の性質を示す制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &quot;role&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より正確には、オブジェクトまたは変数に含まれるオブジェクトが&quot;role&quot;が示すメソッドに応答できることの保証です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数自体はどの種類のものが含まれているか指定すること無しに、コンテナがどの様に動作するか指定するコンテナ型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制約とコンテナの型は一緒に使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that $x is also initialized to the Int type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$xはまた、Int型オブジェクトで初期化されることに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これについて詳しくは以下を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my Dog $spot by itself does not automatically call a Dog constructor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>my Dog $spotそれ自体はDogのコンストラクターを自動で呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined Dog prototype object to $spot:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは単に未定義のDogのプロトタイプオブジェクトを$spotに割り当てます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is an undefined instance of that type's prototype object, or type object for short.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値として使われる任意の型名はその型のプロトタイプオブジェクト、または短くはタイプオブジェクトの未定義のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>右辺のコンテキストでの型名は単一の型の値としてパースされ、引数がないことを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、タイプオブジェクトは関数呼び出しインターフェースに応答するので、あなたは型の名前を括弧と一緒に関数であるかのように使用するでしょう。そして呼び出しに供給されるどんな引数もタイプオブジェクトの示す型によって強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし引数が括弧にないなら、タイプオブジェクト自体が返されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a real Dog object, call a constructor method such as new:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当のDogオブジェクトを得るために、newのようなコンストラクタメソッドを呼んで下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンストラクタに引数を渡すことも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you are declaring that the elements of @array are native integers, but that the array itself is implemented by the MyArray class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@arrayの要素がネイティブの整数と宣言しますが、配列自体はMyArrayクラスで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型指定されない配列とハッシュはまだ完全に何でも受け入れますが、Perl 5と同じパフォーマンスの問題があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the .elems method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の要素数を得るには.elemsメソッドを使用して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also ask for the total string length of an array's elements, in bytes, codepoints or graphemes, using these methods .bytes, .codes or .graphs respectively on the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、.bytes、.codes、.graphsメソッドを使用してバイト、コードポイント、書記素で配列の要素の文字列の長さの合計を求めることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列にも同じメソッドを適用することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that .bytes is not guaranteed to be well-defined when the encoding is unknown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(.bytesはエンコーディングが不明な場合は明確には保証されないので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, .codes is not well-defined unless you know which canonicalization is in effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、.codesはどの正規化が有効なのか不明な場合は明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルトインオブジェクト型は大文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes immutable types (e.g. Int, Num, Complex, Rat, Str, Bit, Regex, Set, Block, List, Seq), as well as mutable (container) types, such as Scalar, Array, Hash, Buf, Routine, Module, and non-instantiable Roles such as Callable, Failure, and Integral.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは不変の型を含みます。(例えばInt、Num、Complex、Rat、Str、Bit、Regex、Set、Block、List、Seq)変更可能な型(コンテナ)も同様です。Scalar、Array、Hash、Buf、Routine、Moduleなど。そしてインスタンス化できないCallable、Failure、Integralも同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型は主にコンパクトな配列を宣言するためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、Perlは対応する大文字の型のように扱えるようにしようとするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it does autoboxing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、autoboxingを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのオブジェクトは値型として振る舞うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a &quot;WHICH&quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトはハッシュと値ベースの比較のために一意に識別するための&quot;WHICH&quot;という値を出力できます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with non-native types can always contain undefined values, such as Object, Whatever and Failure objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型の値は常にundefined値を含むことが出来ます。Object、Whatever、Failureのオブジェクトなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S04 for more about failures (i.e. unthrown exceptions):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>failures(例えばunthrown exceptions)についてはS04を参照して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型は未定義をサポートしません: 未定義値をそれらに割り当てるとエラーになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測: 浮動小数点形式がこの概念を表現できるなら、numはundefをNaNにする自動変換をサポートするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その変換を任意に出来るなら良いかもしれません。ロケットの設計者は事故破壊を即座に行うか後で行うか決めることが出来るように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables of non-native types start out containing an undefined value unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型は明示的に定義された値で初期化されるのでなければ未定義値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object supports a HOW function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトは、オブジェクトが定義されているかどうかに関わらずそれを管理するメタクラスのインスタンスを返すHOW関数/メソッドをサポートします。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(プロトタイプシステム(クラスベースでないオブジェクトシステム)のために全てのオブジェクトは同じメタオブジェクトによって管理されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は本質的にシステムの型宣言を通してbig integersとrationalsをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int automatically supports promotion to arbitrary precision, as well as holding Inf and NaN values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IntはInfとNaNを保持するのと同じに任意の精度を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Int assumes 2's complement arithmetic, so +^1 == -2 is guaranteed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Intは2の補数演算を推測することに注意して下さい。+^1 == -2は保証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Native int operations need not support this on machines that are not natively 2's complement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ネイティブintの演算は2の歩数をネイティブにサポートしないマシンではこれをサポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 should by default make standard IEEE floating point concepts visible, such as Inf (infinity) and NaN (not a number).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はデフォルトでInf(無限)とNaN(数でない)のような標準のIEEE小数点概念を見えるようにするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープではプログラムは一時的な値の性質、そして様々な環境で浮動小数点がどの様に振る舞うか指定するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機能しないプラットフォームをバイパスするために壮大な努力を必要とする場合を除いて、全てのIEEEモードがプラグマによってレキシカルに有効でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルトの浮動小数点モードは例外をスローしませんが、InfとNaNを伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ボックス化されたオブジェクト型はオーバーフローかアンダーフローが起こったところでより詳細な情報を伝達するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlでは数値は同一の答えを与えるように設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(本当によいプログラマーは時にはより良くします。) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Str is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Strはユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native str type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応するネイティブなstr型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since a Str object may fill multiple roles, we say that a Str keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながらStrオブジェクトは複数のroleを果たすので、Strはユニコードの抽象的レベルで最小と最大のトラックを保持し、現在のレキシカルスコープの考える理想的な文字を演じます。バイト、コードポイント、 graphemesまたはある言語の文字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all Str positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての組み込み操作について、全てのStrの位置はポジションオブジェクトとして報告され、整数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These StrPos objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StrPosオブジェクトは特定の文字列の特定の場所を抽象化レベルに依存せずポイントします。文字列と位置を直接に追跡するか、あらゆるコンテキストで同じ文字列に適用される同じ結果を与える文字列の始まりのオフセットを抽象化に依存しない表現で出力するかどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is assuming the string isn't modified in the meanwhile; a StrPos is not a &quot;marker&quot; and is not required to follow changes to a mutable string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはその間に文字列が変更されないと仮定します;StrPosは&quot;マーカー&quot;ではなく、変更される文字列を追跡する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、置換された文字列の位置を求めるとしたら、その答えは元の文字列のものです(今はアクセスできないでしょう！)。 変更された文字列のものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポジションオブジェクトが期待されるところで整数を使用すると、現在のレキシカルスコープのユニコード抽象化レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(デフォルトはgraphemesです。)それ以外は適切な単位を強要する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろんそのような次元数は文字列が適切な抽象化レベルを提供しないなら失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような次元的でない数を間違った単位で解釈するルーチンに渡すのは間違っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Buf is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of Str.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufは文字列的な整数の配列です。明示的にいくつかの種類のStrに変換されるのでなければユニコードか文字のプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A buf is the native counterpart.) Typically it's an array of bytes serving as a buffer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(bufはネイティブ対応です。)通常はバッファを受け取るためのバイト列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a Buf treat the entire buffer as a single large integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufのビット演算は一つの巨大な整数として扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a Str generally fail unless the Str in question can provide an abstract Buf interface somehow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Strのビット演算は普通は失敗します。Strが Bufの抽象インターフェースを何とか提供しなければ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercion to Buf should generally invalidate the Str interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufへの強制は一般的にはStrのインターフェースを無効にするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a generic type Buf may be instantiated as (or bound to) any of buf8, buf16, or buf32 (or to any type that provides the appropriate Buf interface), but when used to create a buffer Buf defaults to buf8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ジェネリック型としてのBufはbuf8、buf16、buf32のどれか(またはBufの適切なインターフェースを提供する何かの型)によってインスタンス化（またはバインド）されます。バッファとして使われる時のBufのデフォルトはbuf8になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは必ずしもバイト位置ではありません ― 整数位置は単に基礎的な位置の数を数えるだけです。それはあるセルを意味するある位置の基礎的な整数型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The utf8 type is derived from buf8, with the additional constraint that it may only contain validly encoded UTF-8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>utf8型はbuf8型から派生し、正当にエンコードされたUTF-8だけであるという追加の制約があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, utf16 is derived from buf16, and utf32 from buf32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様にutf16はbuf16から派生し、utf32はbuf32から派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは型名なので、リスト演算形式は制約には許可されないので、それらを制約として呼び出すために必ず括弧が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に次のようにパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The * character as a standalone term captures the notion of &quot;Whatever&quot;, which is applied lazily by whatever operator it is an argument to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項の文字*は&quot;何でも&quot;という概念をとらえます。それはwhatever演算子が引数にいい加減に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally it can just be thought of as a &quot;glob&quot; that gives you everything it can in that argument position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的にはそれは引数の位置に何でも与える&quot;glob&quot;と考えることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever is an undefined prototype object derived from Any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>WhateverはAnyを継承した未定義のプロトタイプオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としては抽象型で、定義されたオブジェクトとしてインスタンス化されないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例外が理にかなっていると考えないなら、理にかなった答えが与えられると期待しない方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Whatever object is effectively immutable, the optimizer is free to recognize * and optimize in the context of what operator it is being passed to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Whateverオブジェクトは不変なので、オプティマイザは *を自由に認識することができ、どの演算子に渡されるのかコンテキストの中で最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces a function of a single argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数1つの関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the single dispatcher recognizes *.meth and returns { $_.meth }, so it can be used where patterns are expected:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に単一のディスパッチャーは*.methを認識して{ $_.meth }を返すので、そのパターンが期待される場所で使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These closures are of type Code:($), not Whatever, so that constructs can distinguish via multiple dispatch:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Code:($)はクロージャー型でWhateverではないので、構造はマルチディスパッチによって区別できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bare * form may also be called as a function, and represents the identify function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸の*形式は関数としても呼ぶことができ、関数の識別を表します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that this is not what is happening above, or</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこれは上で起こっていることではありません。または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would end up meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は以下を意味することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ... operator is instead dispatching bare * to a routine that does dwimmery, and in this case decides to supply a function { * + 1 }.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>...演算子は代わりに*を期待通りに動作するルーチンにディスパッチしています。そしてこの場合は関数{ * + 1 }を供給すると決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore @array[^**] represents @array[{ map { ^* }, @_ }], that is to say, every element of the array, no matter how many dimensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って@array[^**]は@array[{ map { ^* }, @_ }]を表し、配列の次元数を問わない配列の全要素ということになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, @array[**] means the same thing because (as with ... above), the subscript operator will interpret bare ** as meaning all the subscripts, not the list of dimension sizes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ただし@array[**]は同じことを意味します。なぜなら (...で述べたように)添字演算子は裸の**を全ての添字と解釈し、次元のサイズのリストとは解釈しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがそうでなければ、これらはMMDシステムによって意味を与えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型の値は、それらの対になる大文字の型のオブジェクトとして扱われる時はautobox化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including bit) default to 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型はPerlの概念の未定義値を表現できないので、明確な初期化がなければネイティブ浮動小数点はデフォルトでNaN、整数（bit含む)はデフォルトで0になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>complex型のデフォルトはNaN + NaN\iです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既知のサイズのbuf型は0の値のシーケンスがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any native type is explicitly initialized to * (the Whatever type), no initialization is attempted and you'll get whatever was already there when the memory was allocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしネイティブ型が*(Whatever型)に明示的に初期化されたら、メモリに既に割り当てられた値が割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしbuf型がユニコード文字列の値で初期化されたら、文字列はユニコードのコードポイントに分解され、それぞれのコードポイントは整数の要素に押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>buf型のサイズが指定されない場合は、初期化する文字列の長さから持ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サイズが指定された場合は文字列は必要に応じて切り詰められるか0で埋められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time; otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either U+FFFD (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or U+007f (DELETE) if the larger value would not fit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしコードポイントがbufの整数型にフィットしない場合は、コンパイル時に検出できるならパースエラーが発生します。そうでなければ実行時に警告され、オーバーフローしたバッファの要素は適切な代替文字U+FFFD (置き換え文字、整数型が少なくとも16ビットの場合)かU+007f (削除文字、より大きい値にフィットしない場合)に置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の変換を望む場合は、明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, no conversion to UTF-8 or UTF-16 is attempted; that must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にUTF-8かUTF-16への変換は試みられません。明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それが起こったら、32ビット整数ベースのbufへの変換はネイティブエンディアンの有効なUTF-32を生成します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can behave as values or objects of any class, except that defined always returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>definedが常にfalseを返す場合を除き、未定義型は値または何かのクラスのオブジェクトとして振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can create them with the built-in undef and fail functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは組み込みのundefかfail関数で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(failuresがどの様に処理されるかはS04を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの種類のtype、class、moduleまたはpackageを定義した場合でも、自動的に同じ名前の未定義プロトタイプ値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a Failure value is put into a typed container, it takes on the type specified by the container but continues to carry the Failure role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Failure値が型付けされたコンテナに設置された時はいつでもコンテナによって指定された型を引き受けますが、Failureのroleをもたらし続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The undef function merely returns the most generic Failure object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(undef関数は最も一般的なFailureオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use fail to return more specific failures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より特定のfailuresを返すにはfailを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use Object for the most generic non-failure undefined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最も一般的なnon-failureの未定義値にはObjectを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Any type is also undefined, but excludes junctions so that autothreading may be dispatched using normal multiple dispatch rules.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Any型も未定義ですが、autothreadingは普通のマルチディスパッチの規則でディスパッチされるのでjunctionsは除外します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nil type is officially undefined as an item but interpolates as a null list into list context, and an empty capture into slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Nil型は項目として公式に未定義ですが、リストコンテキストではnullリストに、スライスコンテキストでは空キャプチャに補間されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Nil object may also carry failure information, but if so, the object behaves as a failure only in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Nilオブジェクトはfailureの情報ももたらしますが、もしそうなら、オブジェクトはitemコンテキストでのみfailureとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use Failure/undef when you want to return a hard failure that will not evaporate in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストコンテキストで消滅しないhard failureを返したい時は Failure/undefを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types behave like values, i.e. $x === $y is true if and only if their types and contents are identical (that is, if $x.WHICH eqv $y.WHICH).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は値のように振る舞います。すなわち、$x === $yはそれらの型と内容が同一の場合のみtrueです。(つまり$x.WHICH eqv $y.WHICHなら)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Insofar as Lists are lazy, they're really only partially immutable, in the sense that the past is fixed but the future is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Listsがlazyである限りにおいて、過去が固定され、未来がないという意味では、それらは本当に部分的にだけ不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The portion of a List yet to be determined by iterators may depend on mutable values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まだイテレータによって決定されていないListの部分は変更可能な値に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an iterator is called upon to iterate and extend the known part of the list, some number of immutable values (which includes immutable references to mutable objects) are decided and locked in at that point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータがリストの既知の部分の反復と拡張の上で呼ばれた時、いくつかの数の不変の値(変更可能なオブジェクトへの不変なリファレンスを含む)が決定され、その点でロックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterators may have several different ways of iterating depending on the degree of laziness/eagerness desired in context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテキストで望まれるlaziness/eagernessの度合いに応じてイテレータはいくつかの異なる方法を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator API is described in S07.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータのAPIはS07で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instants and Durations are measured in atomic seconds with fractions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>InstantとDurationは有理数で微少時間に測定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notionally they are real numbers which may be implemented in either Num or Rat types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>理論上、それらはNumかRat型で実装される実数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Fixed-point implementations are strongly discouraged.) Interfaces that take Duration arguments, such as sleep(), may also take Num arguments, but Instant arguments must be explicitly created via any of various culturally aware time specification APIs that, by and large, are outside the CORE of Perl 6, with the possible exception of a constructor taking a native TAI value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(固定小数点の実装は強く推奨されません。)sleep()のようなDurationの引数を受け取るインターフェースはNum引数も受け取りますが、Instant引数はさまざまな文化を理解した時間仕様のAPI(概してPerl 6のCOREの外側で、ネイティブTAI値を受け取るコンストラクタの可能な例外を伴う)によって明示的に作成されたものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context a Duration happily returns a Num representing seconds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストではDurationは喜んで秒を表すNumを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If pressed for a number, an Instant will return the length of time in atomic seconds from the TAI epoch, but it will be unhappy about it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値が求められる場面ではInstantはTAIエポック値の微少時間の長さを返すでしょう。しかしそれに関しては適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems which cannot provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>POSIXのような安定したタイムベースを返すことができないシステムでは、正しい微少時間を最大限に推測できるようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types have distinct .WHICH values that do not change even if the object's contents change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型のオブジェクトはそれぞれがオブジェクトの内容が変わっても変わらない.WHICH値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Routinesは変更可能と見なされます。なぜならそれらは適所にラップされることができるからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash differs from a normal Hash in how it handles default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashは通常のHashとデフォルト値の扱いが異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of a KeyHash element is set to the default value for the KeyHash, the element is deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashの要素の値がKeyHashのデフォルト値にセットされていた場合、その要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If undeclared, the default default for a KeyHash is 0 for numeric types, False for boolean types, and the null string for string and buffer types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言されていない場合、KeyHashのデフォルトのデフォルトは数値型では0、ブール型ではFalse、文字列とバッファ型ではnull文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash of a Object type defaults to the undefined prototype for that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Object型のKeyHashはその型の未定義プロトタイプがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, the default default is whatever defined value an undef would convert to for that value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より一般的には、デフォルトのデフォルトは定義された値のなんでもの型に変換されるであろうundefです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash of Scalar deletes elements that go to either 0 or the null string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ScalarのKeyHashは0かnull文字列の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash also autodeletes keys for normal undef values (that is, those undefined values that do not contain an unthrown exception).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashは通常のundef値のキーも削除します(つまりそれらの未定義値はスローされない例外を含みません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySet is a KeyHash of booleans with a default of False.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeySetはFalseをデフォルトにしたブール値のKeyHashです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the Hash interface and increment an element of a KeySet its value becomes true (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしHashインターフェースを使い、KeySetの要素を増やした場合はその値はtrueになります(要素が存在しない場合は作成する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし要素を減らした場合はその要素はfalseになり、自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decrementing a non-existing value results in a False value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値を減らすとFalse値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incrementing an existing value results in True.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在する値を増やすとTrueを生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a Hash (that is, when used as an Array or list or Set object) a KeySet behaves as a Set of its keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしHashとして使わない場合(つまりArrayかリストかSetオブジェクトとして使った場合)KeySetはそのキーのSetとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Since the only possible value of a KeySet is the True value, it need not be represented in the actual implementation with any bits at all.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(KeySetの可能な値がTrue値だけなので、少しのことでも実際の実装では表現する必要はありません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyBag is a KeyHash of UInt with default of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyBagは0をデフォルトにしたUIntのKeyHashです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the Hash interface and increment an element of a KeyBag its value is increased by one (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたがHashインターフェースを使い、KeyBagの要素をインクリメントするとその値が1増加します(存在しない要素は作成されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element the value is decreased by one; if the value goes to 0 the element is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素をデクリメントすると値が1減少します。値が0になると要素が自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attempt to decrement a non-existing value results in a Failure value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値をデクリメントしようとするとFailure値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a Hash (that is, when used as an Array or list or Bag object) a KeyBag behaves as a Bag of its keys, with each key replicated the number of times specified by its corresponding value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hashとして使われない場合(つまりArrayかリスト化Bagオブジェクトとして使われた場合)、KeyBagはそのキーのBagとして振る舞い、それぞれのキーは対応する値によって指定された回数複製されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use .kv or .pairs to suppress this behavior in list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(リストコンテキストでこの振る舞いを抑制するには.kv か.pairsを使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Hash types, Pair and Mapping are mutable in their values but not in their keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hash型のようにPairとMappingはそれらの値を変更できますがキーはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A key can be a reference to a mutable object, but cannot change its .WHICH identity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(キーは変更可能なオブジェクトへの参照になれますが、.WHICHの固有性は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、ハッシュの要素と同様に値は異なるオブジェクトに再バインドされるでしょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的な型はオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their &quot;value type&quot; and their &quot;implementation type&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlの変数は2つの関連する型を持ちます: それらの&quot;値型&quot;と&quot;実装型&quot;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its of property, while the implementation type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より一般的には、どの種類のコンテナもサブルーチンとモジュールを含む実装型を持ちます。)値型はそのofプロパティとして格納され、コンテナの実装型は単にコンテナ自身のオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word returns is allowed as an alias for of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単語returnsはofの別名として許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型はどの種類の値が変数に格納されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type is given as a prefix or with the of keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は前置かofキーワードで与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the of property of the container to Dog.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合でもコンテナのofプロパティをDogに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines have a variant of the of property, as, that sets the as property instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンはofプロパティの変化形asを持ち、代わりにasプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to return or by implicit fall-off-the-end return).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asプロパティは返値に強制される制約(もしかしたら抑制) を指定します(returnによって明示的に呼ばれるか最後の暗黙の返値のいずれかによって)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint, unlike the of property, is not advertised as the type of the routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ofプロパティのようでないこの制約はルーチンの型としては表に出ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of it as the implicit type signature of the (possibly implicit) return statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは(もしかしたら暗黙の)return文の暗黙の型シグネチャと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's therefore available for type inferencing within the routine but not outside it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従ってルーチン内で型推論が利用できますが外側ではできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no as type is declared, it is assumed to be the same as the of type, if declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as型が宣言されていない場合、of型が宣言されている場合と同じと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列かハッシュでの値型はそれぞれの格納された要素の型を指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュのキーの型はshape traitで指定されます―S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型は変数自身がどの様に実装されているかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変数のtraitとして与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型を定義することはPerl 6ではPerl 5の変数のtieに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time tie statement unless the variable is explicitly declared with an implementation type that does the Tieable role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしPerl 6の変数は宣言時に直接tieされ、Tieable roleを行う実装型で明示的に宣言された変数でなければパフォーマンス上の理由で実行時にtie文でtieされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, package variables are always considered Tieable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながらパッケージ変数は常にデフォルトでTieableとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, all named packages are also Tieable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、全ての名前付きパッケージもデフォルトでTieableです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスとモジュールはtieされたパッケージとは異なると見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the Package role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の方向から見れば、グローバルパッケージにバインドされることを希望するクラスとモジュールはPackage roleが可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの型の値がそれぞれの要素に格納されているか指定するため、非スカラー型は修飾されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each successive of makes the type on its right a parameter of the type on its left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの連続するofはその右のパラメータの型を、その左の型にさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ付きの型は角括弧を使って名前を付けられます。だから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は実際には以下のような意味になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑な型が指定された場合は実際の変数を理解するのが大変なので、同様の後置形式があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as form may be used in subroutines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンではas形式が使われるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに返値の型はシグネチャ内で指定されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a slight difference, insofar as the type inferencer will ignore a as but pay attention to --&gt; or prefix type declarations, also known as the of type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の推測者がasを無視する限りにおいて、そこには微妙な違いがあります。しかしof型としても知られる--&gt;または後置の型宣言に注意を払って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the inside of the subroutine pays attention to as, and essentially coerces the return value to the indicated type, just as if you'd coerced each return expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンの内側だけがasに注意を払っており、本質的に返値はそれぞれのreturn式を強制したかのように指定された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also specify the of type as the of trait (with returns allowed as a synonym):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型をof trait(returnsが同義語として許可される)として指定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &quot;or&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;or&quot;かjunctionであるかのように、単一の型をセットで使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fancier type constraints may be expressed through a subtype:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>手の込んだ型制約はsubtypeを通して表現されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &quot;anded&quot; together (the variable itself supplies type constraints, and where clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &quot;and&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの項は暗黙に一緒に&quot;anded&quot;された制約のセットと見ることができるので(変数自身は型制約を供給し、where条項かツリーマッチングはさらに制約を加えるだけです)、我々は&quot;and&quot; junctionのように型の並びを許可するためにこれを緩和します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは他のどの様な変数と同じように型を与えられるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の中で、クラス変数(それ自身か既存の型名の後のどちらか)は新しい型名を宣言し、実際のパラメータの型と関連づけられているパラメータ付きの値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It declares the new type name in the same scope as the associated declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは関連付けられた宣言として同じスコープ内で新しい型名を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい型名は直ちに取り込まれ、同じシグネチャ内の2つのそのような型は同じ名前の場合は互換性を統一する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a scoped subroutine, a return type can be specified before or after the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スコープ付きサブルーチンでは、返値の型は名前の前か後で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call all return types &quot;return types&quot;, but distinguish two kinds of return types, the as type and the of type, because the of type is normally an &quot;official&quot; named type and declares the official interface to the routine, while the as type is merely a constraint on what may be returned by the routine from the routine's point of view.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々は返値の型を&quot;return types&quot;と呼びますが、as型とof型の2種類の返値の型は区別します。なぜならof型は通常は&quot;official&quot;な名前を付けられた型名で、ルーチンに対するオフィシャルなインターフェースを宣言します。asは単にルーチン視点でルーチンによって何が返されるかの制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it's scoped with the our scope modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしサブルーチンが明示的にスコープ化されていないなら、それはourスコープ修飾子でスコープ化されるかのように現在の名前空間(モジュール、クラス、grammarまたはパッケージ)に属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any return type must go after the name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はどれでも名前の後に移動する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On an anonymous subroutine, any return type can only go after the sub keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名サブルーチンでは、どの返値の型もsubキーワードの後にしか移動できません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but you can use a scope modifier to introduce an of prefix type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of後置型を導入するためにスコープ修飾子を使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are anonymous, you can change the my modifier to our without affecting the meaning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは無名なので、my修飾子は意味に影響を与えずに ourに変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type may also be specified after a --&gt; token within the signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はシグネチャの中で--&gt;トークンの後で指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This doesn't mean exactly the same thing as as.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはasと正確に同じ意味があるものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The of type is the &quot;official&quot; return type, and may therefore be used to do type inferencing outside the sub.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型は&quot;official&quot;な返値の型で、サブルーチンの外側で型推論を行うために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as type only makes the return type available to the internals of the sub so that the return statement can know its context, but outside the sub we don't know anything about the return value, as if no return type had been declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as型はサブルーチンの内部で利用できる返値の型を作るだけで、return文がそのコンテキストを知ることができますが、サブルーチンの外側では返値の型が宣言されていないかのように返値の型に関して何も知ることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prefix form specifies the of type rather than the as type, so the return type of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置形式はas型よりもof型を指定するので、返値の型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is known to return an object of type Fish, as if you'd said:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はあなたが次のようにしたかのようにFish型のオブジェクトを返すと知ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not as if you'd said</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のようにではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible for the of type to disagree with the as type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型とas型を区別することが可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または同じに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of sigils to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は変数の基本的な構造をマークするためのsigilsシステムを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, the &amp; sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言内で&amp; sigilはスコープ宣言内のsigil無しにサブルーチン名の可視性も宣言します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a signature or other declaration, the :: sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャか他の宣言内で、識別子が続く:: sigilはpackage/type名の可視性をスコープ宣言のsigil無しに宣言する型変数をマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初はそのようなスコープ付きの宣言はバインドされない型とみなされ、その関連付けられた引数の実際の型を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後に続く同じスコープの宣言内のsigilは任意なので、裸の型名も宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内側をネストする宣言は同じ型を参照したい場合はsigilを使うことは出来ません。内側の宣言は型を再バインドするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(pointy blockのシグネチャは外側のブロックではなく内側のブロックとして数えられルので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsはバインドされたオブジェクトの正確な型ではなく、全体的なインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるsigilsはわずかな異なる能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなスカラー変数はオブジェクトが本質的に複合型か単一型かどうかに関わらず常にどのようなリストコンテキストでも単数形アイテムとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの種類のデリファレンスコンテキストに置かれなければ、その内容は自動的にデリファレンスされないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly though it just means that you want to give some abstraction an official name that you can then use later in the compilation without any sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはコンパイル中になんらかのsigil無しに抽象化に後で使えるように公式な名前を与えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのような場合でも、sigilによって意味づけされた最小のコンテナroleは最新のバインディング時にチェックされ、文法エラーがすぐに検出できるなら（コンパイル時のような）早期に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなリストの添字は元のオブジェクトの添字を意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、もはやsigilとそれに続く名前または構造の間に空白を置けないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通のsigilsは通常のスコープ変数、レキシカルかパッケージスコープを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oddly scoped variables include a secondary sigil (a twigil) that indicates what kind of strange scoping the variable is subject to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変なスコープ変数は変数がどの種類の奇妙なスコープに従属するかを示す2つ目のsigil(twigil)を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &quot;my&quot; or &quot;our&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのtwigils変数は暗黙に他のスコープに宣言されるか宣言されていると見なされ、&quot;my&quot;か&quot;our&quot;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attribute variables are declared with has, though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性変数はhasで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsは今は変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ always means a scalar variable, @ an array variable, and % a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$は常にスカラー変数を意味し、添字がある場合でも@は配列、%はハッシュ変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as @array and %hash simply return themselves as Array and Hash objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アイテムコンテキストでは@arrayや%hashのような変数は単純にそれら自身をArrayやHashオブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Item context was formerly known as scalar context, but we now reserve the &quot;scalar&quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(アイテムコンテキストは以前はスカラーコンテキストとして知られていましたが、われわれは&quot;scalar&quot;の概念をコンテキスト（リストコンテキストからの配列の解除）よりも変数のことに関しての話と予約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列コンテキストではコンテナオブジェクトは自動的に適切な文字列値に文字列化(空白で区切られた)されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールコンテキストでは、コンテナに要素がある場合だけtrue値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a Perlish representation of any object, use the .perl method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのPerlっぽい表現を得るには.perlメソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the Data::Dumper module in Perl 5, the .perl method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5のData::Dumperモジュールのように、.perlメソッドは文字列にクォートを置き、リスト値に角括弧を置き、ハッシュ値にカーリーを置きます。なのでPerlは結果を評価して同じオブジェクトに戻せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .perl method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.perlメソッドはオブジェクトの想定の表現を返し、もしコードが同じ点で再解析されたら、アイテムコンテキストでオブジェクトをスカラーとして再出力するのに使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use &lt;prefix:&lt;| &gt;&gt; to force interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし再解析されたオブジェクトをリストコンテキストに挿入したいなら、&lt;prefix:&lt;| &gt;&gt;を強制挿入のために使う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the .fmt('%03d') method to do an implicit sprintf on the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スカラー値のフォーマットされた表現を得るには、値に暗黙のsprintfを行う.fmt('%03d')メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は一貫して左にあるどんなものにでも作られたコンテナをデリファレンスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数名と添字の間の空白は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、構造を視覚的に引き延ばす2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a subscript is a kind of postfix operator, there is a corresponding dot form of each subscript (@foo.[1] and %bar.{'a'}) that makes the dereference a little more explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は後置演算子の一種なので、それぞれの添字に対応するdot形式があります(@foo.[1]と%bar.{'a'})。それはデリファレンスをより少し明示的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant string subscripts may be placed in angles, so %bar.{'a'} may also be written as %bar&lt;a&gt; or %bar.&lt;a&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数文字列の添字はangles内に置かれます。つまり%bar.{'a'}は%bar&lt;a&gt;か%bar.&lt;a&gt;とも書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceを使って追加の空白を挿入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシングは添字の性質で指定され、sigilによってではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More specifically, they are evaluated in a variant of list context known as slice context, which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より正確には、それらはsliceコンテキストというリストコンテキストの変化形で評価され、それは次元的情報を保存し、あなたはmulti-dimensionalスライスをセミコロンを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それぞれの次元のスライスは普通のリストコンテキストなので添字の一部で呼ばれた関数はsliceコンテキストを認識しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし内部のコンテキストをアイテム(スカラー)コンテキストに強制したいなら+を数値コンテキスト、~を文字列コンテキストに指定するなどの便利な単一文字のspecifiersがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils used either as functions or as list prefix operators also force context, so these also work:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsを関数として、またはリストの前置演算子として使うかどちらかによってもコンテキストを強制できます。なのでこれらはこのようにも動きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこれらは同じではないので注意して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストバインディングからリストの割り当てを識別する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストの割り当てはPerl 5のように、値をコピーして動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a new := binding operator that lets you bind names to Array and Hash objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい:=バインディング演算子があり、それはコピー無しにArrayとHashオブジェクトを名前にバインディングし、サブルーチンの引数の同じ方法ではパラメータに正式にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バインディングについて詳しくはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An argument list may be captured into an object with backslashed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数リストはバックスラッシュ括弧でオブジェクトに取り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in a Capture object are parsed as ordinary expressions, then marked as positional or named.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Captureオブジェクト内の値は普通の式としてパースされ、順番か名前でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように解決されるかは最終的に何にバインドされるかに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他がそうでない場合に、いくつかのバインディングは複数の次元に敏感です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When cast into an array, you can access all the positional arguments; into a hash, all named arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列にキャストすると全てのポジショナル引数にアクセスできます。ハッシュなら全ての名前付き引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての前置sigil演算子は一つのポジショナル引数を許容します。それは右辺値としてアイテムコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはもし括弧で呼ばれたら文字列に差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of them as &quot;fat&quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは&quot;fat&quot;リファレンスと考えることができます。それは現在のシングルオブジェクトのアイデンティティだけでなく、関連するいくつかのオブジェクトを取り込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (Signature) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャオブジェクト(Signature)はコロン前置の括弧で作成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャ中の式は普通の式ではなくパラメータ宣言として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの文法の詳細についてはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数にバインドされたシグネチャオブジェクト(上記の例のように)は追加の型制約を適用するために他のシグネチャと共に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &amp;foo merely stands for the foo function as a Routine object without calling it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と異なり、&amp;fooという表記は単に関数fooをRoutineオブジェクトとして呼び出し無しに表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧でデリファレンスしてCodeオブジェクトを呼べるでしょう(もちろん引数を含めて):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の前に空白は許されません。なぜなら括弧は後置として解析されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any postfix, there is also a corresponding .() operator, and you may use the &quot;unspace&quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのpostfixとも同じように、対応する.()演算子があり、オプショナルな空白やコメントを挿入するために間にバックスラッシュで&quot;unspace&quot;を使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the parentheses around arguments in the &quot;normal&quot; named forms of function and method calls are not postfix operators, so do not allow the .() form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通の形式の名前に付けられた括弧は関数かメソッド呼び出しですが後置演算子ではありません。そのため.()形式は許されません。なぜならドットは実際にはデリファレンス演算子を示すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの特別な場合にドット形式を使う場合は、引数無しに名前付き形式を呼ぶか、結果をデリファレンスしたいということを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With multiple dispatch, &amp;foo may actually be the name of a set of candidate functions (which you can use as if it were an ordinary function).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マルチディスパッチにおいては&amp;fooは実際には候補関数のセットの名前になります(それは普通の関数であるかのように使うことが出来ます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &amp;foo by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこの場合は&amp;foo自身は特定の関数の関数名となるには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定するために、型は後置演算子のシグネチャリテラルを使ってリファインされるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It still just returns the Routine object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはまだRoutineオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied by using the .assuming method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>呼び出しは.assumingを使うことによっても部分的に適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシング文法はS09でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元スライスは個々のスライスサブリストの間のセミコロンで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such slice sublist is evaluated lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのスライスサブリストは曖昧に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライスの添字を値以外の何かを返すようにさせるには、添字に適切な副詞を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの副詞的形式は存在しないエントリーを取り去ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, which will return true if all the elements of the slice exist:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのスライスの要素が存在するならtrueを返すテストを実行することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>likewise,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &quot;en passant&quot; while returning them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は値を返すついでに削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろん単一のインデックスのスライスでもこれらの形式は動きます。)添字が最も前の演算子であるという事実のおかげでこれらが動くということに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(このようなスライス修飾子はめったには起こりません。なぜならそれらは普通はコンマの優先順位を操作するリストコンテキストで使用されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into Int or Num), a Hash object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキスト(IntかNumにキャストされる場合)、Hashオブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール値コンテキストではなんらかのペアがハッシュにあればtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, any intrinsic iterator would be reset.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの場合で、内在のイテレータはリセットされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ペアのリストをソートするとデフォルトでキーでソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of lists should sort on the first elements, then the second elements, etc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストのリストをソートすると最初の要素でソートし、次に2番目の要素で、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on sort see S29.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sortの詳細についてはS29を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5の特殊変数はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りの特殊変数はレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes $_ and @_, as well as the new $/, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは$_と@_を含み、同様に新しい$/は最後の正規表現マッチの返値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$0, $1, $2, etc., are aliases into the $/ object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$0、$1、$2などは$/オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $#foo notation is dead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$#foo表記法はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use @foo.end or @foo[*-1] instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@foo.endか@foo[*-1]を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or @foo.shape[$dimension] for multidimensional arrays.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(または@foo.shape[$dimension]を多次元配列に使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は英数字が続くアルファベットで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルファベットと数字の定義は適切なユニコード文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコアは常にアルファベットと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は次の文字がアルファベットの孤立したアポストロフィかハイフンを含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は変数名の適正な部分のことです(sigilは数えません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは以下を含みます。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
