<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5_4"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>と</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document originally summarized Apocalypse 1, which covers the initial design concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 1を要約したもので、初期のデザインコンセプトを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That original summary may be found below under &quot;Random Thoughts&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>原文の概要は &quot;Random Thoughts&quot; 以下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>歴史的資料として凍結されるApocalypsesと違い、SynopsesはPerl 6の設計の更新も反映します 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの更新点は記録されません ― SynopsisがApocalypseと違う場合はSynopsisが正しいと見なして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another assumption has been that if we don't talk about something in these Synopses, it's the same as it is in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つの前提として、これらSynopsesで我々が話題にしないことはPerl5と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Soon we plan to fill in the gaps with the Perl 5 details though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もうすぐ我々はPerl 5の細部とのずれを埋める予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly, we're just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大抵の場合、我々は餌を巣に運ぶアリのような集団に過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主にボランティアによって、多くのグループが適当にこまごまとした仕事を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not attempt to summarize all these subprojects--see the various websites for Parrot and Pugs and Perl 6 for such information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはこれらのサブプロジェクトを全て要約するわけではありません。そのような情報はParrotやPugsやPerl 6のウェブサイトなどを参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が言えることは、Perl 5の場合と違ってこれらのプロジェクトは公式のPerlとは異なるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is anything that passes the official test suite.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公式のテストスイートをパスしたものは全てPerl 6なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This test suite was initially developed under the Pugs project because that project is the furthest along in exploring the high-level semantics of Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>当初、このテストスイートはPugsプロジェクトの元で開発されました。Perl 6の開発に関してPugsプロジェクトが最も先行していたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Other projects are better at other things, such as speed or interoperability.) However, the Pugs project views the test suite as community property, and is working towards platform neutrality, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(他のプロジェクトは速度や相互運用性などの面では優れています。)しかしPugsプロジェクトはテストスイートをコミュニティの所有物と考えており、プラットフォームに対して中立になることを目指しているので、このテストが動作するものをPerl 6とすることにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another aspect of this is the Perl 6 compiler will be self-hosting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の側面は、Perl 6コンパイラをセルフホスティングすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々なコード出力バックエンドが開発されたら、最終的にはコンパイラ自身をコンパイルするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは主にフロントエンドからプラットフォームの依存性を取り除き、バックエンドだけがプラットフォーム固有の問題を気にするようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &quot;apocalypse&quot; historically meant merely &quot;a revealing&quot;, and we're using it in that unexciting sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;apocalypse&quot; という言葉は歴史的には啓示することを意味します。我々はそのありきたりな意味で使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたがRFCを一般人に尋ねたら、興味深いが矛盾した多くのアイデアを得るでしょう。人々の意見は極端に分かれがちで、どのアイデアもお互いに構築することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry's First Law of Language Redesign: Everyone wants the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Larryによる新しい言語設計の最初の秩序：みんながcolonを望む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 2の要約で、小規模の字句項目と類型的問題を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(These Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Apocalypsesと違い、これらのSynopsesは時間と共に進化するPerl 6のデザインの更新を反映します。 Apocalypsesは歴史的資料としてある時点で凍結されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの更新は記録されません―SynopsisがApocalypseと異なるなら、Synopsisが正しいと見なして下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブ言語のパーサーによる拡張のために、Perlはワンパスの予測的パーサーによって解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, lookahead of more than one &quot;longest token&quot; is discouraged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり、複数の最長トークンの先読みは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これについて現在知られている例外は、パーサーが以下のようにしなければならない場合です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sigilで始まり、ブロックで終わる、または終わらないかもしれない展開式の終了位置を決定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recognize that a reduce operator is not really beginning a [...] composer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>減少演算子が[...]の生成を開始するとは限らないと認識する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>理論上はPerlはユニコードで記述され、基本的なテキスト表現に関係なく一貫したユニコードのセマンティクス(意味)を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default Perl presents Unicode in &quot;NFG&quot; formation, where each grapheme counts as one character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの書記素が1文字として数えられる場所では、PerlはデフォルトでユニコードをNFG形式で表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書記素とは初心者ユーザーが日常生活の中で考えると思われるあらゆる発音記号を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlはユニコードの行とパラグラフのセパレータを行マーカーとして数えることが出来ます。しかし、その振る舞いはあなたのエディタが考えるユニコードの行とPerlの行番号の考え方がマッチするように設定出来るべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコードの水平空白は空白として数えられます。しかし、単独のトークンに見えるような隣接したトークンを生成するような場所ではem幅の空白は使わないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方でPerlはインデントを文法として使わないので、空白が意味をなす場所ではいくらでも自由に空白を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは常に空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの構文上の目的で、Perlは括弧でないものから括弧文字を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧文字は双方向対称かPs/Pe/Pi/Pfプロパティのどちらかのユニコード文字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実用上はPs/Pe/Pi/Pfプロパティの文字を使うのが最も安全ですが、ASCIIの不等号括弧はPs/Pe/Pi/Pfセットではないのに双方向なので注目すべき例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する閉じ文字がない文字は括弧の開始と見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはユニコードBidiMirroringデータテーブルの第2セクションを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字が既にPs/Pe/Pi/Pfマッピングで使用されている場合、どのBidiMirroringのエントリも無視されます（前方、後方マッピング両方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any given Ps character, the next Pe codepoint (in numerical order) is assumed to be its matching character even if that is not what you might guess using left-right symmetry.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のPs文字に対して次のPeコードポイント(番号順)は、たとえあなたが左右対称だと思っていなくてもマッチする文字と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore U+298D maps to U+298E, not U+2990, and U+298F maps to U+2990, not U+298E.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従ってU+298DはU+2990ではなくU+298Eにマップされ、U+298FはU+298EではなくU+2990にマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither U+298E nor U+2990 are valid bracket openers, despite having reverse mappings in the BidiMirroring table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+298EとU+2990はどちらも括弧の開始ではありません。にもかかわらずBidiMirroringテーブルに逆のマッピングを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The U+301D codepoint has two closing alternatives, U+301E and U+301F; Perl 6 only recognizes the one with lower code point number, U+301E, as the closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+301Dコードポイントは2つの代替の終了文字を持っています。U+301EとU+301Fです。Perl 6は低いコードポイント数のU+301Eだけを閉じブレースとして認識します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This policy also applies to new one-to-many mappings introduced in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このポリシーは未来に登場する新しい1対多のマッピングにも適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, many-to-one mappings are fine; multiple opening characters may map to the same closing character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、多対1は構いません。複数の開始文字は同じ終了文字にマップするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, U+2018, U+201A, and U+201B may all be used as the opener for the U+2019 closer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばU+2018、U+201A、U+201Bは全てU+2019クローザーに対するオープナーとして使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs that count openers and closers assume that only the given opener is special.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オープナーとクローザーを考慮する構造は、与えられたオープナーだけが特別と見なします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if you open with one of the alternatives, all other alternatives are treated as non-bracketing characters within that construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり代替文字の1つで開く場合、他の代替文字はその構造では非括弧文字として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POD sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6ではPODセクションは複数行コメントとして確実に使用されるようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, POD syntax now lets you use =begin comment and =end comment delimit a POD block correctly without the need for =cut.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、現在のPOD構文は=begin commentと=end commentを=cut無しでPODブロックを正しく区切って使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In fact, =cut is now gone.) The format name does not have to be comment -- any unrecognized format name will do to make it a comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(現に、=cutは無くなりました。)フォーマット名は commentである必要はありません。識別されないフォーマット名はコメントになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, bare =begin and =end probably aren't good enough, because all comments in them will show up in the formatted output.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(しかし、裸の=beginと=endではおそらく不十分です。その中の全てのコメントがフォーマットされて表示されてしまうからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have single paragraph comments with =for comment as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、単独のパラグラフコメント=for commentがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That lets =for keep its meaning as the equivalent of a =begin and =end combined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは=forを=beginと=endが結合したものと同等の意味を持つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with =begin and =end, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>=beginと=endのように、コメントはコードの前から後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is a newline before the first =, the POD form of comment counts as whitespace equivalent to a newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の=の前に改行が現れるまで、POD形式のコメントは改行と同様に空白としてカウントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みドキュメントの詳細はS26を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except within a string literal, a # character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6では文字列リテラルを除いて、#は常にコメントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two forms of comment based on #.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#を元にしたコメントは2つの形式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments require the # to be followed by one or more opening bracketing characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントは1つかそれ以上の括弧の開始文字が続く#を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other uses of # are interpreted as single-line comments that work just as in Perl 5, starting with a # character and ending at the subsequent newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その他の#の使用はPerl 5のように1行コメントとして解釈され、#で始まって次の改行で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは分割を目的とした改行と同じく空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, # may not be used as the delimiter in quoting constructs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、#はクォートを構築する区切り文字としては使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments are supported as a variant on quoting syntax, introduced by # plus any user-selected bracket characters (as defined in Lexical Conventions above):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントはクォーティング構文の変化形としてサポートされ、#とユーザーが選んだ括弧文字(Lexical Conventionsで定義されているもの)で導入されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧は普通の引用括弧と同じポリシーに沿ってネストするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There must be no space between the # and the opening bracket character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の開始文字と#の間に空白を置くことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There may be the visual appearance of space for some double-wide characters, however, such as the corner quotes above.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(上記のかぎ括弧のように見栄えのあるダブルワイド文字がいくつかあります。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded comment is not allowed as the first thing on the line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行頭に埋め込みコメントを置くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to have a comment there, you must disambiguate it to either an embedded comment or a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそこにコメントを置きたいなら、埋め込みコメントか行コメントの曖昧さをなくす必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put a space in front of it to make it an embedded comment:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントにするために、前に空白を置くことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can put something other than a single # to make it a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または行コメントにするために単一の#以外のものを置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if you are commenting out a block of code using the line-comment form, we recommend that you use ##, or # followed by some whitespace, preferably a tab to keep any tab formatting consistent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って、もしコードブロックを行コメントを使ってコメントアウトするなら、空白(タブによるフォーマッティングを一貫するならタブが好ましい)が続く##か#を使うことをお勧めします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's often better to use pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、PODコメントは暗黙の行指向なのでそちらの方が良い場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if you have an intelligent syntax highlighter that will mark pod comments in a different color, there's less visual need for a # on every line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに、もしあなたがPODコメントを色分けする賢いシンタックスハイライターを持っているなら、それぞれの#の行に必要なビジュアルが少なくなってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザーが選んだ括弧のクォート構文で、複数の一致する括弧文字を使うことが出来ます。閉じ括弧は同じ数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧のネストは開き括弧と同じ数でなければ適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that bare circumfix or postcircumfix &lt;&lt;...&gt;&gt; is not a user-selected bracket, but the ASCII variant of the «...» interpolating word list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし注意として、裸の接周辞または後置接周辞&lt;&lt;...&gt;&gt;はユーザー選択の括弧ではなく、«...»のワードリストを展開したASCII形式の別記法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only # and the q-style quoters (including m, s, tr, and rx) enable subsequent user-selected brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#とqスタイルのクォート(m、s、 tr、rxを含む)だけが後に続くユーザー選択の括弧を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C言語のようないくつかの言語は、行を結合するために改行をエスケープすることを認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の言語(正規表現など)は空白文字のバックスラッシュを様々な理由で認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はこの概念をあらゆる種類の空白に一般化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with \.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる連続する空白(コメント含む)は\を前置することによってパーサーから隠蔽されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as the &quot;unspace&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはunspaceとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはPerlの様々な空白のいずれかの依存関係を隠することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばPerlは名詞と後置演算子の間に空白が無いことを要求するので、unspaceを使うことで後置演算子を繋げることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の使い方をサポートするための特別な場合として、後置演算子が期待される場所でのバックスラッシュはunspaceの変質した形式と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意として、それの前に空白は置けません。そのため</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は構文エラーです(行に2つの項)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will be parsed as a list operator with a Capture argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はCapture引数を伴うリスト演算子と解析されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、他の形式のunspaceは空白の前にきて役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それ故に単項のバックスラッシュの使われ方は空白が続かないこと、または空白をunspaceと受け取ることです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の後置演算子もunspaceを活用できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つ見えない空白の使い方は、典型的にはドット後置演算子を次の行に置くことです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But unspace is mainly about language extensibility: it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしunspaceは主に言語の拡張性に関するものです。あなたが現在インストールしているパーサーに関わらず、改行がパーサーを混乱させるかもしれないあらゆる場面で行を継続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, you override the unspace rule itself...)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろん、あなたがunspaceのルール自体を上書きすれば別ですが・・・)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、unspaceはパーサーから空白を隠しますが、レクサーからは隠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果として、unspaceはトークンとして認められません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceが1つ以上の改行を含むなら依然として行番号がカウントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A # following such a newline is always an end-of-line comment, as described above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような改行に続く#は上に述べたように常に行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Podチャンク(かたまり)は言語にとって空白として数えられるので、それもunspaceによって取り込むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントの境界は隠蔽されます。けれども、あなたは過度に長いヒアドキュメントの出だしの行をこのように分割できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントのパーサーは単にこのように見ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is one of those cases in which it is fine to have whitespace before the unspace, since we're only trying to suppress the newline transition, not all whitespace as in the case of postfix parsing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意として、これはunspaceの前に空白を置いても構わないケースの1つです。なので接尾辞の解析については我々は全ての空白ではなく改行の変わり目を隠そうと試みているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that the example above is not meant to spec how the test suite works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(さらに注意として、上記の例はテストスイートの動作仕様を意図していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはコメントを含むかもしれませんが、コメントはunspaceを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、行コメントはバックスラッシュを意味のあるものとして扱いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is an end-of-line comment, not an embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントではなく行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のように書くと:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に、単独のトークンか他の構文上の単位と間違って解釈される構成を分離する必要がある場所を除いて、Perl 6での空白は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, Perl 6 follows the standard longest-token principle, or in the cases of large constructs, a prefer shifting to reducing principle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、Perl 6は標準の最長トークンの原則、または大きな構文の場合はprefer shifting to reducingの原則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Grammatical Categories below for more on how a Perl program is analyzed into tokens.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlプログラムがどのようにトークンに解析されるか、詳細についてはGrammatical Categoriesを参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは不変の深いルールです。しかしPerl 6は可変の言語となるように設計されているので、様々な演算子や言語にマクロを追加したり削除することで表面上の悪影響を変えるということが起こるのを我々は期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、項の後で後置演算子と2項演算子の間の自然な競合がどちらかで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし与えられたトークンが後置演算子か2項演算子と解釈されそうなら、2項演算子の前に空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置演算子は間に入る空白を持ちませんが、間に入るドットを持つことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上で分離が望まれるなら、空白がunspaceか埋め込みコメントの外側に発生しない限り前述のunspaceか埋め込みコメントが使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you were to add your own infix:&lt;++&gt; operator, then it must have space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばあなたのinfix:&lt;++&gt;という2項演算子を追加するとしたら、その前に必ず空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal autoincrementing postfix:&lt;++&gt; operator may never have space before it, but may be written in any of these forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準の自動インクリメントpostfix:&lt;++&gt;演算子はその前に空白を持ちませんが、これらの形式のどれかで書かれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on $_ where a term is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(クォートを区切るかunspaceを終了することは除いて)項が期待される場所で前に空白があるドットは常に$_のメソッド呼び出しとみなされます。 それが接尾辞のルールの結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その箇所で項が期待されていないなら、それは構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろんドットで始まる名前の2項演算子があるなら別ですが。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could, for instance, define a Fortranly infix:&lt;.EQ.&gt; if the fit took you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、その気になればFortran風のinfix:&lt;.EQ.&gt;を定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしあなたはそれの前に常に空白を置くか、代わりに後置メソッド呼び出しと解釈されるようにして気をつけなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に次のように解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のいくつかの変化形を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし後置のメソッド呼び出しを意味するなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of all this is that you may no longer write a Num as 42. with just a trailing dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これら全ての内の1つの結果として、ただの終端ドットを伴うNumを 42.として書くことはもはやできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must instead say either 42 or 42.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりにあなたは42か42.0のどちらかにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば、もし直後の文字が数字なら、数の直後のドットは小数点にしかなり得ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、後置のドットはいくつかの種類のメソッド呼び出し構文の開始と取られるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The .123 form with a leading dot is still allowed however when a term is expected, and is equivalent to 0.123 rather than $_.123.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(項が期待される場合でも、直前のドットを伴う.123形式がまだ認められています。そしてそれは$_.123ではなく0.123と同じです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In support of OO encapsulation, there is a new fundamental datatype: P6opaque.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト指向カプセル化のサポートの中で、新しい基本データ型があります: P6opaqueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>opaqueオブジェクトへの外部からのアクセスは常にメソッド呼び出しを通して行われます。属性でさえそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はより安全でより良く動作するコードを書くことを助ける選択自由な型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがあなたの提供可能な型情報を推測するのは自由です。しかしあなたが尋ねない限り、欠落した型情報について文句を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は構造的な等価性よりも名前の等価性で正式に比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、我々は名前を考えることに寛大であることを好みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &quot;anonymous&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、名前は型を定義するモジュールに関連付けられたバージョンと権限を含みます(たとえ型自体が無名でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &quot;long name&quot; of the resulting type, so one Array of Int is equivalent to another Array of Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上でパラメータを伴う型をインスタンス化する場合、引数は結果となる型の長い名前の一部と考えられるので、あるArray of Intは他のArray of Intと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Another way to look at it is that the type instantiation &quot;factory&quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それを調べるもう一つの方法は、型をインスタンス化するファクトリーがメモ化されることです。)型名の別名は元の型と同等とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the Array of Int syntax is just sugar for Array:of(Int), which is the canonical form of an instantiated generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にArray of Intという構文はインスタンス化されたジェネリックタイプの正規形であるArray:of(Int)の単なるシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このパラメータを伴う型の名前の等価性は不変(または少なくとも不変のスナップショットを撮ることが出来る)とみなせるパラメータだけを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別個の2つのクラスはたとえ同じ属性を持っていても決して同等とは見なされません。なぜならクラスは不変とみなされないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of properties on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は様々な種類のオブジェクトでプロパティの概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのクラスではなく個々のオブジェクトに管理されている場合を除いて、プロパティはオブジェクトの属性に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S12に従って、プロパティは実際にはミックスインメカニズムのようなもので実装され、そのようなミックスインはオブジェクトに対する個々の無名クラスの生成によって完成します(同じ無名クラスがまだ存在せず、安全に共有できるのであれば)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティはコンパイル時に構成される変数やクラスなどに適用され、トレイトとも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トレイトを実行時に変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時のプロパティの変更は代わりにミックスインによって行われます。これによってコンパイラーは宣言されたトレイトを元に最適化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンですが、都合が悪いならオブジェクト指向で考える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ファイルハンドルのようないくつかのビルトインの概念はPerl 5以上にユーザーに見える形でオブジェクト指向的になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数の型とは、変数がどのような値を含む可能性があるかを示す制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &quot;role&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より正確には、オブジェクトまたは変数に格納されたオブジェクトがroleで示されたメソッドに応答できることの保証です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数自体はどの種類のものを含むか指定せず、どのように動作するかを指定するコンテナ型にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制約とコンテナ型は一緒に使用することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that $x is also initialized to the Int type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$xがInt型オブジェクトで初期化されることにも注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これについて詳しくは以下を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my Dog $spot by itself does not automatically call a Dog constructor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>my Dog $spot自体はDogのコンストラクターを自動で呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined Dog prototype object to $spot:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは単に未定義のDogプロトタイプオブジェクトを$spotに割り当てます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is an undefined instance of that type's prototype object, or type object for short.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値として使われる任意の型名はその型の未定義のプロトタイプオブジェクト、短くはタイプオブジェクトのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>右辺コンテキストでの型名は単独の型の値としてパースされ、それに続く引数がないことを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしタイプオブジェクトは関数呼び出しインターフェースに応答するので、あなたは型の名前を括弧と一緒に関数であるかのように使用するでしょう。そして呼び出しに供給されるどんな引数もタイプオブジェクトの示す型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしも括弧に引数が無いなら、タイプオブジェクト自身を返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a real Dog object, call a constructor method such as new:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当のDogオブジェクトを得るために、newのようなコンストラクタメソッドを呼んで下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様にコンストラクタに引数を渡すことも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you are declaring that the elements of @array are native integers, but that the array itself is implemented by the MyArray class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@arrayの要素をネイティブ整数と宣言しますが、配列自身はMyArrayクラスで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型指定されていない配列とハッシュはいまだに何でも受け入れますが、Perl 5と同じパフォーマンスの問題を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the .elems method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の要素数を得るには.elemsメソッドを使用して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also ask for the total string length of an array's elements, in bytes, codepoints or graphemes, using these methods .bytes, .codes or .graphs respectively on the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、.bytes、.codes、.graphsメソッドを使用してバイト、コードポイント、書記素でそれぞれの配列要素の文字列の長さの合計を求めることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に文字列にも同じメソッドを適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that .bytes is not guaranteed to be well-defined when the encoding is unknown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(.bytesはエンコーディングが不明な場合は明確には保証されないので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, .codes is not well-defined unless you know which canonicalization is in effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、.codesはどの正規化が有効なのか不明な場合は明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, both methods allow an optional argument to specify the meaning exactly if it cannot be known from context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのため、両方のメソッドはコンテキストから知ることができない場合に正確な意味を指定するための任意の引数を受け入れます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no .length method for either arrays or strings, because length does not specify a unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.lengthメソッドは配列と文字列のどちらにもありません。なぜならlengthは単位を指定しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルトインオブジェクト型は大文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes immutable types (e.g. Int, Num, Complex, Rat, Str, Bit, Regex, Set, Block, List, Seq), as well as mutable (container) types, such as Scalar, Array, Hash, Buf, Routine, Module, and non-instantiable Roles such as Callable, Failure, and Integral.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変更不可の型を含みます(Int、Num、Complex、Rat、Str、Bit、Regex、Set、Block、List、Seqなど)。変更可能な(コンテナ)型も同様です。Scalar、Array、Hash、Buf、Routine、Moduleなど。そしてインスタンス化できないCallable、Failure、Integralなども同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-object (native) types are lowercase: int, num, complex, rat, buf, bit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトでない(ネイティブ)型は小文字です: int、num、complex、rat、buf、bit。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型は主にコンパクトな配列ストレージを宣言するためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、Perlはそれらを対応する大文字の型のように扱えるようにしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it does autoboxing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、自動ボックス化を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that sometimes repeated autoboxing can slow your program more than the native type can speed it up.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、自動ボックス化の繰り返しがネイティブ型のスピードアップ以上にプログラムを遅くすることもあるので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The junction type is considered a native type because its internal representation is fixed, and you may not usefully derive from it because the intent of junctions is to autothread any method calls on them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内部表現が固定されているので、junction型はネイティブ型と見なされます。そしてjunctionの意図はあらゆるメソッド呼び出しを自動スレッド化することなので、それから有益に派生させることはできないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのオブジェクトは値型として振る舞うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a &quot;WHICH&quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトはハッシュと値ベースの比較のために一意に識別するためのWHICH値を出力できます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal objects just use their address in memory, but if a class wishes to behave as a value type, it can define a .WHICH method that makes different objects look like the same object if they happen to have the same contents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常のオブジェクトはそれらのメモリアドレス使うだけですが、クラスが値型として振る舞いたい場合に、異なるオブジェクトが同じ内容を持つ場合が発生するなら同じオブジェクトのように見せる.WHICHメソッドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with non-native types can always contain undefined values, such as Object, Whatever and Failure objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型を伴う変数は常にObject、Whatever、Failureオブジェクトなどのundefined値を含むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S04 for more about failures (i.e. unthrown exceptions):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>failures(例えばunthrown exceptionsなど)の詳細についてはS04を参照して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型を伴う変数は未定義をサポートしません: 未定義値をそれらに割り当てるとエラーになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測: numはundefからNaNへの自動変換をサポートするかもしれないので、浮動小数点形式はこの概念を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ロケットの設計者が自己破壊を即座に行うかその後間もなく行うか決めることが出来るように、その変換を任意に出来るなら良いかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables of non-native types start out containing an undefined value unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型は明示的に定義された値で初期化されなければ未定義値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object supports a HOW function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトは、オブジェクトが定義されているかどうかに関わらずそれを管理するメタクラスのインスタンスを返すHOW関数/メソッドをサポートします: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(プロトタイプシステム(クラスベースでないオブジェクトシステム)のために、全てのオブジェクトは単に同じメタオブジェクトによって管理されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は型宣言のシステムを通してbig integersとbig rationalsを本質的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int automatically supports promotion to arbitrary precision, as well as holding Inf and NaN values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IntはInf値とNaN値を保持するのと同様に任意の精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Int assumes 2's complement arithmetic, so +^1 == -2 is guaranteed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Intは2の補数演算を想定することに注意して下さい。なので+^1 == -2が保証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Native int operations need not support this on machines that are not natively 2's complement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ネイティブのint演算は2の補数をネイティブにサポートしていないマシンではサポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must convert to and from Int to do portable bitops on such ancient hardware.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはIntへの変換や逆のことをそのような古いハードウェアで移植性のあるビット演算に出来るようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Num may support arbitrary-precision floating-point arithmetic, but is not required to unless we can do so portably and efficiently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Numは任意の精度の浮動小数点演算をサポートします。しかし移植性があり効率的に行うことが出来ないのであれば必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Num must support the largest native floating point format that runs at full speed.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Numは最も大きいネイティブ浮動小数点フォーマットをフルスピードで実行できるようにサポートしなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rat supports arbitrary precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Ratは任意の精度の有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, dividing two Int objects using infix:&lt;/&gt; produces a fraction of Num type, not a ratio.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、2つのIntオブジェクトをinfix:&lt;/&gt;で除算するとレシオではなくNum型の端数を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can produce a ratio by using infix:&lt;div&gt; on two integers instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりにinfix:&lt;div&gt;を使ってレシオを生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lower-case types like int and num imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>int、numのような小文字型はマシンネイティブの整数と浮動小数点表現を意味します。それぞれは任意の精度へ昇格しませんが、テンポラリ値についてはより大きい表現が常に許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless qualified with a number of bits, int and num types represent the largest native integer and floating-point types that run at full speed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット数で制限されなければ、intとnum型はフルスピードで実行される最も大きな整数と浮動小数点を表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric values in untyped variables use Int and Num semantics rather than int and num.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型のない変数での数値はIntとNumをintとnumより優先して使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 should by default make standard IEEE floating point concepts visible, such as Inf (infinity) and NaN (not a number).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はデフォルトでInf(無限)とNaN(数でない)のような標準のIEEE小数点概念を見えるようにするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープ内でプラグマはテンポラリ値の性質、そして様々な環境下で浮動小数点がどの様に振る舞うか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>うまく機能しないプラットフォームを回避するために壮大な努力を必要とする場合を除いて、全てのIEEEモードがプラグマによってレキシカルに使用可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルトの浮動小数点モードは例外をスローするのではなくInfとNaNを伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ボックス化されたオブジェクト型はオーバーフローかアンダーフローが発生したところでより詳細な情報を伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlでの計算法はどこでも同じ答えを与えるように設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are designed to give the typical programmer the tools to achieve a good enough answer most of the time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは一般的なプログラマーにほとんどの場合十分な答えを果たすツールを与えるように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(本当によいプログラマーは時折もっと良く改善します。)大抵、これは重要でないアルゴリズムの愚行に十分なビットの使用を引き起こすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Str is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Strはユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native str type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応するネイティブstr型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since a Str object may fill multiple roles, we say that a Str keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしStrオブジェクトは複数のロールを果たすので、Strはユニコードの抽象レベルで最小と最大のトラックを保持します。そしてバイト、コードポイント、 書記素またはいくつかの言語の文字であるかどうか、現在のレキシカルスコープの理想的な文字のアイデアに沿ってうまく演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all Str positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのビルトイン操作について、全てのStrポジションは整数ではなくポジションオブジェクトとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These StrPos objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらStrPosオブジェクトは特定の文字列の特定の場所を抽象レベルに依存せずポイントします。文字列と位置を直接に追跡するか、あらゆるコンテキストで同じ文字列に適用された場合に同じ結果を与える文字列の開始オフセットを抽象レベルに依存しない表現で出力するかどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is assuming the string isn't modified in the meanwhile; a StrPos is not a &quot;marker&quot; and is not required to follow changes to a mutable string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは一方で文字列が変更されないと仮定しています; StrPosはマーカーではなく、可変の文字列の変更を追跡する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、置換された文字列のマッチする位置を求めるとしたら、その答えは変更された文字列のポジションではなく元の文字列のものとして報告されます(今はアクセスできないかもしれません！)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subtraction of two StrPos objects gives a StrLen object, which is also not an integer, because the string between two positions also has multiple integer interpretations depending on the units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つのStrPosオブジェクトの減算はStrLenオブジェクトを与えます。それも整数ではありません。なぜなら2つのポジション間の文字列も単位に依存する複数の整数解釈を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A given StrLen may know that it represents 18 bytes, 7 codepoints, 3 graphemes, and 1 letter in Malayalam, but it might only know this lazily because it actually just hangs onto the two StrPos endpoints within the string that in turn may or may not just lazily point into the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられたStrLenは18バイト、7コードポイント、3書記素、そしてマラヤーラムの1文字を表現すると知っているでしょう。しかしそれはいい加減にしか知っていないかもしれません。なぜならそれは文字列を単にいい加減にポイントするかしていない文字列内の2つのStrPosの終点を捕まえているだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The lazy implementation of StrLen is much like a Range object in that respect.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(その点に関してStrLenのいいかげんな実装はRangeオブジェクトにそっくりです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポジションオブジェクトが期待されるところで整数を引数として使用すると、現在のレキシカルスコープのユニコード抽象レベルの単位を意味すると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(デフォルトは書記素です。)それ以外は適切な単位を強制する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろんそのような次元数は文字列が適切な抽象レベルを提供しないなら失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a StrPos or StrLen is forced into a numeric context, it will assume the units of the current Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StrPosかStrLenが数値コンテキストを強制されると、現在のユニコード抽象レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような次元的でない数を間違った単位で解釈するルーチンに渡すのは誤っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation note: since Perl 6 mandates that the default Unicode processing level must view graphemes as the fundamental unit rather than codepoints, this has some implications regarding efficient implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装上の注意: Perl 6はデフォルトのユニコード処理レベルをコードポイントよりも書記素を基本単位として見なければならないと命じるので、これは効率的な実装に注意を払ういくつかの意味合いを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is suggested that all graphemes be translated on input to a unique grapheme numbers and represented as integers within some kind of uniform array for fast substr access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>substrアクセスを高速化するため、いくつかの種類の均一な配列内で全ての書記素のインプットを固有の書記素数に変換し、整数として表現することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those graphemes that have a precomposed form, use of that codepoint is suggested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの構成済みの形式を持つ書記素のために、そのコードポイントを使うことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this means Latin-1 can still be represented internally with 8-bit integers.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(これは、Latin-1がいまだに内部的に8ビット整数で表現されることができることに注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For graphemes that have no precomposed form, a temporary private id should be assigned that uniquely identifies the grapheme.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構成済みの形式を持たない書記素のために、テンポラリのプライベートIDは書記素を固有に識別するように割り当てられるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such ids are assigned consistently thoughout the process, comparison of two graphemes is no more difficult than the comparison of two integers, and comparison of base characters no more difficult than a direct lookup into the id-to-NFD table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このようなIDが処理を通して一貫して割り当てられるなら、2つの書記素の比較はもはや2つの整数の比較より難しくありません。そして基本文字の比較はもはやid-to-NFDテーブル内の直接検索より難しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, any temporary grapheme ids must be translated back to some universal form (such as NFD) on output, and normal precomposed graphemes may turn into either NFC or NFD forms depending on the desired output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろん、あらゆるテンポラリ書記素IDはいくつかの普遍的な形式(NFDのような)に再変換されて出力されなければなりません。そして普通の構成済みの書記素は望まれる出力に従ってNFCかNFDのどちらかの形式に変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maintaining a particular grapheme/id mapping over the life of the process may have some GC implications for long-running processes, but most processes will likely see a limited number of non-precomposed graphemes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>処理の期間にわたる特定の書記素/IDマッピングを扱うことは長期実行中のプロセスのためのいくつかのGC実装を持つかもしれません。しかし、おそらくほとんどのプロセスは限られた数の構成済みでない書記素を参照するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the program has a scope that wants a codepoint view rather than a grapheme view, the string visible to that lexical scope must also be translated to universal form, just as with output translation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしプログラムが書記素表示よりもコードポイント表示を望むスコープを持つなら、そのレキシカルスコープに見える文字列もまた出力変換と同時に普遍的な形式に変換されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the temporary grapheme ids may be hidden behind an abstraction layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、テンポラリ書記素IDは抽象化レイヤーから隠されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, codepoint scope should never see any temporary grapheme ids.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんな場合でも、コードポイントスコープはどのようなテンポラリ書記素IDも参照しないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The lexical codepoint declaration should probably specify which normalization form it prefers to view strings under.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(レキシカルコードポイント宣言はおそらく文字列を見下ろすことを好む正規化形式を指定するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a declaration could be applied to input translation as well.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このような宣言は入力変換にも同様に適用できます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Buf is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of Str.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufは整数配列の文字列的な見方です。そしていくつかの種類のStrへ明示的な変換がなければユニコードまたは文字のプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A buf is the native counterpart.) Typically it's an array of bytes serving as a buffer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(bufはネイティブに相当するものです。)通常、それはバッファとして供給するバイト配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a Buf treat the entire buffer as a single large integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufのビット単位演算はバッファ全体を一つの巨大な整数として扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a Str generally fail unless the Str in question can provide an abstract Buf interface somehow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>問題になっているStrがBufの抽象インターフェースをどうにかして提供しなければ、Strのビット単位演算は普通は失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercion to Buf should generally invalidate the Str interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bufへの強制は一般的にはStrのインターフェースを無効にするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a generic type Buf may be instantiated as (or bound to) any of buf8, buf16, or buf32 (or to any type that provides the appropriate Buf interface), but when used to create a buffer Buf defaults to buf8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ジェネリック型としてのBufはbuf8、buf16、buf32のどれか(またはBufの適切なインターフェースを提供する何らかの型)によってインスタンス化（またはバインド）されます。バッファとして使われる場合、Bufのデフォルトはbuf8になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Str types, Buf types prefer to deal with integer string positions, and map these directly to the underlying compact array as indices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Str型と異なり、Buf型は整数の文字列ポジションで処理することを好みます。そしてそれらをインデックスとして直接に基本的なコンパクト配列にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは必ずしもバイトポジションである必要はありません―整数ポジションは単にあるポジションがある基本的な整数型のセルを意味する基本的なポジションの数を数えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin string operations on Buf types return integers and expect integers when dealing with positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Buf型のビルトイン文字列操作は整数を返し、ポジションを処理する時には整数を期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a limiting case, buf8 is just an old-school byte string, and the positions are byte positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>限られた場合として、buf8はただの古い習慣のバイト文字列で、ポジションはバイトポジションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, though, that if you remap a section of buf32 memory to be buf8, you'll have to multiply all your positions by 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただし、buf32のメモリのセクションをbuf8に再マップするなら全てのポジションを4倍する必要があるので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The utf8 type is derived from buf8, with the additional constraint that it may only contain validly encoded UTF-8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>utf8型はbuf8型から派生し、正当にエンコードされたUTF-8だけを含むという追加の制約を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, utf16 is derived from buf16, and utf32 from buf32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様にutf16はbuf16から派生し、utf32はbuf32から派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは型名であり、制約にリスト演算形式は認められないので、それらを制約として呼び出すためには括弧を使う必要があるので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に次のように解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The * character as a standalone term captures the notion of &quot;Whatever&quot;, which is applied lazily by whatever operator it is an argument to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項としての文字*は“何でも”という概念を引き受けます。それは引数に対するwhatever演算子によっていいかげんに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally it can just be thought of as a &quot;glob&quot; that gives you everything it can in that argument position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的に、それは引数のポジションに何でも与える“glob”と考えることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever is an undefined prototype object derived from Any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>WhateverはAnyから派生した未定義のプロトタイプオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としては抽象型で、定義されたオブジェクトとしてインスタンス化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If for a particular MMD dispatch, nothing in the MMD system claims it, it dispatches to as an Any with an undefined value, and usually blows up constructively.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし特定のMMDディスパッチに対してMMDシステムが何も主張しないなら、それは未定義値を伴うAnyにディスパッチされ、そして普通は前向きに怒ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが例外を合理的だと思わないなら、合理的な答えを生じさせると期待しないべきかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Whatever object is effectively immutable, the optimizer is free to recognize * and optimize in the context of what operator it is being passed to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Whateverオブジェクトは事実上は不変なので、オプティマイザは*を自由に認識することができ、どの演算子に渡されるのかコンテキストの中で最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the built-in numeric operators treat an argument of * as indicating the desire to create a function of a single unknown, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのビルトイン数値演算子は引数の*を単独の未知の関数を作成することを満たすとして扱います。つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces a function of a single argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は単独の引数の関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the single dispatcher recognizes *.meth and returns { $_.meth }, so it can be used where patterns are expected:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に単独のディスパッチャーは*.methを認識して{ $_.meth }を返すので、そのパターンが期待される場所で使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These closures are of type Code:($), not Whatever, so that constructs can distinguish via multiple dispatch:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクロージャーはWhateverではなくCode:($)型なので、その構造はマルチディスパッチによって区別できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bare * form may also be called as a function, and represents the identify function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸の*形式は関数としても呼ぶことができ、関数の識別を表します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that this is not what is happening above, or</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし注意として、これは上で起こっていることではありません。または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would end up meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は以下を意味することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ... operator is instead dispatching bare * to a routine that does dwimmery, and in this case decides to supply a function { * + 1 }.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>...演算子は代わりに*を期待通りに動作するルーチンにディスパッチしています。そしてこの場合は関数 { * + 1 } を供給すると決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final element of an array is subscripted as @a[*-1], which means that when the subscripting operation discovers a Code object for a subscript, it calls it and supplies an argument indicating the number of elements in (that dimension of) the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最後の要素は@a[*-1]として添字化され、それは添字操作がCodeオブジェクトを添字に見つけると、それを呼んで(その次元の)配列内の要素数を示す引数を供給することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variant of * is the ** term, which is of type HyperWhatever.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>*の変化形は**という項で、それはHyperWhatever型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally understood to be a multidimension form of * when that makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは一般的に、意味をなす場合は多次元形式の*と理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When modified by an operator that would turn * into a function of one argument, ** instead turns into a function with a slurpy argument, of type Code:(*@).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子によって*が1つの引数の関数に変換される場合、 **は代わりにすばらしい引数を伴う関数、Code:(*@)型に変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore @array[^**] represents @array[{ map { ^* }, @_ }], that is to say, every element of the array, no matter how many dimensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って@array[^**]は@array[{ map { ^* }, @_ }]を表し、配列の次元数を問わない配列の全要素ということになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, @array[**] means the same thing because (as with ... above), the subscript operator will interpret bare ** as meaning all the subscripts, not the list of dimension sizes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ただし@array[**]は同じことを意味します。なぜなら (...で述べたように)添字演算子は裸の**を全ての添字と解釈し、次元のサイズのリストとは解釈しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of Whatever is always controlled by its immediate context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Whateverの意味は常にその場のコンテキストによってコントロールされます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other uses for * and ** will doubtless suggest themselves over time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>*と**の他の用途はそのうちにそれら自身で示されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがそうでなければ、これらはMMDシステムによって意味を与えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型の値は、それらの対になる大文字の型のオブジェクトとして扱われる時はautobox化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including bit) default to 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型はPerlの概念の未定義値を表現できないので、明確な初期化がなければネイティブ浮動小数点はデフォルトでNaN、整数（bit含む)はデフォルトで0になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>complex型のデフォルトはNaN + NaN\iです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既知のサイズのbuf型は0の値のシーケンスがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any native type is explicitly initialized to * (the Whatever type), no initialization is attempted and you'll get whatever was already there when the memory was allocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしネイティブ型が*(Whatever型)に明示的に初期化されたら、メモリに既に割り当てられた値が割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしbuf型がユニコード文字列の値で初期化されたら、文字列はユニコードのコードポイントに分解され、それぞれのコードポイントは整数の要素に押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>buf型のサイズが指定されない場合は、初期化する文字列の長さから持ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サイズが指定された場合は文字列は必要に応じて切り詰められるか0で埋められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time; otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either U+FFFD (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or U+007f (DELETE) if the larger value would not fit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしコードポイントがbufの整数型にフィットしない場合は、コンパイル時に検出できるならパースエラーが発生します。そうでなければ実行時に警告され、オーバーフローしたバッファの要素は適切な代替文字U+FFFD (置き換え文字、整数型が少なくとも16ビットの場合)かU+007f (削除文字、より大きい値にフィットしない場合)に置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の変換を望む場合は、明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, no conversion to UTF-8 or UTF-16 is attempted; that must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にUTF-8かUTF-16への変換は試みられません。明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それが起こったら、32ビット整数ベースのbufへの変換はネイティブエンディアンの有効なUTF-32を生成します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can behave as values or objects of any class, except that defined always returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>definedが常にfalseを返す場合を除き、未定義型は値または何かのクラスのオブジェクトとして振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can create them with the built-in undef and fail functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは組み込みのundefかfail関数で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(failuresがどの様に処理されるかはS04を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの種類のtype、class、moduleまたはpackageを定義した場合でも、自動的に同じ名前の未定義プロトタイプ値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a Failure value is put into a typed container, it takes on the type specified by the container but continues to carry the Failure role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Failure値が型付けされたコンテナに設置された時はいつでもコンテナによって指定された型を引き受けますが、Failureのroleをもたらし続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The undef function merely returns the most generic Failure object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(undef関数は最も一般的なFailureオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use fail to return more specific failures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より特定のfailuresを返すにはfailを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use Object for the most generic non-failure undefined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最も一般的なnon-failureの未定義値にはObjectを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Any type is also undefined, but excludes junctions so that autothreading may be dispatched using normal multiple dispatch rules.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Any型も未定義ですが、autothreadingは普通のマルチディスパッチの規則でディスパッチされるのでjunctionsは除外します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nil type is officially undefined as an item but interpolates as a null list into list context, and an empty capture into slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Nil型は項目として公式に未定義ですが、リストコンテキストではnullリストに、スライスコンテキストでは空キャプチャに補間されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Nil object may also carry failure information, but if so, the object behaves as a failure only in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Nilオブジェクトはfailureの情報ももたらしますが、もしそうなら、オブジェクトはitemコンテキストでのみfailureとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use Failure/undef when you want to return a hard failure that will not evaporate in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストコンテキストで消滅しないhard failureを返したい時は Failure/undefを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types behave like values, i.e. $x === $y is true if and only if their types and contents are identical (that is, if $x.WHICH eqv $y.WHICH).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は値のように振る舞います。すなわち、$x === $yはそれらの型と内容が同一の場合のみtrueです。(つまり$x.WHICH eqv $y.WHICHなら)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Insofar as Lists are lazy, they're really only partially immutable, in the sense that the past is fixed but the future is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Listsがlazyである限りにおいて、過去が固定され、未来がないという意味では、それらは本当に部分的にだけ不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The portion of a List yet to be determined by iterators may depend on mutable values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まだイテレータによって決定されていないListの部分は変更可能な値に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an iterator is called upon to iterate and extend the known part of the list, some number of immutable values (which includes immutable references to mutable objects) are decided and locked in at that point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータがリストの既知の部分の反復と拡張の上で呼ばれた時、いくつかの数の不変の値(変更可能なオブジェクトへの不変なリファレンスを含む)が決定され、その点でロックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterators may have several different ways of iterating depending on the degree of laziness/eagerness desired in context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテキストで望まれるlaziness/eagernessの度合いに応じてイテレータはいくつかの異なる方法を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator API is described in S07.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータのAPIはS07で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instants and Durations are measured in atomic seconds with fractions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>InstantとDurationは有理数で微少時間に測定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notionally they are real numbers which may be implemented in either Num or Rat types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>理論上、それらはNumかRat型で実装される実数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Fixed-point implementations are strongly discouraged.) Interfaces that take Duration arguments, such as sleep(), may also take Num arguments, but Instant arguments must be explicitly created via any of various culturally aware time specification APIs that, by and large, are outside the CORE of Perl 6, with the possible exception of a constructor taking a native TAI value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(固定小数点の実装は強く推奨されません。)sleep()のようなDurationの引数を受け取るインターフェースはNum引数も受け取りますが、Instant引数はさまざまな文化を理解した時間仕様のAPI(概してPerl 6のCOREの外側で、ネイティブTAI値を受け取るコンストラクタの可能な例外を伴う)によって明示的に作成されたものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context a Duration happily returns a Num representing seconds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストではDurationは喜んで秒を表すNumを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If pressed for a number, an Instant will return the length of time in atomic seconds from the TAI epoch, but it will be unhappy about it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値が求められる場面ではInstantはTAIエポック値の微少時間の長さを返すでしょう。しかしそれに関しては適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems which cannot provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>POSIXのような安定したタイムベースを返すことができないシステムでは、正しい微少時間を最大限に推測できるようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types have distinct .WHICH values that do not change even if the object's contents change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型のオブジェクトはそれぞれがオブジェクトの内容が変わっても変わらない.WHICH値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Routinesは変更可能と見なされます。なぜならそれらは適所にラップされることができるからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash differs from a normal Hash in how it handles default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashは通常のHashとデフォルト値の扱いが異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of a KeyHash element is set to the default value for the KeyHash, the element is deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashの要素の値がKeyHashのデフォルト値にセットされていた場合、その要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If undeclared, the default default for a KeyHash is 0 for numeric types, False for boolean types, and the null string for string and buffer types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言されていない場合、KeyHashのデフォルトのデフォルトは数値型では0、ブール型ではFalse、文字列とバッファ型ではnull文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash of a Object type defaults to the undefined prototype for that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Object型のKeyHashはその型の未定義プロトタイプがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, the default default is whatever defined value an undef would convert to for that value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より一般的には、デフォルトのデフォルトは定義された値のなんでもの型に変換されるであろうundefです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash of Scalar deletes elements that go to either 0 or the null string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ScalarのKeyHashは0かnull文字列の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyHash also autodeletes keys for normal undef values (that is, those undefined values that do not contain an unthrown exception).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyHashは通常のundef値のキーも削除します(つまりそれらの未定義値はスローされない例外を含みません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySet is a KeyHash of booleans with a default of False.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeySetはFalseをデフォルトにしたブール値のKeyHashです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the Hash interface and increment an element of a KeySet its value becomes true (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしHashインターフェースを使い、KeySetの要素を増やした場合はその値はtrueになります(要素が存在しない場合は作成する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし要素を減らした場合はその要素はfalseになり、自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decrementing a non-existing value results in a False value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値を減らすとFalse値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incrementing an existing value results in True.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在する値を増やすとTrueを生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a Hash (that is, when used as an Array or list or Set object) a KeySet behaves as a Set of its keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしHashとして使わない場合(つまりArrayかリストかSetオブジェクトとして使った場合)KeySetはそのキーのSetとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Since the only possible value of a KeySet is the True value, it need not be represented in the actual implementation with any bits at all.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(KeySetの可能な値がTrue値だけなので、少しのことでも実際の実装では表現する必要はありません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyBag is a KeyHash of UInt with default of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>KeyBagは0をデフォルトにしたUIntのKeyHashです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the Hash interface and increment an element of a KeyBag its value is increased by one (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたがHashインターフェースを使い、KeyBagの要素をインクリメントするとその値が1増加します(存在しない要素は作成されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element the value is decreased by one; if the value goes to 0 the element is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素をデクリメントすると値が1減少します。値が0になると要素が自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attempt to decrement a non-existing value results in a Failure value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値をデクリメントしようとするとFailure値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a Hash (that is, when used as an Array or list or Bag object) a KeyBag behaves as a Bag of its keys, with each key replicated the number of times specified by its corresponding value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hashとして使われない場合(つまりArrayかリスト化Bagオブジェクトとして使われた場合)、KeyBagはそのキーのBagとして振る舞い、それぞれのキーは対応する値によって指定された回数複製されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use .kv or .pairs to suppress this behavior in list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(リストコンテキストでこの振る舞いを抑制するには.kv か.pairsを使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Hash types, Pair and Mapping are mutable in their values but not in their keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hash型のようにPairとMappingはそれらの値を変更できますがキーはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A key can be a reference to a mutable object, but cannot change its .WHICH identity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(キーは変更可能なオブジェクトへの参照になれますが、.WHICHの固有性は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、ハッシュの要素と同様に値は異なるオブジェクトに再バインドされるでしょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的な型はオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their &quot;value type&quot; and their &quot;implementation type&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlの変数は2つの関連する型を持ちます: それらの&quot;値型&quot;と&quot;実装型&quot;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its of property, while the implementation type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より一般的には、どの種類のコンテナもサブルーチンとモジュールを含む実装型を持ちます。)値型はそのofプロパティとして格納され、コンテナの実装型は単にコンテナ自身のオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word returns is allowed as an alias for of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単語returnsはofの別名として許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型はどの種類の値が変数に格納されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type is given as a prefix or with the of keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は前置かofキーワードで与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the of property of the container to Dog.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合でもコンテナのofプロパティをDogに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines have a variant of the of property, as, that sets the as property instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンはofプロパティの変化形asを持ち、代わりにasプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to return or by implicit fall-off-the-end return).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asプロパティは返値に強制される制約(もしかしたら抑制) を指定します(returnによって明示的に呼ばれるか最後の暗黙の返値のいずれかによって)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint, unlike the of property, is not advertised as the type of the routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ofプロパティのようでないこの制約はルーチンの型としては表に出ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of it as the implicit type signature of the (possibly implicit) return statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは(もしかしたら暗黙の)return文の暗黙の型シグネチャと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's therefore available for type inferencing within the routine but not outside it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従ってルーチン内で型推論が利用できますが外側ではできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no as type is declared, it is assumed to be the same as the of type, if declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as型が宣言されていない場合、of型が宣言されている場合と同じと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列かハッシュでの値型はそれぞれの格納された要素の型を指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュのキーの型はshape traitで指定されます―S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型は変数自身がどの様に実装されているかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変数のtraitとして与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型を定義することはPerl 6ではPerl 5の変数のtieに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time tie statement unless the variable is explicitly declared with an implementation type that does the Tieable role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしPerl 6の変数は宣言時に直接tieされ、Tieable roleを行う実装型で明示的に宣言された変数でなければパフォーマンス上の理由で実行時にtie文でtieされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, package variables are always considered Tieable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながらパッケージ変数は常にデフォルトでTieableとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, all named packages are also Tieable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、全ての名前付きパッケージもデフォルトでTieableです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスとモジュールはtieされたパッケージとは異なると見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the Package role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の方向から見れば、グローバルパッケージにバインドされることを希望するクラスとモジュールはPackage roleが可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの型の値がそれぞれの要素に格納されているか指定するため、非スカラー型は修飾されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each successive of makes the type on its right a parameter of the type on its left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの連続するofはその右のパラメータの型を、その左の型にさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ付きの型は角括弧を使って名前を付けられます。だから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は実際には以下のような意味になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑な型が指定された場合は実際の変数を理解するのが大変なので、同様の後置形式があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as form may be used in subroutines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンではas形式が使われるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに返値の型はシグネチャ内で指定されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a slight difference, insofar as the type inferencer will ignore a as but pay attention to --&gt; or prefix type declarations, also known as the of type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の推測者がasを無視する限りにおいて、そこには微妙な違いがあります。しかしof型としても知られる--&gt;または後置の型宣言に注意を払って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the inside of the subroutine pays attention to as, and essentially coerces the return value to the indicated type, just as if you'd coerced each return expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンの内側だけがasに注意を払っており、本質的に返値はそれぞれのreturn式を強制したかのように指定された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also specify the of type as the of trait (with returns allowed as a synonym):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型をof trait(returnsが同義語として許可される)として指定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &quot;or&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;or&quot;かjunctionであるかのように、単一の型をセットで使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fancier type constraints may be expressed through a subtype:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>手の込んだ型制約はsubtypeを通して表現されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &quot;anded&quot; together (the variable itself supplies type constraints, and where clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &quot;and&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの項は暗黙に一緒に&quot;anded&quot;された制約のセットと見ることができるので(変数自身は型制約を供給し、where条項かツリーマッチングはさらに制約を加えるだけです)、我々は&quot;and&quot; junctionのように型の並びを許可するためにこれを緩和します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは他のどの様な変数と同じように型を与えられるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の中で、クラス変数(それ自身か既存の型名の後のどちらか)は新しい型名を宣言し、実際のパラメータの型と関連づけられているパラメータ付きの値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It declares the new type name in the same scope as the associated declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは関連付けられた宣言として同じスコープ内で新しい型名を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい型名は直ちに取り込まれ、同じシグネチャ内の2つのそのような型は同じ名前の場合は互換性を統一する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a scoped subroutine, a return type can be specified before or after the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スコープ付きサブルーチンでは、返値の型は名前の前か後で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call all return types &quot;return types&quot;, but distinguish two kinds of return types, the as type and the of type, because the of type is normally an &quot;official&quot; named type and declares the official interface to the routine, while the as type is merely a constraint on what may be returned by the routine from the routine's point of view.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々は返値の型を&quot;return types&quot;と呼びますが、as型とof型の2種類の返値の型は区別します。なぜならof型は通常は&quot;official&quot;な名前を付けられた型名で、ルーチンに対するオフィシャルなインターフェースを宣言します。asは単にルーチン視点でルーチンによって何が返されるかの制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it's scoped with the our scope modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしサブルーチンが明示的にスコープ化されていないなら、それはourスコープ修飾子でスコープ化されるかのように現在の名前空間(モジュール、クラス、grammarまたはパッケージ)に属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any return type must go after the name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はどれでも名前の後に移動する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On an anonymous subroutine, any return type can only go after the sub keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名サブルーチンでは、どの返値の型もsubキーワードの後にしか移動できません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but you can use a scope modifier to introduce an of prefix type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of後置型を導入するためにスコープ修飾子を使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are anonymous, you can change the my modifier to our without affecting the meaning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは無名なので、my修飾子は意味に影響を与えずに ourに変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type may also be specified after a --&gt; token within the signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はシグネチャの中で--&gt;トークンの後で指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This doesn't mean exactly the same thing as as.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはasと正確に同じ意味があるものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The of type is the &quot;official&quot; return type, and may therefore be used to do type inferencing outside the sub.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型は&quot;official&quot;な返値の型で、サブルーチンの外側で型推論を行うために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as type only makes the return type available to the internals of the sub so that the return statement can know its context, but outside the sub we don't know anything about the return value, as if no return type had been declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as型はサブルーチンの内部で利用できる返値の型を作るだけで、return文がそのコンテキストを知ることができますが、サブルーチンの外側では返値の型が宣言されていないかのように返値の型に関して何も知ることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prefix form specifies the of type rather than the as type, so the return type of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置形式はas型よりもof型を指定するので、返値の型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is known to return an object of type Fish, as if you'd said:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はあなたが次のようにしたかのようにFish型のオブジェクトを返すと知ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not as if you'd said</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のようにではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible for the of type to disagree with the as type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>of型とas型を区別することが可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または同じに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of sigils to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は変数の基本的な構造をマークするためのsigilsシステムを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, the &amp; sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言内で&amp; sigilはスコープ宣言内のsigil無しにサブルーチン名の可視性も宣言します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a signature or other declaration, the :: sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャか他の宣言内で、識別子が続く:: sigilはpackage/type名の可視性をスコープ宣言のsigil無しに宣言する型変数をマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初はそのようなスコープ付きの宣言はバインドされない型とみなされ、その関連付けられた引数の実際の型を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後に続く同じスコープの宣言内のsigilは任意なので、裸の型名も宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内側をネストする宣言は同じ型を参照したい場合はsigilを使うことは出来ません。内側の宣言は型を再バインドするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(pointy blockのシグネチャは外側のブロックではなく内側のブロックとして数えられルので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsはバインドされたオブジェクトの正確な型ではなく、全体的なインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるsigilsはわずかな異なる能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x may be bound to any object, including any object that can be bound to any other sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$x は，どんなオブジェクトにでも束縛されることが許されています。それにはそれ以外の sigil に束縛されたものをも含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなスカラー変数はオブジェクトが本質的に複合型か単一型かどうかに関わらず常にどのようなリストコンテキストでも単数形アイテムとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの種類のデリファレンスコンテキストに置かれなければ、その内容は自動的にデリファレンスされないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, when interpolating into list context, $x never expands its object to anything other than the object itself as a single item, even if the object is a container object containing multiple items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、リストコンテキストに差し込まれている場合、$x は単一のアイテムとしてオブジェクト自身以外の何か他のものとしてそのオブジェクトを展開しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@x may be bound to an object of the Array class, but it may also be bound to any object that does the Positional role, such as a List, Seq, Range, Buf, or Capture.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@xは、単体のArray クラスのオブジェクトに束縛されることが許されていますし、List、Seq、Range、Buf、CaptureのようなPositional role を負う全てのオブジェクトに束縛されることも許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Positional role implies the ability to support postcircumfix:&lt;[ ]&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Positional role は、postcircumfix:&lt;[ ]&gt;をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, %x may be bound to any object that does the Associative role, such as Pair, Mapping, Set, Bag, KeyHash, or Capture.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に%x は，Pair、Mapping、Set、Bag、KeyHash、CaptureのようなAssociative role を負う全てのオブジェクトに束縛されることが許されています．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Associative role implies the ability to support postcircumfix:&lt;{ }&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Associative role は、postcircumfix:&lt;{ }&gt;をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;x may be bound to any object that does the Callable role, such as any Block or Routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&amp;xは、Block、RoutineのようなCallable role を負う全てのオブジェクトに束縛されることを許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Callable role implies the ability to support postcircumfix:&lt;( )&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Callable role は、postcircumfix:&lt;( )&gt;をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>::x may be bound to any object that does the Abstraction role, such as a package, module, class, role, grammar, or any other type object, or any immutable value object that can be used as a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>::x は、package、module、class、role、grammar、それ以外の全ての型オブジェクトや型として使われるimmutable な値オブジェクトのようなAbstraction role を負う全てのオブジェクトに束縛されることを許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This Abstraction role implies the ability to do various symbol table and/or typological manipulations which may or may not be supported by any given abstraction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Abstraction role は、抽象化によりサポートすることを許可されたり，そうでないような様々なシンボルテーブルや型論理を操作する能力を意味します．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly though it just means that you want to give some abstraction an official name that you can then use later in the compilation without any sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはコンパイル中になんらかのsigil無しに抽象化に後で使えるように公式な名前を与えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのような場合でも、sigilによって意味づけされた最小のコンテナroleは最新のバインディング時にチェックされ、文法エラーがすぐに検出できるなら（コンパイル時のような）早期に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to bind an object that doesn't yet do the appropriate role, you must either stick with the generic $ sigil, or mix in the appropriate role before binding to a more specific sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>適切なroleを負わないオブジェクトを束縛したい場合、一般的な$ sigilにこだわるか、より特定されたsigilと束縛する前に適切なroleをミックスインしてやらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object is allowed to support both Positional and Associative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PositionalとAssociativeをサポートするオブジェクトも許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that does not support Positional may not be bound directly to @x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Positionalをサポートしないオブジェクトを@xに直接束縛することは許されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, any construct such as %x that can interpolate the contents of such an object into list context can automatically construct a list value that may then be bound to an array variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただし、リストコンテキスト内でのオブジェクトの内容を挿入するような%xの構築は、1つの配列変数に束縛されているリスト値を自動的に構築する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなリストの添字は元のオブジェクトの添字を意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、もはやsigilとそれに続く名前または構造の間に空白を置けないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通のsigilsは通常のスコープ変数、レキシカルかパッケージスコープを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oddly scoped variables include a secondary sigil (a twigil) that indicates what kind of strange scoping the variable is subject to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変なスコープ変数は変数がどの種類の奇妙なスコープに従属するかを示す2つ目のsigil(twigil)を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &quot;my&quot; or &quot;our&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのtwigils変数は暗黙に他のスコープに宣言されるか宣言されていると見なされ、&quot;my&quot;か&quot;our&quot;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attribute variables are declared with has, though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性変数はhasで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsは今は変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ always means a scalar variable, @ an array variable, and % a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$は常にスカラー変数を意味し、添字がある場合でも@は配列、%はハッシュ変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as @array and %hash simply return themselves as Array and Hash objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アイテムコンテキストでは@arrayや%hashのような変数は単純にそれら自身をArrayやHashオブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Item context was formerly known as scalar context, but we now reserve the &quot;scalar&quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(アイテムコンテキストは以前はスカラーコンテキストとして知られていましたが、われわれは&quot;scalar&quot;の概念をコンテキスト（リストコンテキストからの配列の解除）よりも変数のことに関しての話と予約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列コンテキストではコンテナオブジェクトは自動的に適切な文字列値に文字列化(空白で区切られた)されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールコンテキストでは、コンテナに要素がある場合だけtrue値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a Perlish representation of any object, use the .perl method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのPerlっぽい表現を得るには.perlメソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the Data::Dumper module in Perl 5, the .perl method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5のData::Dumperモジュールのように、.perlメソッドは文字列にクォートを置き、リスト値に角括弧を置き、ハッシュ値にカーリーを置きます。なのでPerlは結果を評価して同じオブジェクトに戻せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .perl method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.perlメソッドはオブジェクトの想定の表現を返し、もしコードが同じ点で再解析されたら、アイテムコンテキストでオブジェクトをスカラーとして再出力するのに使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use &lt;prefix:&lt;| &gt;&gt; to force interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし再解析されたオブジェクトをリストコンテキストに挿入したいなら、&lt;prefix:&lt;| &gt;&gt;を強制挿入のために使う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the .fmt('%03d') method to do an implicit sprintf on the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スカラー値のフォーマットされた表現を得るには、値に暗黙のsprintfを行う.fmt('%03d')メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: .fmt('%03d', ', ').</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の値をコンマで区切ってフォーマットするには.fmt('%03d', ', ')のように第二引数を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: .fmt('%s: %s', &quot;\n&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ値やペアのリストをフォーマットするには.fmt('%s: %s', &quot;\n&quot;)のように最初の文字列にキィとバリューの両方に対してのフォーマットを含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は一貫して左にあるどんなものにでも作られたコンテナをデリファレンスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数名と添字の間の空白は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、構造を視覚的に引き延ばす2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a subscript is a kind of postfix operator, there is a corresponding dot form of each subscript (@foo.[1] and %bar.{'a'}) that makes the dereference a little more explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は後置演算子の一種なので、それぞれの添字に対応するdot形式があります(@foo.[1]と%bar.{'a'})。それはデリファレンスをより少し明示的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant string subscripts may be placed in angles, so %bar.{'a'} may also be written as %bar&lt;a&gt; or %bar.&lt;a&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字が定数文字列の場合は、山括弧内に置くこともできます。つまり%bar.{'a'}は%bar&lt;a&gt;か%bar.&lt;a&gt;とも書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceを使って追加の空白を挿入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシングは添字の性質で指定され、sigilによってではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context in which a subscript is evaluated is no longer controlled by the sigil either.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字が評価されているコンテキストは、もはやsigilによって制御されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More specifically, they are evaluated in a variant of list context known as slice context, which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より正確には、それらはsliceコンテキストというリストコンテキストの変化形で評価され、それは次元的情報を保存し、あなたはmulti-dimensionalスライスをセミコロンを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それぞれの次元のスライスは普通のリストコンテキストなので添字の一部で呼ばれた関数はsliceコンテキストを認識しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし内部のコンテキストをアイテム(スカラー)コンテキストに強制したいなら+を数値コンテキスト、~を文字列コンテキストに指定するなどの便利な単一文字のspecifiersがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils used either as functions or as list prefix operators also force context, so these also work:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsを関数として、またはリストの前置演算子として使うかどちらかによってもコンテキストを強制できます。なのでこれらはこのようにも動きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこれらは同じではないので注意して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストバインディングからリストの割り当てを識別する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストの割り当てはPerl 5のように、値をコピーして動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a new := binding operator that lets you bind names to Array and Hash objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい:=バインディング演算子があり、それはコピー無しにArrayとHashオブジェクトを名前にバインディングし、サブルーチンの引数の同じ方法ではパラメータに正式にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バインディングについて詳しくはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An argument list may be captured into an object with backslashed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数リストはバックスラッシュ括弧でオブジェクトに取り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in a Capture object are parsed as ordinary expressions, then marked as positional or named.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Captureオブジェクト内の値は普通の式としてパースされ、順番か名前でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように解決されるかは最終的に何にバインドされるかに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他がそうでない場合に、いくつかのバインディングは複数の次元に敏感です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When cast into an array, you can access all the positional arguments; into a hash, all named arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列にキャストすると全てのポジショナル引数にアクセスできます。ハッシュなら全ての名前付き引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての前置sigil演算子は一つのポジショナル引数を許容します。それは右辺値としてアイテムコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはもし括弧で呼ばれたら文字列に差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of them as &quot;fat&quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは&quot;fat&quot;リファレンスと考えることができます。それは現在のシングルオブジェクトのアイデンティティだけでなく、関連するいくつかのオブジェクトを取り込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (Signature) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャオブジェクト(Signature)はコロン前置の括弧で作成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャ中の式は普通の式ではなくパラメータ宣言として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの文法の詳細についてはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数にバインドされたシグネチャオブジェクト(上記の例のように)は追加の型制約を適用するために他のシグネチャと共に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &amp;foo merely stands for the foo function as a Routine object without calling it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と異なり、&amp;fooという表記は単に関数fooをRoutineオブジェクトとして呼び出さないで取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧でデリファレンスしてCodeオブジェクトを呼べるでしょう(もちろん引数を含めて):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の前に空白は許されません。なぜなら括弧は後置として解析されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any postfix, there is also a corresponding .() operator, and you may use the &quot;unspace&quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのpostfixとも同じように、対応する.()演算子があり、オプショナルな空白やコメントを挿入するために間にバックスラッシュで&quot;unspace&quot;を使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the parentheses around arguments in the &quot;normal&quot; named forms of function and method calls are not postfix operators, so do not allow the .() form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通の形式の名前に付けられた括弧は関数かメソッド呼び出しですが後置演算子ではありません。そのため.()形式は許されません。なぜならドットは実際にはデリファレンス演算子を示すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの特別な場合にドット形式を使う場合は、引数無しに名前付き形式を呼ぶか、結果をデリファレンスしたいということを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With multiple dispatch, &amp;foo may actually be the name of a set of candidate functions (which you can use as if it were an ordinary function).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マルチディスパッチにおいては&amp;fooは実際には候補関数のセットの名前になります(それは普通の関数であるかのように使うことが出来ます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &amp;foo by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこの場合は&amp;foo自身は特定の関数の関数名となるには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定するために、型は後置演算子のシグネチャリテラルを使ってリファインされるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It still just returns the Routine object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはまだRoutineオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied by using the .assuming method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>呼び出しは.assumingを使うことによっても部分的に適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシング文法はS09でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元スライスは個々のスライスサブリストの間のセミコロンで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such slice sublist is evaluated lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのスライスサブリストは曖昧に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライスの添字を値以外の何かを返すようにさせるには、添字に適切な副詞を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの副詞的形式は存在しないエントリーを取り去ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, which will return true if all the elements of the slice exist:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのスライスの要素が存在するならtrueを返すテストを実行することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>likewise,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &quot;en passant&quot; while returning them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は値を返すついでに削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろん単一のインデックスのスライスでもこれらの形式は動きます。)添字が最も前の演算子であるという事実のおかげでこれらが動くということに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(このようなスライス修飾子はめったには起こりません。なぜならそれらは普通はコンマの優先順位を操作するリストコンテキストで使用されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into Int or Num), a Hash object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキスト(IntかNumにキャストされる場合)、Hashオブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール値コンテキストではなんらかのペアがハッシュにあればtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, any intrinsic iterator would be reset.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの場合で、内在のイテレータはリセットされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ペアのリストをソートするとデフォルトでキーでソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of lists should sort on the first elements, then the second elements, etc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストのリストをソートすると最初の要素でソートし、次に2番目の要素で、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on sort see S29.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sortの詳細についてはS29を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5の特殊変数はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りの特殊変数はレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes $_ and @_, as well as the new $/, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは$_と@_を含み、同様に新しい$/は最後の正規表現マッチの返値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$0, $1, $2, etc., are aliases into the $/ object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$0、$1、$2などは$/オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $#foo notation is dead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>$#foo表記法はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use @foo.end or @foo[*-1] instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@foo.endか@foo[*-1]を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or @foo.shape[$dimension] for multidimensional arrays.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(または@foo.shape[$dimension]を多次元配列に使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は英数字が続くアルファベットで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルファベットと数字の定義は適切なユニコード文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコアは常にアルファベットと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は次の文字がアルファベットの孤立したアポストロフィかハイフンを含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は変数名の適正な部分のことです(sigilは数えません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは以下を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a sigil, the semantic function of :: within a name is to force the preceding portion of the name to be considered a package through which the subsequent portion of the name is to be located.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sigilとして使わない場合、名前の範囲での::の意味関数は後の位置の名前を伴っていれば、前の位置にパッケージとみなされる名前を強制します．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon not followed by an identifier, or any kind of bracket or whitespace (including Unicode brackets and whitespace), it will be taken to be a sigil without a name rather than a punctuational variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl5と違って、sigilにコンマ、セミコロン、識別子が後に続かないコロン、括弧、空白(これにはUnicodeの括弧、空白を含む)が続く場合、お決まりの変数ではなく名前無しのsigilとみなされます．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to use sigils as coercion operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはsigilをcoercion演算子として使えるということです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In declarative contexts bare sigils may be used as placeholders for anonymous variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言コンテキストでは、裸のsigilは無名変数のプレイスホルダとして使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside of declarative contexts you may use * for a placeholder:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言コンテキストの外側では、プレイスホルダとして*を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to say something like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>似たようなことを言おうとして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will result in the message, &quot;Anonymous variable requires declarator&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とすると&quot;Anonymous variable requires declarator&quot;というメッセージを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other all-caps names are semi-reserved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外の全てが大文字の名前は準予約になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &quot;strict&quot; is in effect (which is the default except for one-liners), non-qualified variables (such as $x and @y) are only looked up from lexical scopes, but never from package scopes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;strict&quot;が有効な場合(これはワンライナー以外ではデフォルトの動作です)では、資格を持たない変数($xや@yのような)は、レキシカルスコープからのみ見付けられますが，パッケージスコープからは見付けられません．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To bind package variables into a lexical scope, simply say our ($x, @y).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープへパッケージスコープの変数を束縛するには、単にour ($x, @y)を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To bind global variables into a lexical scope, predeclare them with use:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバル変数をレキシカルスコープに束縛するには、useでそれらをあらかじめ宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or just refer to them as $*IN and $*OUT.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>か，$*INや$*OUTのように参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every block is a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのブロックはクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This synopsis summarizes Apocalypse 10, which discusses packages despite never having been written.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この概要は、Apocalypse 10 をまとめたもので、これ以前に書かれなかったパッケージについて話しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, packages are the basis of modules and classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5のように、パッケージは、モジュールとクラスの基礎となるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, modules and classes are declared with distinct keywords, but they're still just packages with extra behaviors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl5とは異なり、モジュールとクラスは別々のキーワードで宣言されますが、それらは追加の機能を持ったパッケージでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise every typename has an associated package namespace, even if unused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に全ての型名は、パッケージを使うかどうかに関係なく、関係を持つパッケージの名前空間を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ordinary package is declared with the package keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常のパッケージは、packageキーワードで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, in Perl 6 it can only be used with a block:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl5と違い、Perl6 ではブロックを伴ってのみ使用されることが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named package declaration can occur as part of an expression, just like named subroutine declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きのパッケージ宣言は、表現の一部として現われ、ただの名前付きサブルーチン宣言のようでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special exception, if a braceless package declaration occurs as the first executable statement in a file, then it's taken to mean that the rest of the file is Perl 5 code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な表現として、括弧を伴わないpackage宣言がファイルの実行可能な最初の文として現れた場合、ファイルの残りはPerl5のコードを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is illegal in a Perl 6 file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式は、Perl6のファイルとしては違法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to have a file-scoped package, either use the brace form or declare it with the module keyword instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイルスコープのパッケージを作りたいなら、括弧形式を使うか、(packageの)代わりにmoduleキーワードを使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there are no barewords in Perl 6, package names must be predeclared, or use the sigil-like ::PackageName syntax to indicate that the type will be supplied some other way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl6 では裸のワードは存在しないので、パッケージ名はあらかじめ宣言されていなければならず、そうでなければ型が他の場所で提供されている可能性を示すのにシジルみたいな::PackageName構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :: prefix does not imply globalness as it does in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>::の接頭辞は、perl5でのようにグローバル性を示す訳ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use GLOBAL:: for that.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それを示すためにはGLOBAL::を使いましょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare package declarator (without an explicit scope declarator such as my) declares an our package within the current package (or module, or class, or role, or...).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸のpackage宣言(myのようなスコープ宣言子を付けないような)は、現在のパッケージ(やモジュール、クラス、ロールなど)の中のourパッケージを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use GLOBAL:: to declare a global package name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルなパッケージ名を宣言するには、GLOBAL::を使いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a lexically scoped package, use my package.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープなパッケージを宣言するには、my packageを使いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare an anonymous package you can use either of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>匿名のパッケージを宣言するには、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All files start out being parsed in the GLOBAL package, but may switch to some other package scope depending on the first package-ish declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>のどちらかが使えます。全てのファイルがGLOBALパッケージの中にあるとしてパースされますが，最初のパッケージ的な宣言に依存してそれ以外のパッケージスコープに変化していることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that first declaration is not a package variant, then the parsing switches to the &quot;main&quot; package for Perl 5 code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の宣言がパッケージ変数でない場合、パースはPerl5コードとしてなら&quot;main&quot;パッケージに変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 code stays GLOBAL in that situation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じようにPerl6のコードならGLOBALのままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mainline code is thus in the GLOBAL namespace unless declared otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外に宣言されていなければ、メインラインのコードはGLOBAL名前空間のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package traits are set using is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージトレイトはisを使って設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All symbolic links are done with the ::($expr) syntax, which is legal in any variable, package, module, or class name anywhere a ::Ident is legal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボリックリンクは、::($expr)構文を使います、これは::Identが有効な場所のどこででも全ての変数、パッケージ、モジュール、クラスの名前で有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string returned by the expression will be parsed for :: indicating subpackage names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この表現によって返される文字列は、::の中のサブパッケージ名を差すとしてパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not confuse this with the</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをシンボルテーブルの中を検索できるようにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>syntax that lets you do a lookup in a particular symbol table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文と混同しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the key is not parsed for ::.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、キィは::の中としてパースされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's just a hash lookup.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはハッシュの検索として働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration of any object of the form A::B::c also creates (if needed) an empty package A, and an empty package B inside of A, in addition to creating c inside of B.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>A::B::c形式のオブジェクトの宣言は(必要であれば)空のパッケージA、Aの中の空のパッケージB、Bの中のcを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such empty packages may be subsequently be redeclared as any other package-like object (module, class, etc.), and no redeclaration warning will be issued for such a redeclaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このように空のパッケージは他のパッケージ的なオブジェクト(モジュール、クラス他)によって再宣言されるかもしれません。このような再宣言には再宣言の警告を引き起しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a parent package already exists, no stub package needs to be created, and no declaration of the form A::B::c has anything to say about the type of package A or package A::B, since any package variant can function as a package for the purposes of naming things.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>親パッケージが既に存在する場合、スタブパッケージが作成される必要がありません。パッケージ変数は名前付けされた通りにパッケージとして機能しますので、A::B::c形式の宣言はAパッケージ、A::Bパッケージに何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart of package declaration constructs, package names are always searched for from the innermost lexical scope to outermost.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージ宣言の構成の一部であるパッケージ名は常に最も内側のレキシカルスコープから最も外側のそれの範囲から探されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not defined in any surrounding lexical scope, the package is searched for from the current package up through the containing packages to GLOBAL.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープに囲まれて定義されていなければ、そのパッケージは現在のパッケージからGLOBALに向かって含んでいるパッケージを探されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not found, a compiler error results.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでも見付からなければ、結果としてコンパイルエラーを生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an initial ::, the presence of a :: within the name does not imply globalness (unlike in Perl 5).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先頭の::のような、名前の中の::は，グローバル性を意味するものではありません(Perl5と違い)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True globals are always in the GLOBAL:: namespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>真のグローバルは常にGLOBAL::名前空間の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PROCESS:: namespace, shared by all interpreters within the process, is notionally outside of GLOBAL::, but package searches do not look there for anything.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PROCESS::名前空間は，プロセスの範囲でのインタプリタ全体で共有され、表記としてGLOBAL::の外側にあり、パッケージ検索はそこを探しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contextual variable searches do; $*PID will eventually locate $PROCESS::PID if not hidden by an inner context's $PID.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(コンテキスト変数検索は探すようになっていて、内側のコンテキストの$PIDによって隠されていなければ、$*PIDは最終的には$PROCESS::PIDを探し出せます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package (or any other similar namespace) can control autoloading.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージ(やそれ以外の同様な名前空間)はオートロードを制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Perl 5's AUTOLOAD is being superseded by MMD autoloaders that distinguish declaration from definition, but are not restricted to declaring subs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl5のAUTOLOADは定義と宣言を区別するMMDのオートローダに取って代わられ、スタブを宣言することに制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A run-time declarator multisub is declared as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時の宣言のマルチスタブは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which stands in for the declaration of a container object within another container object; it is called when anyone is searching for a name in the package (or module, or class), and the name doesn't already exist in the package.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>のように宣言されています。これは別のコンテナオブジェクトの中のコンテナオブジェクトの宣言の代わりをしています。パッケージ(やモジュールやクラス)の中で名前を探す場合に呼ばれます。その名前はパッケージの中に既に存在している訳ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In particular, .can calls CANDO when trying to determine if a class supports a particular method.) The arguments to CANDO include type information on what kind of object is expected in context, or this may be intuited from the name requested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(特にクラスが特定のメソッドをサポートしているかどうかを判断しようとする場合には.canはCANDOを呼び出します。)CANDOへの引数はコンテキストで期待されるオブジェクトの種類の型情報を含みます。これは呼び出される名前からも直感的でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, there may be multiple CANDO routines that are dispatched via MMD:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての場合で、MMD経由でディスパッチされるマルチなCANDOルーチンが存在する可能性はある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The package itself is just passed as the first argument, since it's the container object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージ自身はコンテナオブジェクトなので、最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent arguments identify the desired type of the inner container and the &quot;name&quot; or &quot;key&quot; by which the object is to be looked up in the outer container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後続の引数は外側のコンテナから探されたオブジェクトによって内部コンテナとして望まれた型と&quot;名前&quot;や&quot;キィ&quot;を特定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a name does not include its container name, unlike Perl 5's magical $AUTOLOAD variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その名前にはコンテナの名前を含みません。Perl5のマジカルな$AUTOLOAD変数と違い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor does it include the type information of a Code object's &quot;long name&quot;; this information comes in via the type parameter, and may be matched against using ordinary subsignature matching:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードオブジェクトの&quot;長い名前&quot;の型情報は含んでいないが、この情報は型パラメータに現われ、通常のサブシグネチャマッチを使いマッチされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The slurpy %args hash is likely to be empty in standard Perl 6 usage, but it's possible that some dialects of Perl will desire a mechanism to pass in additional contextual information, so this parameter is reserved for such purposes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常のPerl6 の使用法では、丸呑み%argsハッシュは空になりそうですが、渡すメカニズムを追加のコンテキスト情報の中で要求することが可能なPerlの方言もあります。そのためこのパラメータはこのような目的に対して予約されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CANDO is expected to return an inner container object of the proper sort (i.e. a variable, subroutine, or method object), or a proxy object that can &quot;autovivify&quot; lazily, or undef if that name is not to be considered declared in the namespace in question.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その名前が質問の際に名前空間に宣言されていないと考えられる場合、適切な種類(例えば、変数、サブルーチン、メソッドオブジェクト)の内部のコンテナオブジェクト、怠惰な&quot;自動活性&quot;のプロキシオブジェクト、undefを返すことをCANDOは期待されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Only bare undef is interpreted as &quot;not there&quot;, since typed undefs may function as autovivifiable proxy objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(型付けられたundefは自動活性可能なプロキシオブジェクトとして機能しますので、裸のundefは、&quot;そこに無い&quot;として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S12 参照のこと。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration merely defines the interface to the new object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言は単に新しいオブジェクトへのインターフェイスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That object need not be completely defined yet, though the CANDO routine is certainly allowed to define it eagerly, and even install the inner object into the outer container (the symbol table) if it wants to cache the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのオブジェクトはそのときまでには完全に定義されることを必要としませんが、宣言のキャッシュを望めばCANDOルーチンはそれを積極的に定義すること、内部オブジェクトを外部コンテナ(シンボルテーブル)に設定することを確実に許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At declaration time it might not yet be known whether the inner container object will be used in lvalue or rvalue context; the use of a proxy object can supply either readonly or rw semantics later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言時には、まだ内部コンテナオブジェクトがlvalue、rvalueコンテキストのどちらで使われるかがわかっていないかもしれません。プロキシオブジェクトを使う場合、読み込み専用か読み書き可能な動作のどちらかが後で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the package in question is a class, it is also possible to declare real methods or submethods:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>質問時のパッケージがクラスの場合、実際のメソッドやサブメソッドを宣言することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method form is inherited by subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド形式はサブクラスにっよって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Submethods are never inherited but may still do MMD within the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブメソッドは継承されませんが、クラスの範囲でMMDは起きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Ordinary multisubs are inherited only to the extent allowed by the MMD mechanism.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(通常のマルチスタブはMMDメカニズムによって許可された拡張に対してのみ継承されます。)</seg>
      </tuv>
    </tu>
  </body>
</tmx>
