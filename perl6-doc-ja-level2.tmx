<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5_4"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>and</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>と</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This document originally summarized Apocalypse 1, which covers the initial design concept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このドキュメントはApocalypse 1を要約したもので、初期のデザインコンセプトを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That original summary may be found below under &quot;Random Thoughts&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>原文の概要は &quot;Random Thoughts&quot; 以下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>歴史的資料として凍結されるApocalypsesと違い、SynopsesはPerl 6の設計の更新も反映します 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの更新点は記録されません ― SynopsisがApocalypseと違う場合はSynopsisが正しいと見なして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another assumption has been that if we don't talk about something in these Synopses, it's the same as it is in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一つの前提として、これらSynopsesで我々が話題にしないことはPerl5と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Soon we plan to fill in the gaps with the Perl 5 details though.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もうすぐ我々はPerl 5の細部とのずれを埋める予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mostly, we're just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大抵の場合、我々は餌を巣に運ぶアリのような集団に過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>主にボランティアによって、多くのグループが適当にこまごまとした仕事を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This document does not attempt to summarize all these subprojects--see the various websites for Parrot and Pugs and Perl 6 for such information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このドキュメントはこれらのサブプロジェクトを全て要約するわけではありません。そのような情報はParrotやPugsやPerl 6のウェブサイトなどを参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>我々が言えることは、Perl 5の場合と違ってこれらのプロジェクトは公式のPerlとは異なるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 is anything that passes the official test suite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公式のテストスイートをパスしたものは全てPerl 6なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This test suite was initially developed under the Pugs project because that project is the furthest along in exploring the high-level semantics of Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>当初、このテストスイートはPugsプロジェクトの元で開発されました。Perl 6の開発に関してPugsプロジェクトが最も先行していたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Other projects are better at other things, such as speed or interoperability.) However, the Pugs project views the test suite as community property, and is working towards platform neutrality, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(他のプロジェクトは速度や相互運用性などの面では優れています。)しかしPugsプロジェクトはテストスイートをコミュニティの所有物と考えており、プラットフォームに対して中立になることを目指しているので、このテストが動作するものをPerl 6とすることにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another aspect of this is the Perl 6 compiler will be self-hosting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の側面は、Perl 6コンパイラをセルフホスティングすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>様々なコード出力バックエンドが開発されたら、最終的にはコンパイラ自身をコンパイルするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは主にフロントエンドからプラットフォームの依存性を取り除き、バックエンドだけがプラットフォーム固有の問題を気にするようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The word &quot;apocalypse&quot; historically meant merely &quot;a revealing&quot;, and we're using it in that unexciting sense.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>&quot;apocalypse&quot; という言葉は歴史的には啓示することを意味します。我々はそのありきたりな意味で使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたがRFCを一般人に尋ねたら、興味深いが矛盾した多くのアイデアを得るでしょう。人々の意見は極端に分かれがちで、どのアイデアもお互いに構築することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Larry's First Law of Language Redesign: Everyone wants the colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Larryによる新しい言語設計の最初の秩序：みんながcolonを望む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このドキュメントはApocalypse 2の要約で、小規模の字句項目と類型的問題を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(These Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(Apocalypsesと違い、これらのSynopsesは時間と共に進化するPerl 6のデザインの更新を反映します。 Apocalypsesは歴史的資料としてある時点で凍結されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの更新は記録されません―SynopsisがApocalypseと異なるなら、Synopsisが正しいと見なして下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブ言語のパーサーによる拡張のために、Perlはワンパスの予測的パーサーによって解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, lookahead of more than one &quot;longest token&quot; is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>つまり、複数の最長トークンの先読みは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これについて現在知られている例外は、パーサーが以下のようにしなければならない場合です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>sigilで始まり、ブロックで終わる、または終わらないかもしれない展開式の終了位置を決定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Recognize that a reduce operator is not really beginning a <bpt i='0' x='0'>&lt;c0&gt;</bpt>[...]<ept i='0'>&lt;/c0&gt;</ept> composer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減少演算子が<bpt i='0' x='0'>&lt;c0&gt;</bpt>[...]<ept i='0'>&lt;/c0&gt;</ept>の生成を開始するとは限らないと認識する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>理論上はPerlはユニコードで記述され、基本的なテキスト表現に関係なく一貫したユニコードのセマンティクス(意味)を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default Perl presents Unicode in &quot;NFG&quot; formation, where each grapheme counts as one character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの書記素が1文字として数えられる場所では、PerlはデフォルトでユニコードをNFG形式で表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書記素とは初心者ユーザーが日常生活の中で考えると思われるあらゆる発音記号を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlはユニコードの行とパラグラフのセパレータを行マーカーとして数えることが出来ます。しかし、その振る舞いはあなたのエディタが考えるユニコードの行とPerlの行番号の考え方がマッチするように設定出来るべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードの水平空白は空白として数えられます。しかし、単独のトークンに見えるような隣接したトークンを生成するような場所ではem幅の空白は使わないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方でPerlはインデントを文法として使わないので、空白が意味をなす場所ではいくらでも自由に空白を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメントは常に空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの構文上の目的で、Perlは括弧でないものから括弧文字を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧文字は双方向対称かPs/Pe/Pi/Pfプロパティのどちらかのユニコード文字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実用上はPs/Pe/Pi/Pfプロパティの文字を使うのが最も安全ですが、ASCIIの不等号括弧はPs/Pe/Pi/Pfセットではないのに双方向なので注目すべき例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応する閉じ文字がない文字は括弧の開始と見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはユニコードBidiMirroringデータテーブルの第2セクションを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字が既にPs/Pe/Pi/Pfマッピングで使用されている場合、どのBidiMirroringのエントリも無視されます（前方、後方マッピング両方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any given Ps character, the next Pe codepoint (in numerical order) is assumed to be its matching character even if that is not what you might guess using left-right symmetry.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>任意のPs文字に対して次のPeコードポイント(番号順)は、たとえあなたが左右対称だと思っていなくてもマッチする文字と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore <bpt i='0' x='0'>&lt;c0&gt;</bpt>U+298D<ept i='0'>&lt;/c0&gt;</ept> maps to <bpt i='1' x='1'>&lt;c1&gt;</bpt>U+298E<ept i='1'>&lt;/c1&gt;</ept>, not <bpt i='2' x='2'>&lt;c2&gt;</bpt>U+2990<ept i='2'>&lt;/c2&gt;</ept>, and <bpt i='3' x='3'>&lt;c3&gt;</bpt>U+298F<ept i='3'>&lt;/c3&gt;</ept> maps to <bpt i='4' x='4'>&lt;c4&gt;</bpt>U+2990<ept i='4'>&lt;/c4&gt;</ept>, not <bpt i='5' x='5'>&lt;c5&gt;</bpt>U+298E<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従って<bpt i='0' x='0'>&lt;c0&gt;</bpt>U+298D<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>U+2990<ept i='2'>&lt;/c2&gt;</ept>ではなく<bpt i='1' x='1'>&lt;c1&gt;</bpt>U+298E<ept i='1'>&lt;/c1&gt;</ept>にマップされ、<bpt i='3' x='3'>&lt;c3&gt;</bpt>U+298F<ept i='3'>&lt;/c3&gt;</ept>は<bpt i='5' x='5'>&lt;c5&gt;</bpt>U+298E<ept i='5'>&lt;/c5&gt;</ept>ではなく<bpt i='4' x='4'>&lt;c4&gt;</bpt>U+2990<ept i='4'>&lt;/c4&gt;</ept>にマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Neither <bpt i='6' x='6'>&lt;c6&gt;</bpt>U+298E<ept i='6'>&lt;/c6&gt;</ept> nor <bpt i='7' x='7'>&lt;c7&gt;</bpt>U+2990<ept i='7'>&lt;/c7&gt;</ept> are valid bracket openers, despite having reverse mappings in the BidiMirroring table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>U+298E<ept i='6'>&lt;/c6&gt;</ept>と<bpt i='7' x='7'>&lt;c7&gt;</bpt>U+2990<ept i='7'>&lt;/c7&gt;</ept>はどちらも括弧の開始ではありません。にもかかわらずBidiMirroringテーブルに逆のマッピングを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>U+301D<ept i='0'>&lt;/c0&gt;</ept> codepoint has two closing alternatives, <bpt i='1' x='1'>&lt;c1&gt;</bpt>U+301E<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>U+301F<ept i='2'>&lt;/c2&gt;</ept>; Perl 6 only recognizes the one with lower code point number, <bpt i='3' x='3'>&lt;c3&gt;</bpt>U+301E<ept i='3'>&lt;/c3&gt;</ept>, as the closing brace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>U+301D<ept i='0'>&lt;/c0&gt;</ept>コードポイントは2つの代替の終了文字を持っています。<bpt i='1' x='1'>&lt;c1&gt;</bpt>U+301E<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>U+301F<ept i='2'>&lt;/c2&gt;</ept>です。Perl 6は低いコードポイント数の<bpt i='3' x='3'>&lt;c3&gt;</bpt>U+301E<ept i='3'>&lt;/c3&gt;</ept>だけを閉じブレースとして認識します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This policy also applies to new one-to-many mappings introduced in the future.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポリシーは未来に登場する新しい1対多のマッピングにも適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, many-to-one mappings are fine; multiple opening characters may map to the same closing character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、多対1は構いません。複数の開始文字は同じ終了文字にマップするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, U+2018, U+201A, and U+201B may all be used as the opener for the U+2019 closer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えばU+2018、U+201A、U+201Bは全てU+2019クローザーに対するオープナーとして使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constructs that count openers and closers assume that only the given opener is special.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オープナーとクローザーを考慮する構造は、与えられたオープナーだけが特別と見なします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if you open with one of the alternatives, all other alternatives are treated as non-bracketing characters within that construct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>つまり代替文字の1つで開く場合、他の代替文字はその構造では非括弧文字として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>POD sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6ではPODセクションは複数行コメントとして確実に使用されるようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, POD syntax now lets you use <bpt i='0' x='0'>&lt;c0&gt;</bpt>=begin comment<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>=end comment<ept i='1'>&lt;/c1&gt;</ept> delimit a POD block correctly without the need for <bpt i='2' x='2'>&lt;c2&gt;</bpt>=cut<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と違い、現在のPOD構文は<bpt i='0' x='0'>&lt;c0&gt;</bpt>=begin comment<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>=end comment<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>=cut<ept i='2'>&lt;/c2&gt;</ept>無しでPODブロックを正しく区切って使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In fact, <bpt i='3' x='3'>&lt;c3&gt;</bpt>=cut<ept i='3'>&lt;/c3&gt;</ept> is now gone.) The format name does not have to be <bpt i='4' x='4'>&lt;c4&gt;</bpt>comment<ept i='4'>&lt;/c4&gt;</ept> -- any unrecognized format name will do to make it a comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(現に、<bpt i='3' x='3'>&lt;c3&gt;</bpt>=cut<ept i='3'>&lt;/c3&gt;</ept>は無くなりました。)フォーマット名は <bpt i='4' x='4'>&lt;c4&gt;</bpt>comment<ept i='4'>&lt;/c4&gt;</ept>である必要はありません。識別されないフォーマット名はコメントになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(However, bare <bpt i='5' x='5'>&lt;c5&gt;</bpt>=begin<ept i='5'>&lt;/c5&gt;</ept> and <bpt i='6' x='6'>&lt;c6&gt;</bpt>=end<ept i='6'>&lt;/c6&gt;</ept> probably aren't good enough, because all comments in them will show up in the formatted output.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(しかし、裸の<bpt i='5' x='5'>&lt;c5&gt;</bpt>=begin<ept i='5'>&lt;/c5&gt;</ept>と<bpt i='6' x='6'>&lt;c6&gt;</bpt>=end<ept i='6'>&lt;/c6&gt;</ept>ではおそらく不十分です。その中の全てのコメントがフォーマットされて表示されてしまうからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We have single paragraph comments with <bpt i='0' x='0'>&lt;c0&gt;</bpt>=for comment<ept i='0'>&lt;/c0&gt;</ept> as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに、単独のパラグラフコメント<bpt i='0' x='0'>&lt;c0&gt;</bpt>=for comment<ept i='0'>&lt;/c0&gt;</ept>があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That lets <bpt i='1' x='1'>&lt;c1&gt;</bpt>=for<ept i='1'>&lt;/c1&gt;</ept> keep its meaning as the equivalent of a <bpt i='2' x='2'>&lt;c2&gt;</bpt>=begin<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>=end<ept i='3'>&lt;/c3&gt;</ept> combined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='1' x='1'>&lt;c1&gt;</bpt>=for<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>=begin<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>=end<ept i='3'>&lt;/c3&gt;</ept>が結合したものと同等の意味を持つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with <bpt i='4' x='4'>&lt;c4&gt;</bpt>=begin<ept i='4'>&lt;/c4&gt;</ept> and <bpt i='5' x='5'>&lt;c5&gt;</bpt>=end<ept i='5'>&lt;/c5&gt;</ept>, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='4' x='4'>&lt;c4&gt;</bpt>=begin<ept i='4'>&lt;/c4&gt;</ept>と<bpt i='5' x='5'>&lt;c5&gt;</bpt>=end<ept i='5'>&lt;/c5&gt;</ept>のように、コメントはコードの前から後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since there is a newline before the first <bpt i='0' x='0'>&lt;c0&gt;</bpt>=<ept i='0'>&lt;/c0&gt;</ept>, the POD form of comment counts as whitespace equivalent to a newline.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の<bpt i='0' x='0'>&lt;c0&gt;</bpt>=<ept i='0'>&lt;/c0&gt;</ept>の前に改行が現れるまで、POD形式のコメントは改行と同様に空白としてカウントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みドキュメントの詳細はS26を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Except within a string literal, a <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6では文字列リテラルを除いて、<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>は常にコメントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two forms of comment based on <bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept>を元にしたコメントは2つの形式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Embedded comments require the <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> to be followed by one or more opening bracketing characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントは1つかそれ以上の括弧の開始文字が続く<bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All other uses of <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> are interpreted as single-line comments that work just as in Perl 5, starting with a <bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept> character and ending at the subsequent newline.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その他の<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>の使用はPerl 5のように1行コメントとして解釈され、<bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept>で始まって次の改行で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは分割を目的とした改行と同じく空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> may <bpt i='3' x='3'>&lt;i3&gt;</bpt>not<ept i='3'>&lt;/i3&gt;</ept> be used as the delimiter in quoting constructs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と違い、<bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>はクォートを構築する区切り文字としては使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Embedded comments are supported as a variant on quoting syntax, introduced by <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> plus any user-selected bracket characters (as defined in <bpt i='1' x='1'>&lt;a1&gt;</bpt>Lexical Conventions<ept i='1'>&lt;/a1&gt;</ept> above):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントはクォーティング構文の変化形としてサポートされ、<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>とユーザーが選んだ括弧文字(<bpt i='1' x='1'>&lt;a1&gt;</bpt>Lexical Conventions<ept i='1'>&lt;/a1&gt;</ept>で定義されているもの)で導入されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧は普通の引用括弧と同じポリシーに沿ってネストするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There must be no space between the <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> and the opening bracket character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧の開始文字と<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>の間に空白を置くことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(There may be the <bpt i='1' x='1'>&lt;i1&gt;</bpt>visual appearance<ept i='1'>&lt;/i1&gt;</ept> of space for some double-wide characters, however, such as the corner quotes above.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(上記のかぎ括弧のように見栄えのあるダブルワイド文字がいくつかあります。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An embedded comment is not allowed as the first thing on the line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行頭に埋め込みコメントを置くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to have a comment there, you must disambiguate it to either an embedded comment or a line-end comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしそこにコメントを置きたいなら、埋め込みコメントか行コメントの曖昧さをなくす必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can put a space in front of it to make it an embedded comment:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントにするために、前に空白を置くことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or you can put something other than a single <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> to make it a line-end comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または行コメントにするために単一の<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>以外のものを置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, if you are commenting out a block of code using the line-comment form, we recommend that you use <bpt i='1' x='1'>&lt;c1&gt;</bpt>##<ept i='1'>&lt;/c1&gt;</ept>, or <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> followed by some whitespace, preferably a tab to keep any tab formatting consistent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従って、もしコードブロックを行コメントを使ってコメントアウトするなら、空白(タブによるフォーマッティングを一貫するならタブが好ましい)が続く<bpt i='1' x='1'>&lt;c1&gt;</bpt>##<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>を使うことをお勧めします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it's often better to use pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、PODコメントは暗黙の行指向なのでそちらの方が良い場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And if you have an intelligent syntax highlighter that will mark pod comments in a different color, there's less visual need for a <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> on every line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに、もしあなたがPODコメントを色分けする賢いシンタックスハイライターを持っているなら、それぞれの<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>の行に必要なビジュアルが少なくなってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユーザーが選んだ括弧のクォート構文で、複数の一致する括弧文字を使うことが出来ます。閉じ括弧は同じ数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧のネストは開き括弧と同じ数でなければ適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note however that bare circumfix or postcircumfix <bpt i='0' x='0'>&lt;c0&gt;</bpt>&lt;&lt;...&gt;&gt;<ept i='0'>&lt;/c0&gt;</ept> is not a user-selected bracket, but the ASCII variant of the <bpt i='1' x='1'>&lt;c1&gt;</bpt>«...»<ept i='1'>&lt;/c1&gt;</ept> interpolating word list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし注意として、裸の接周辞または後置接周辞<bpt i='0' x='0'>&lt;c0&gt;</bpt>&lt;&lt;...&gt;&gt;<ept i='0'>&lt;/c0&gt;</ept>はユーザー選択の括弧ではなく、<bpt i='1' x='1'>&lt;c1&gt;</bpt>«...»<ept i='1'>&lt;/c1&gt;</ept>のワードリストを展開したASCII形式の別記法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> and the <bpt i='3' x='3'>&lt;c3&gt;</bpt>q<ept i='3'>&lt;/c3&gt;</ept>-style quoters (including <bpt i='4' x='4'>&lt;c4&gt;</bpt>m<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>s<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>tr<ept i='6'>&lt;/c6&gt;</ept>, and <bpt i='7' x='7'>&lt;c7&gt;</bpt>rx<ept i='7'>&lt;/c7&gt;</ept>) enable subsequent user-selected brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>q<ept i='3'>&lt;/c3&gt;</ept>スタイルのクォート(<bpt i='4' x='4'>&lt;c4&gt;</bpt>m<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>s<ept i='5'>&lt;/c5&gt;</ept>、 <bpt i='6' x='6'>&lt;c6&gt;</bpt>tr<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>rx<ept i='7'>&lt;/c7&gt;</ept>を含む)だけが後に続くユーザー選択の括弧を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C言語のようないくつかの言語は、行を結合するために改行をエスケープすることを認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の言語(正規表現など)は空白文字のバックスラッシュを様々な理由で認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はこの概念をあらゆる種類の空白に一般化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with <bpt i='0' x='0'>&lt;c0&gt;</bpt>\<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる連続する空白(コメント含む)は<bpt i='0' x='0'>&lt;c0&gt;</bpt>\<ept i='0'>&lt;/c0&gt;</ept>を前置することによってパーサーから隠蔽されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as the &quot;unspace&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはunspaceとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>unspaceはPerlの様々な空白のいずれかの依存関係を隠することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えばPerlは名詞と後置演算子の間に空白が無いことを要求するので、unspaceを使うことで後置演算子を繋げることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の使い方をサポートするための特別な場合として、後置演算子が期待される場所でのバックスラッシュはunspaceの変質した形式と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意として、それの前に空白は置けません。そのため</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は構文エラーです(行に2つの項)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will be parsed as a list operator with a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept> argument:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は<bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept>引数を伴うリスト演算子と解析されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、他の形式のunspaceは空白の前にきて役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それ故に単項のバックスラッシュの使われ方は空白が続かないこと、または空白をunspaceと受け取ることです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の後置演算子もunspaceを活用できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一つ見えない空白の使い方は、典型的にはドット後置演算子を次の行に置くことです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But unspace is mainly about language extensibility: it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしunspaceは主に言語の拡張性に関するものです。あなたが現在インストールしているパーサーに関わらず、改行がパーサーを混乱させるかもしれないあらゆる場面で行を継続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Unless, of course, you override the unspace rule itself...)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(もちろん、あなたがunspaceのルール自体を上書きすれば別ですが・・・)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、unspaceはパーサーから空白を隠しますが、レクサーからは隠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果として、unspaceはトークンとして認められません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、unspaceが1つ以上の改行を含むなら依然として行番号がカウントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> following such a newline is always an end-of-line comment, as described above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような改行に続く<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>は上に述べたように常に行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Podチャンク(かたまり)は言語にとって空白として数えられるので、それもunspaceによって取り込むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヒアドキュメントの境界は隠蔽されます。けれども、あなたは過度に長いヒアドキュメントの出だしの行をこのように分割できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヒアドキュメントのパーサーは単にこのように見ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this is one of those cases in which it is fine to have whitespace before the unspace, since we're only trying to suppress the newline transition, not all whitespace as in the case of postfix parsing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意として、これはunspaceの前に空白を置いても構わないケースの1つです。なので接尾辞の解析については我々は全ての空白ではなく改行の変わり目を隠そうと試みているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note also that the example above is not meant to spec how the test suite works.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(さらに注意として、上記の例はテストスイートの動作仕様を意図していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>unspaceはコメントを含むかもしれませんが、コメントはunspaceを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、行コメントはバックスラッシュを意味のあるものとして扱いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>it is an end-of-line comment, not an embedded comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントではなく行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のように書くと:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般に、単独のトークンか他の構文上の単位と間違って解釈される構成を分離する必要がある場所を除いて、Perl 6での空白は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In other words, Perl 6 follows the standard <bpt i='0' x='0'>&lt;i0&gt;</bpt>longest-token<ept i='0'>&lt;/i0&gt;</ept> principle, or in the cases of large constructs, a <bpt i='1' x='1'>&lt;i1&gt;</bpt>prefer shifting to reducing<ept i='1'>&lt;/i1&gt;</ept> principle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(言い換えれば、Perl 6は標準の<bpt i='0' x='0'>&lt;i0&gt;</bpt>最長トークン<ept i='0'>&lt;/i0&gt;</ept>の原則、または大きな構文の場合は<bpt i='1' x='1'>&lt;i1&gt;</bpt>prefer shifting to reducing<ept i='1'>&lt;/i1&gt;</ept>の原則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i='2' x='2'>&lt;a2&gt;</bpt>Grammatical Categories<ept i='2'>&lt;/a2&gt;</ept> below for more on how a Perl program is analyzed into tokens.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlプログラムがどのようにトークンに解析されるか、詳細については<bpt i='2' x='2'>&lt;a2&gt;</bpt>Grammatical Categories<ept i='2'>&lt;/a2&gt;</ept>を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは不変の深いルールです。しかしPerl 6は可変の言語となるように設計されているので、様々な演算子や言語にマクロを追加したり削除することで表面上の悪影響を変えるということが起こるのを我々は期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、項の後で後置演算子と2項演算子の間の自然な競合がどちらかで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし与えられたトークンが後置演算子か2項演算子と解釈されそうなら、2項演算子の前に空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置演算子は間に入る空白を持ちませんが、間に入るドットを持つことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上で分離が望まれるなら、空白がunspaceか埋め込みコメントの外側に発生しない限り前述のunspaceか埋め込みコメントが使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, if you were to add your own <bpt i='0' x='0'>&lt;c0&gt;</bpt>infix:&lt;++&gt;<ept i='0'>&lt;/c0&gt;</ept> operator, then it must have space before it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えばあなたの<bpt i='0' x='0'>&lt;c0&gt;</bpt>infix:&lt;++&gt;<ept i='0'>&lt;/c0&gt;</ept>という2項演算子を追加するとしたら、その前に必ず空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The normal autoincrementing <bpt i='1' x='1'>&lt;c1&gt;</bpt>postfix:&lt;++&gt;<ept i='1'>&lt;/c1&gt;</ept> operator may never have space before it, but may be written in any of these forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準の自動インクリメント<bpt i='1' x='1'>&lt;c1&gt;</bpt>postfix:&lt;++&gt;<ept i='1'>&lt;/c1&gt;</ept>演算子はその前に空白を持ちませんが、これらの形式のどれかで書かれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on <bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept> where a term is expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(クォートを区切るかunspaceを終了することは除いて)項が期待される場所で前に空白があるドットは常に<bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept>のメソッド呼び出しとみなされます。 それが接尾辞のルールの結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その箇所で項が期待されていないなら、それは構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(もちろんドットで始まる名前の2項演算子があるなら別ですが。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You could, for instance, define a Fortranly <bpt i='1' x='1'>&lt;c1&gt;</bpt>infix:&lt;.EQ.&gt;<ept i='1'>&lt;/c1&gt;</ept> if the fit took you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、その気になればFortran風の<bpt i='1' x='1'>&lt;c1&gt;</bpt>infix:&lt;.EQ.&gt;<ept i='1'>&lt;/c1&gt;</ept>を定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしあなたはそれの前に常に空白を置くか、代わりに後置メソッド呼び出しと解釈されるようにして気をつけなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は常に次のように解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のいくつかの変化形を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし後置のメソッド呼び出しを意味するなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One consequence of all this is that you may no longer write a Num as <bpt i='0' x='0'>&lt;c0&gt;</bpt>42.<ept i='0'>&lt;/c0&gt;</ept> with just a trailing dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これら全ての内の1つの結果として、ただの終端ドットを伴うNumを <bpt i='0' x='0'>&lt;c0&gt;</bpt>42.<ept i='0'>&lt;/c0&gt;</ept>として書くことはもはやできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must instead say either <bpt i='1' x='1'>&lt;c1&gt;</bpt>42<ept i='1'>&lt;/c1&gt;</ept> or <bpt i='2' x='2'>&lt;c2&gt;</bpt>42.0<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりにあなたは<bpt i='1' x='1'>&lt;c1&gt;</bpt>42<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>42.0<ept i='2'>&lt;/c2&gt;</ept>のどちらかにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば、もし直後の文字が数字なら、数の直後のドットは小数点にしかなり得ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、後置のドットはいくつかの種類のメソッド呼び出し構文の開始と取られるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The <bpt i='3' x='3'>&lt;c3&gt;</bpt>.123<ept i='3'>&lt;/c3&gt;</ept> form with a leading dot is still allowed however when a term is expected, and is equivalent to <bpt i='4' x='4'>&lt;c4&gt;</bpt>0.123<ept i='4'>&lt;/c4&gt;</ept> rather than <bpt i='5' x='5'>&lt;c5&gt;</bpt>$_.123<ept i='5'>&lt;/c5&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(項が期待される場合でも、直前のドットを伴う<bpt i='3' x='3'>&lt;c3&gt;</bpt>.123<ept i='3'>&lt;/c3&gt;</ept>形式がまだ認められています。そしてそれは<bpt i='5' x='5'>&lt;c5&gt;</bpt>$_.123<ept i='5'>&lt;/c5&gt;</ept>ではなく<bpt i='4' x='4'>&lt;c4&gt;</bpt>0.123<ept i='4'>&lt;/c4&gt;</ept>と同じです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In support of OO encapsulation, there is a new fundamental datatype: <bpt i='0' x='0'>&lt;s0&gt;</bpt>P6opaque<ept i='0'>&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクト指向カプセル化のサポートの中で、新しい基本データ型があります: <bpt i='0' x='0'>&lt;s0&gt;</bpt>P6opaque<ept i='0'>&lt;/s0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>opaqueオブジェクトへの外部からのアクセスは常にメソッド呼び出しを通して行われます。属性でさえそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はより安全でより良く動作するコードを書くことを助ける選択自由な型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラがあなたの提供可能な型情報を推測するのは自由です。しかしあなたが尋ねない限り、欠落した型情報について文句を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型は構造的な等価性よりも名前の等価性で正式に比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、我々は名前を考えることに寛大であることを好みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &quot;anonymous&quot;).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、名前は型を定義するモジュールに関連付けられたバージョンと権限を含みます(たとえ型自体が無名でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &quot;long name&quot; of the resulting type, so one <bpt i='0' x='0'>&lt;c0&gt;</bpt>Array of Int<ept i='0'>&lt;/c0&gt;</ept> is equivalent to another <bpt i='1' x='1'>&lt;c1&gt;</bpt>Array of Int<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上でパラメータを伴う型をインスタンス化する場合、引数は結果となる型の長い名前の一部と考えられるので、ある<bpt i='0' x='0'>&lt;c0&gt;</bpt>Array of Int<ept i='0'>&lt;/c0&gt;</ept>は他の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Array of Int<ept i='1'>&lt;/c1&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Another way to look at it is that the type instantiation &quot;factory&quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それを調べるもう一つの方法は、型をインスタンス化するファクトリーがメモ化されることです。)型名の別名は元の型と同等とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Array of Int<ept i='2'>&lt;/c2&gt;</ept> syntax is just sugar for <bpt i='3' x='3'>&lt;c3&gt;</bpt>Array:of(Int)<ept i='3'>&lt;/c3&gt;</ept>, which is the canonical form of an instantiated generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に<bpt i='2' x='2'>&lt;c2&gt;</bpt>Array of Int<ept i='2'>&lt;/c2&gt;</ept>という構文はインスタンス化されたジェネリックタイプの正規形である<bpt i='3' x='3'>&lt;c3&gt;</bpt>Array:of(Int)<ept i='3'>&lt;/c3&gt;</ept>の単なるシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このパラメータを伴う型の名前の等価性は不変(または少なくとも不変のスナップショットを撮ることが出来る)とみなせるパラメータだけを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別個の2つのクラスはたとえ同じ属性を持っていても決して同等とは見なされません。なぜならクラスは不変とみなされないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 supports the notion of <bpt i='0' x='0'>&lt;s0&gt;</bpt>properties<ept i='0'>&lt;/s0&gt;</ept> on various kinds of objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は様々な種類のオブジェクトで<bpt i='0' x='0'>&lt;s0&gt;</bpt>プロパティ<ept i='0'>&lt;/s0&gt;</ept>の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのクラスではなく個々のオブジェクトに管理されている場合を除いて、プロパティはオブジェクトの属性に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S12に従って、プロパティは実際にはミックスインメカニズムのようなもので実装され、そのようなミックスインはオブジェクトに対する個々の無名クラスの生成によって完成します(同じ無名クラスがまだ存在せず、安全に共有できるのであれば)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called <bpt i='0' x='0'>&lt;s0&gt;</bpt>traits<ept i='0'>&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティはコンパイル時に構成される変数やクラスなどに適用され、<bpt i='0' x='0'>&lt;s0&gt;</bpt>トレイト<ept i='0'>&lt;/s0&gt;</ept>とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>トレイトを実行時に変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時のプロパティの変更は代わりにミックスインによって行われます。これによってコンパイラーは宣言されたトレイトを元に最適化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンですが、都合が悪いならオブジェクト指向で考える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、ファイルハンドルのようないくつかのビルトインの概念はPerl 5以上にユーザーに見える形でオブジェクト指向的になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数の型とは、変数がどのような値を含む可能性があるかを示す制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &quot;role&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より正確には、オブジェクトまたは変数に格納されたオブジェクトがroleで示されたメソッドに応答できることの保証です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数自体はどの種類のものを含むか指定せず、どのように動作するかを指定するコンテナ型にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制約とコンテナ型は一緒に使用することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept> is also initialized to the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept> type object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept>が<bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept>型オブジェクトで初期化されることにも注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これについて詳しくは以下を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>my Dog $spot<ept i='0'>&lt;/c0&gt;</ept> by itself does not automatically call a <bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept> constructor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>my Dog $spot<ept i='0'>&lt;/c0&gt;</ept>自体は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>のコンストラクターを自動で呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It merely assigns an undefined <bpt i='2' x='2'>&lt;c2&gt;</bpt>Dog<ept i='2'>&lt;/c2&gt;</ept> prototype object to <bpt i='3' x='3'>&lt;c3&gt;</bpt>$spot<ept i='3'>&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは単に未定義の<bpt i='2' x='2'>&lt;c2&gt;</bpt>Dog<ept i='2'>&lt;/c2&gt;</ept>プロトタイプオブジェクトを<bpt i='3' x='3'>&lt;c3&gt;</bpt>$spot<ept i='3'>&lt;/c3&gt;</ept>に割り当てます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type name used as a value is an undefined instance of that type's prototype object, or <bpt i='0' x='0'>&lt;i0&gt;</bpt>type object<ept i='0'>&lt;/i0&gt;</ept> for short.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値として使われる任意の型名はその型の未定義のプロトタイプオブジェクト、短くはタイプオブジェクトのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>右辺コンテキストでの型名は単独の型の値としてパースされ、それに続く引数がないことを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしタイプオブジェクトは関数呼び出しインターフェースに応答するので、あなたは型の名前を括弧と一緒に関数であるかのように使用するでしょう。そして呼び出しに供給されるどんな引数もタイプオブジェクトの示す型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしも括弧に引数が無いなら、タイプオブジェクト自身を返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a real <bpt i='0' x='0'>&lt;c0&gt;</bpt>Dog<ept i='0'>&lt;/c0&gt;</ept> object, call a constructor method such as <bpt i='1' x='1'>&lt;c1&gt;</bpt>new<ept i='1'>&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本当の<bpt i='0' x='0'>&lt;c0&gt;</bpt>Dog<ept i='0'>&lt;/c0&gt;</ept>オブジェクトを得るために、<bpt i='1' x='1'>&lt;c1&gt;</bpt>new<ept i='1'>&lt;/c1&gt;</ept>のようなコンストラクタメソッドを呼んで下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様にコンストラクタに引数を渡すことも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>you are declaring that the elements of <bpt i='0' x='0'>&lt;c0&gt;</bpt>@array<ept i='0'>&lt;/c0&gt;</ept> are native integers, but that the array itself is implemented by the <bpt i='1' x='1'>&lt;c1&gt;</bpt>MyArray<ept i='1'>&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>@array<ept i='0'>&lt;/c0&gt;</ept>の要素をネイティブ整数と宣言しますが、配列自身は<bpt i='1' x='1'>&lt;c1&gt;</bpt>MyArray<ept i='1'>&lt;/c1&gt;</ept>クラスで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型指定されていない配列とハッシュはいまだに何でも受け入れますが、Perl 5と同じパフォーマンスの問題を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get the number of elements in an array, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.elems<ept i='0'>&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素数を得るには<bpt i='0' x='0'>&lt;c0&gt;</bpt>.elems<ept i='0'>&lt;/c0&gt;</ept>メソッドを使用して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also ask for the total string length of an array's elements, in bytes, codepoints or graphemes, using these methods <bpt i='1' x='1'>&lt;c1&gt;</bpt>.bytes<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>.codes<ept i='2'>&lt;/c2&gt;</ept> or <bpt i='3' x='3'>&lt;c3&gt;</bpt>.graphs<ept i='3'>&lt;/c3&gt;</ept> respectively on the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i='1' x='1'>&lt;c1&gt;</bpt>.bytes<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>.codes<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>.graphs<ept i='3'>&lt;/c3&gt;</ept>メソッドを使用してバイト、コードポイント、書記素でそれぞれの配列要素の文字列の長さの合計を求めることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に文字列にも同じメソッドを適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that <bpt i='4' x='4'>&lt;c4&gt;</bpt>.bytes<ept i='4'>&lt;/c4&gt;</ept> is not guaranteed to be well-defined when the encoding is unknown.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='4' x='4'>&lt;c4&gt;</bpt>.bytes<ept i='4'>&lt;/c4&gt;</ept>はエンコーディングが不明な場合は明確には保証されないので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i='5' x='5'>&lt;c5&gt;</bpt>.codes<ept i='5'>&lt;/c5&gt;</ept> is not well-defined unless you know which canonicalization is in effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i='5' x='5'>&lt;c5&gt;</bpt>.codes<ept i='5'>&lt;/c5&gt;</ept>はどの正規化が有効なのか不明な場合は明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hence, both methods allow an optional argument to specify the meaning exactly if it cannot be known from context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのため、両方のメソッドはコンテキストから知ることができない場合に正確な意味を指定するための任意の引数を受け入れます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no <bpt i='0' x='0'>&lt;c0&gt;</bpt>.length<ept i='0'>&lt;/c0&gt;</ept> method for either arrays or strings, because <bpt i='1' x='1'>&lt;c1&gt;</bpt>length<ept i='1'>&lt;/c1&gt;</ept> does not specify a unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>.length<ept i='0'>&lt;/c0&gt;</ept>メソッドは配列と文字列のどちらにもありません。なぜなら<bpt i='1' x='1'>&lt;c1&gt;</bpt>length<ept i='1'>&lt;/c1&gt;</ept>は単位を指定しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビルトインオブジェクト型は大文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes immutable types (e.g. <bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>, <bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>Complex<ept i='2'>&lt;/c2&gt;</ept>, <bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>Bit<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>Regex<ept i='6'>&lt;/c6&gt;</ept>, <bpt i='7' x='7'>&lt;c7&gt;</bpt>Set<ept i='7'>&lt;/c7&gt;</ept>, <bpt i='8' x='8'>&lt;c8&gt;</bpt>Block<ept i='8'>&lt;/c8&gt;</ept>, <bpt i='9' x='9'>&lt;c9&gt;</bpt>List<ept i='9'>&lt;/c9&gt;</ept>, <bpt i='10' x='10'>&lt;c10&gt;</bpt>Seq<ept i='10'>&lt;/c10&gt;</ept>), as well as mutable (container) types, such as <bpt i='11' x='11'>&lt;c11&gt;</bpt>Scalar<ept i='11'>&lt;/c11&gt;</ept>, <bpt i='12' x='12'>&lt;c12&gt;</bpt>Array<ept i='12'>&lt;/c12&gt;</ept>, <bpt i='13' x='13'>&lt;c13&gt;</bpt>Hash<ept i='13'>&lt;/c13&gt;</ept>, <bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>, <bpt i='15' x='15'>&lt;c15&gt;</bpt>Routine<ept i='15'>&lt;/c15&gt;</ept>, <bpt i='16' x='16'>&lt;c16&gt;</bpt>Module<ept i='16'>&lt;/c16&gt;</ept>, and non-instantiable Roles such as <bpt i='17' x='17'>&lt;c17&gt;</bpt>Callable<ept i='17'>&lt;/c17&gt;</ept>, <bpt i='18' x='18'>&lt;c18&gt;</bpt>Failure<ept i='18'>&lt;/c18&gt;</ept>, and <bpt i='19' x='19'>&lt;c19&gt;</bpt>Integral<ept i='19'>&lt;/c19&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは変更不可の型を含みます(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Complex<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>Bit<ept i='5'>&lt;/c5&gt;</ept>、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Regex<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>Set<ept i='7'>&lt;/c7&gt;</ept>、<bpt i='8' x='8'>&lt;c8&gt;</bpt>Block<ept i='8'>&lt;/c8&gt;</ept>、<bpt i='9' x='9'>&lt;c9&gt;</bpt>List<ept i='9'>&lt;/c9&gt;</ept>、<bpt i='10' x='10'>&lt;c10&gt;</bpt>Seq<ept i='10'>&lt;/c10&gt;</ept>など)。変更可能な(コンテナ)型も同様です。<bpt i='11' x='11'>&lt;c11&gt;</bpt>Scalar<ept i='11'>&lt;/c11&gt;</ept>、<bpt i='12' x='12'>&lt;c12&gt;</bpt>Array<ept i='12'>&lt;/c12&gt;</ept>、<bpt i='13' x='13'>&lt;c13&gt;</bpt>Hash<ept i='13'>&lt;/c13&gt;</ept>、<bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>、<bpt i='15' x='15'>&lt;c15&gt;</bpt>Routine<ept i='15'>&lt;/c15&gt;</ept>、<bpt i='16' x='16'>&lt;c16&gt;</bpt>Module<ept i='16'>&lt;/c16&gt;</ept>など。そしてインスタンス化できない<bpt i='17' x='17'>&lt;c17&gt;</bpt>Callable<ept i='17'>&lt;/c17&gt;</ept>、<bpt i='18' x='18'>&lt;c18&gt;</bpt>Failure<ept i='18'>&lt;/c18&gt;</ept>、<bpt i='19' x='19'>&lt;c19&gt;</bpt>Integral<ept i='19'>&lt;/c19&gt;</ept>なども同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Non-object (native) types are lowercase: <bpt i='0' x='0'>&lt;c0&gt;</bpt>int<ept i='0'>&lt;/c0&gt;</ept>, <bpt i='1' x='1'>&lt;c1&gt;</bpt>num<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>complex<ept i='2'>&lt;/c2&gt;</ept>, <bpt i='3' x='3'>&lt;c3&gt;</bpt>rat<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>buf<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>bit<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトでない(ネイティブ)型は小文字です: <bpt i='0' x='0'>&lt;c0&gt;</bpt>int<ept i='0'>&lt;/c0&gt;</ept>、<bpt i='1' x='1'>&lt;c1&gt;</bpt>num<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>complex<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>rat<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>buf<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>bit<ept i='5'>&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型は主にコンパクトな配列ストレージを宣言するためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、Perlはそれらを対応する大文字の型のように扱えるようにしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In other words, it does autoboxing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(言い換えれば、自動ボックス化を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note, however, that sometimes repeated autoboxing can slow your program more than the native type can speed it up.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、自動ボックス化の繰り返しがネイティブ型のスピードアップ以上にプログラムを遅くすることもあるので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>junction<ept i='0'>&lt;/c0&gt;</ept> type is considered a native type because its internal representation is fixed, and you may not usefully derive from it because the intent of junctions is to autothread any method calls on them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>内部表現が固定されているので、<bpt i='0' x='0'>&lt;c0&gt;</bpt>junction<ept i='0'>&lt;/c0&gt;</ept>型はネイティブ型と見なされます。そしてjunctionの意図はあらゆるメソッド呼び出しを自動スレッド化することなので、それから有益に派生させることはできないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのオブジェクトは値型として振る舞うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every object can produce a &quot;WHICH&quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのオブジェクトはハッシュと値ベースの比較のために一意に識別するためのWHICH値を出力できます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normal objects just use their address in memory, but if a class wishes to behave as a value type, it can define a <bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept> method that makes different objects look like the same object if they happen to have the same contents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常のオブジェクトはそれらのメモリアドレス使うだけですが、クラスが値型として振る舞いたい場合に、異なるオブジェクトが同じ内容を持つ場合が発生するなら同じオブジェクトのように見せる<bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept>メソッドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables with non-native types can always contain <bpt i='0' x='0'>&lt;i0&gt;</bpt>undefined<ept i='0'>&lt;/i0&gt;</ept> values, such as <bpt i='1' x='1'>&lt;c1&gt;</bpt>Object<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept> objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非ネイティブ型を伴う変数は常に<bpt i='1' x='1'>&lt;c1&gt;</bpt>Object<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept>オブジェクトなどの<bpt i='0' x='0'>&lt;i0&gt;</bpt>undefined<ept i='0'>&lt;/i0&gt;</ept>値を含むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S04 for more about failures (i.e. unthrown exceptions):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>failures(例えばunthrown exceptionsなど)の詳細についてはS04を参照して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型を伴う変数は未定義をサポートしません: 未定義値をそれらに割り当てるとエラーになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>推測: numはundefからNaNへの自動変換をサポートするかもしれないので、浮動小数点形式はこの概念を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ロケットの設計者が自己破壊を即座に行うかその後間もなく行うか決めることが出来るように、その変換を任意に出来るなら良いかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables of non-native types start out containing an undefined value unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非ネイティブ型は明示的に定義された値で初期化されなければ未定義値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every object supports a <bpt i='0' x='0'>&lt;c0&gt;</bpt>HOW<ept i='0'>&lt;/c0&gt;</ept> function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのオブジェクトは、オブジェクトが定義されているかどうかに関わらずそれを管理するメタクラスのインスタンスを返す<bpt i='0' x='0'>&lt;c0&gt;</bpt>HOW<ept i='0'>&lt;/c0&gt;</ept>関数/メソッドをサポートします: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(プロトタイプシステム(クラスベースでないオブジェクトシステム)のために、全てのオブジェクトは単に同じメタオブジェクトによって管理されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は型宣言のシステムを通してbig integersとbig rationalsを本質的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept> automatically supports promotion to arbitrary precision, as well as holding <bpt i='1' x='1'>&lt;c1&gt;</bpt>Inf<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>NaN<ept i='2'>&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Inf<ept i='1'>&lt;/c1&gt;</ept>値と<bpt i='2' x='2'>&lt;c2&gt;</bpt>NaN<ept i='2'>&lt;/c2&gt;</ept>値を保持するのと同様に任意の精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i='3' x='3'>&lt;c3&gt;</bpt>Int<ept i='3'>&lt;/c3&gt;</ept> assumes 2's complement arithmetic, so <bpt i='4' x='4'>&lt;c4&gt;</bpt>+^1 == -2<ept i='4'>&lt;/c4&gt;</ept> is guaranteed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>Int<ept i='3'>&lt;/c3&gt;</ept>は2の補数演算を想定することに注意して下さい。なので<bpt i='4' x='4'>&lt;c4&gt;</bpt>+^1 == -2<ept i='4'>&lt;/c4&gt;</ept>が保証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Native <bpt i='5' x='5'>&lt;c5&gt;</bpt>int<ept i='5'>&lt;/c5&gt;</ept> operations need not support this on machines that are not natively 2's complement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(ネイティブの<bpt i='5' x='5'>&lt;c5&gt;</bpt>int<ept i='5'>&lt;/c5&gt;</ept>演算は2の補数をネイティブにサポートしていないマシンではサポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must convert to and from <bpt i='6' x='6'>&lt;c6&gt;</bpt>Int<ept i='6'>&lt;/c6&gt;</ept> to do portable bitops on such ancient hardware.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i='6' x='6'>&lt;c6&gt;</bpt>Int<ept i='6'>&lt;/c6&gt;</ept>への変換や逆のことをそのような古いハードウェアで移植性のあるビット演算に出来るようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Num<ept i='0'>&lt;/c0&gt;</ept> may support arbitrary-precision floating-point arithmetic, but is not required to unless we can do so portably and efficiently.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Num<ept i='0'>&lt;/c0&gt;</ept>は任意の精度の浮動小数点演算をサポートします。しかし移植性があり効率的に行うことが出来ないのであれば必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept> must support the largest native floating point format that runs at full speed.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>は最も大きいネイティブ浮動小数点フォーマットをフルスピードで実行できるようにサポートしなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Rat<ept i='0'>&lt;/c0&gt;</ept> supports arbitrary precision rational arithmetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Rat<ept i='0'>&lt;/c0&gt;</ept>は任意の精度の有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, dividing two <bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept> objects using <bpt i='2' x='2'>&lt;c2&gt;</bpt>infix:<it pos='end' x='2'>&lt;/&gt;&lt;/c2&gt;</it> produces a fraction of <bpt i='3' x='3'>&lt;c3&gt;</bpt>Num<ept i='3'>&lt;/c3&gt;</ept> type, not a ratio.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、2つの<bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept>オブジェクトを<bpt i='2' x='2'>&lt;c2&gt;</bpt>infix:<it pos='end' x='2'>&lt;/&gt;&lt;/c2&gt;</it>で除算するとレシオではなく<bpt i='3' x='3'>&lt;c3&gt;</bpt>Num<ept i='3'>&lt;/c3&gt;</ept>型の端数を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can produce a ratio by using <bpt i='4' x='4'>&lt;c4&gt;</bpt>infix:&lt;div&gt;<ept i='4'>&lt;/c4&gt;</ept> on two integers instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに<bpt i='4' x='4'>&lt;c4&gt;</bpt>infix:&lt;div&gt;<ept i='4'>&lt;/c4&gt;</ept>を使ってレシオを生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lower-case types like <bpt i='0' x='0'>&lt;c0&gt;</bpt>int<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>num<ept i='1'>&lt;/c1&gt;</ept> imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>int<ept i='0'>&lt;/c0&gt;</ept>、<bpt i='1' x='1'>&lt;c1&gt;</bpt>num<ept i='1'>&lt;/c1&gt;</ept>のような小文字型はマシンネイティブの整数と浮動小数点表現を意味します。それぞれは任意の精度へ昇格しませんが、テンポラリ値についてはより大きい表現が常に許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless qualified with a number of bits, <bpt i='2' x='2'>&lt;c2&gt;</bpt>int<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>num<ept i='3'>&lt;/c3&gt;</ept> types represent the largest native integer and floating-point types that run at full speed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット数で制限されなければ、<bpt i='2' x='2'>&lt;c2&gt;</bpt>int<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>num<ept i='3'>&lt;/c3&gt;</ept>型はフルスピードで実行される最も大きな整数と浮動小数点を表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric values in untyped variables use <bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept> semantics rather than <bpt i='2' x='2'>&lt;c2&gt;</bpt>int<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>num<ept i='3'>&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型のない変数での数値は<bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>int<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>num<ept i='3'>&lt;/c3&gt;</ept>より優先して使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 should by default make standard IEEE floating point concepts visible, such as <bpt i='0' x='0'>&lt;c0&gt;</bpt>Inf<ept i='0'>&lt;/c0&gt;</ept> (infinity) and <bpt i='1' x='1'>&lt;c1&gt;</bpt>NaN<ept i='1'>&lt;/c1&gt;</ept> (not a number).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はデフォルトで<bpt i='0' x='0'>&lt;c0&gt;</bpt>Inf<ept i='0'>&lt;/c0&gt;</ept>(無限)と<bpt i='1' x='1'>&lt;c1&gt;</bpt>NaN<ept i='1'>&lt;/c1&gt;</ept>(数でない)のような標準のIEEE小数点概念を見えるようにするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レキシカルスコープ内でプラグマはテンポラリ値の性質、そして様々な環境下で浮動小数点がどの様に振る舞うか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>うまく機能しないプラットフォームを回避するために壮大な努力を必要とする場合を除いて、全てのIEEEモードがプラグマによってレキシカルに使用可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デフォルトの浮動小数点モードは例外をスローするのではなくInfとNaNを伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ボックス化されたオブジェクト型はオーバーフローかアンダーフローが発生したところでより詳細な情報を伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlでの計算法はどこでも同じ答えを与えるように設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are designed to give the typical programmer the tools to achieve a good enough answer most of the time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは一般的なプログラマーにほとんどの場合十分な答えを果たすツールを与えるように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(本当によいプログラマーは時折もっと良く改善します。)大抵、これは重要でないアルゴリズムの愚行に十分なビットの使用を引き起こすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept> is a Unicode string object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept>はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no corresponding native <bpt i='1' x='1'>&lt;c1&gt;</bpt>str<ept i='1'>&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応するネイティブ<bpt i='1' x='1'>&lt;c1&gt;</bpt>str<ept i='1'>&lt;/c1&gt;</ept>型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, since a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Str<ept i='2'>&lt;/c2&gt;</ept> object may fill multiple roles, we say that a <bpt i='3' x='3'>&lt;c3&gt;</bpt>Str<ept i='3'>&lt;/c3&gt;</ept> keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし<bpt i='2' x='2'>&lt;c2&gt;</bpt>Str<ept i='2'>&lt;/c2&gt;</ept>オブジェクトは複数のロールを果たすので、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Str<ept i='3'>&lt;/c3&gt;</ept>はユニコードの抽象レベルで最小と最大のトラックを保持します。そしてバイト、コードポイント、 書記素またはいくつかの言語の文字であるかどうか、現在のレキシカルスコープの理想的な文字のアイデアに沿ってうまく演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For all builtin operations, all <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept> positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのビルトイン操作について、全ての<bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>ポジションは整数ではなくポジションオブジェクトとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i='5' x='5'>&lt;c5&gt;</bpt>StrPos<ept i='5'>&lt;/c5&gt;</ept> objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これら<bpt i='5' x='5'>&lt;c5&gt;</bpt>StrPos<ept i='5'>&lt;/c5&gt;</ept>オブジェクトは特定の文字列の特定の場所を抽象レベルに依存せずポイントします。文字列と位置を直接に追跡するか、あらゆるコンテキストで同じ文字列に適用された場合に同じ結果を与える文字列の開始オフセットを抽象レベルに依存しない表現で出力するかどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is assuming the string isn't modified in the meanwhile; a <bpt i='6' x='6'>&lt;c6&gt;</bpt>StrPos<ept i='6'>&lt;/c6&gt;</ept> is not a &quot;marker&quot; and is not required to follow changes to a mutable string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは一方で文字列が変更されないと仮定しています; <bpt i='6' x='6'>&lt;c6&gt;</bpt>StrPos<ept i='6'>&lt;/c6&gt;</ept>はマーカーではなく、可変の文字列の変更を追跡する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、置換された文字列のマッチする位置を求めるとしたら、その答えは変更された文字列のポジションではなく元の文字列のものとして報告されます(今はアクセスできないかもしれません！)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subtraction of two <bpt i='0' x='0'>&lt;c0&gt;</bpt>StrPos<ept i='0'>&lt;/c0&gt;</ept> objects gives a <bpt i='1' x='1'>&lt;c1&gt;</bpt>StrLen<ept i='1'>&lt;/c1&gt;</ept> object, which is also not an integer, because the string between two positions also has multiple integer interpretations depending on the units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>2つの<bpt i='0' x='0'>&lt;c0&gt;</bpt>StrPos<ept i='0'>&lt;/c0&gt;</ept>オブジェクトの減算は<bpt i='1' x='1'>&lt;c1&gt;</bpt>StrLen<ept i='1'>&lt;/c1&gt;</ept>オブジェクトを与えます。それも整数ではありません。なぜなら2つのポジション間の文字列も単位に依存する複数の整数解釈を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A given <bpt i='2' x='2'>&lt;c2&gt;</bpt>StrLen<ept i='2'>&lt;/c2&gt;</ept> may know that it represents 18 bytes, 7 codepoints, 3 graphemes, and 1 letter in Malayalam, but it might only know this lazily because it actually just hangs onto the two <bpt i='3' x='3'>&lt;c3&gt;</bpt>StrPos<ept i='3'>&lt;/c3&gt;</ept> endpoints within the string that in turn may or may not just lazily point into the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた<bpt i='2' x='2'>&lt;c2&gt;</bpt>StrLen<ept i='2'>&lt;/c2&gt;</ept>は18バイト、7コードポイント、3書記素、そしてマラヤーラムの1文字を表現すると知っているでしょう。しかしそれはいい加減にしか知っていないかもしれません。なぜならそれは文字列を単にいい加減にポイントするかしていない文字列内の2つの<bpt i='3' x='3'>&lt;c3&gt;</bpt>StrPos<ept i='3'>&lt;/c3&gt;</ept>の終点を捕まえているだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The lazy implementation of <bpt i='4' x='4'>&lt;c4&gt;</bpt>StrLen<ept i='4'>&lt;/c4&gt;</ept> is much like a <bpt i='5' x='5'>&lt;c5&gt;</bpt>Range<ept i='5'>&lt;/c5&gt;</ept> object in that respect.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(その点に関して<bpt i='4' x='4'>&lt;c4&gt;</bpt>StrLen<ept i='4'>&lt;/c4&gt;</ept>のいいかげんな実装は<bpt i='5' x='5'>&lt;c5&gt;</bpt>Range<ept i='5'>&lt;/c5&gt;</ept>オブジェクトにそっくりです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポジションオブジェクトが期待されるところで整数を引数として使用すると、現在のレキシカルスコープのユニコード抽象レベルの単位を意味すると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(デフォルトは書記素です。)それ以外は適切な単位を強制する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もちろんそのような次元数は文字列が適切な抽象レベルを提供しないなら失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a <bpt i='0' x='0'>&lt;c0&gt;</bpt>StrPos<ept i='0'>&lt;/c0&gt;</ept> or <bpt i='1' x='1'>&lt;c1&gt;</bpt>StrLen<ept i='1'>&lt;/c1&gt;</ept> is forced into a numeric context, it will assume the units of the current Unicode abstraction level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>StrPos<ept i='0'>&lt;/c0&gt;</ept>か<bpt i='1' x='1'>&lt;c1&gt;</bpt>StrLen<ept i='1'>&lt;/c1&gt;</ept>が数値コンテキストを強制されると、現在のユニコード抽象レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような次元的でない数を間違った単位で解釈するルーチンに渡すのは誤っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implementation note: since Perl 6 mandates that the default Unicode processing level must view graphemes as the fundamental unit rather than codepoints, this has some implications regarding efficient implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実装上の注意: Perl 6はデフォルトのユニコード処理レベルをコードポイントよりも書記素を基本単位として見なければならないと命じるので、これは効率的な実装に注意を払ういくつかの意味合いを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is suggested that all graphemes be translated on input to a unique grapheme numbers and represented as integers within some kind of uniform array for fast substr access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>substrアクセスを高速化するため、いくつかの種類の均一な配列内で全ての書記素のインプットを固有の書記素数に変換し、整数として表現することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For those graphemes that have a precomposed form, use of that codepoint is suggested.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの構成済みの形式を持つ書記素のために、そのコードポイントを使うことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that this means Latin-1 can still be represented internally with 8-bit integers.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(これは、Latin-1がいまだに内部的に8ビット整数で表現されることができることに注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For graphemes that have no precomposed form, a temporary private id should be assigned that uniquely identifies the grapheme.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構成済みの形式を持たない書記素のために、テンポラリのプライベートIDは書記素を固有に識別するように割り当てられるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If such ids are assigned consistently thoughout the process, comparison of two graphemes is no more difficult than the comparison of two integers, and comparison of base characters no more difficult than a direct lookup into the id-to-NFD table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このようなIDが処理を通して一貫して割り当てられるなら、2つの書記素の比較はもはや2つの整数の比較より難しくありません。そして基本文字の比較はもはやid-to-NFDテーブル内の直接検索より難しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Obviously, any temporary grapheme ids must be translated back to some universal form (such as NFD) on output, and normal precomposed graphemes may turn into either NFC or NFD forms depending on the desired output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もちろん、あらゆるテンポラリ書記素IDはいくつかの普遍的な形式(NFDのような)に再変換されて出力されなければなりません。そして普通の構成済みの書記素は望まれる出力に従ってNFCかNFDのどちらかの形式に変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Maintaining a particular grapheme/id mapping over the life of the process may have some GC implications for long-running processes, but most processes will likely see a limited number of non-precomposed graphemes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>処理の期間にわたる特定の書記素/IDマッピングを扱うことは長期実行中のプロセスのためのいくつかのGC実装を持つかもしれません。しかし、おそらくほとんどのプロセスは限られた数の構成済みでない書記素を参照するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the program has a scope that wants a codepoint view rather than a grapheme view, the string visible to that lexical scope must also be translated to universal form, just as with output translation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしプログラムが書記素表示よりもコードポイント表示を望むスコープを持つなら、そのレキシカルスコープに見える文字列もまた出力変換と同時に普遍的な形式に変換されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternately, the temporary grapheme ids may be hidden behind an abstraction layer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、テンポラリ書記素IDは抽象化レイヤーから隠されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In any case, codepoint scope should never see any temporary grapheme ids.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どんな場合でも、コードポイントスコープはどのようなテンポラリ書記素IDも参照しないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The lexical codepoint declaration should probably specify which normalization form it prefers to view strings under.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(レキシカルコードポイント宣言はおそらく文字列を見下ろすことを好む正規化形式を指定するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such a declaration could be applied to input translation as well.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このような宣言は入力変換にも同様に適用できます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>Buf<ept i='0'>&lt;/c0&gt;</ept> is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of <bpt i='1' x='1'>&lt;c1&gt;</bpt>Str<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Buf<ept i='0'>&lt;/c0&gt;</ept>は整数配列の文字列的な見方です。そしていくつかの種類の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Str<ept i='1'>&lt;/c1&gt;</ept>へ明示的な変換がなければユニコードまたは文字のプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A <bpt i='2' x='2'>&lt;c2&gt;</bpt>buf<ept i='2'>&lt;/c2&gt;</ept> is the native counterpart.) Typically it's an array of bytes serving as a buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>buf<ept i='2'>&lt;/c2&gt;</ept>はネイティブに相当するものです。)通常、それはバッファとして供給するバイト配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise operations on a <bpt i='3' x='3'>&lt;c3&gt;</bpt>Buf<ept i='3'>&lt;/c3&gt;</ept> treat the entire buffer as a single large integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>Buf<ept i='3'>&lt;/c3&gt;</ept>のビット単位演算はバッファ全体を一つの巨大な整数として扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise operations on a <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept> generally fail unless the <bpt i='5' x='5'>&lt;c5&gt;</bpt>Str<ept i='5'>&lt;/c5&gt;</ept> in question can provide an abstract <bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept> interface somehow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>問題になっている<bpt i='5' x='5'>&lt;c5&gt;</bpt>Str<ept i='5'>&lt;/c5&gt;</ept>が<bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept>の抽象インターフェースをどうにかして提供しなければ、<bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>のビット単位演算は普通は失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Coercion to <bpt i='7' x='7'>&lt;c7&gt;</bpt>Buf<ept i='7'>&lt;/c7&gt;</ept> should generally invalidate the <bpt i='8' x='8'>&lt;c8&gt;</bpt>Str<ept i='8'>&lt;/c8&gt;</ept> interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='7' x='7'>&lt;c7&gt;</bpt>Buf<ept i='7'>&lt;/c7&gt;</ept>への強制は一般的には<bpt i='8' x='8'>&lt;c8&gt;</bpt>Str<ept i='8'>&lt;/c8&gt;</ept>のインターフェースを無効にするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a generic type <bpt i='9' x='9'>&lt;c9&gt;</bpt>Buf<ept i='9'>&lt;/c9&gt;</ept> may be instantiated as (or bound to) any of <bpt i='10' x='10'>&lt;c10&gt;</bpt>buf8<ept i='10'>&lt;/c10&gt;</ept>, <bpt i='11' x='11'>&lt;c11&gt;</bpt>buf16<ept i='11'>&lt;/c11&gt;</ept>, or <bpt i='12' x='12'>&lt;c12&gt;</bpt>buf32<ept i='12'>&lt;/c12&gt;</ept> (or to any type that provides the appropriate <bpt i='13' x='13'>&lt;c13&gt;</bpt>Buf<ept i='13'>&lt;/c13&gt;</ept> interface), but when used to create a buffer <bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept> defaults to <bpt i='15' x='15'>&lt;c15&gt;</bpt>buf8<ept i='15'>&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ジェネリック型としての<bpt i='9' x='9'>&lt;c9&gt;</bpt>Buf<ept i='9'>&lt;/c9&gt;</ept>は<bpt i='10' x='10'>&lt;c10&gt;</bpt>buf8<ept i='10'>&lt;/c10&gt;</ept>、<bpt i='11' x='11'>&lt;c11&gt;</bpt>buf16<ept i='11'>&lt;/c11&gt;</ept>、<bpt i='12' x='12'>&lt;c12&gt;</bpt>buf32<ept i='12'>&lt;/c12&gt;</ept>のどれか(または<bpt i='13' x='13'>&lt;c13&gt;</bpt>Buf<ept i='13'>&lt;/c13&gt;</ept>の適切なインターフェースを提供する何らかの型)によってインスタンス化（またはバインド）されます。バッファとして使われる場合、<bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>のデフォルトは<bpt i='15' x='15'>&lt;c15&gt;</bpt>buf8<ept i='15'>&lt;/c15&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept> types, <bpt i='1' x='1'>&lt;c1&gt;</bpt>Buf<ept i='1'>&lt;/c1&gt;</ept> types prefer to deal with integer string positions, and map these directly to the underlying compact array as indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept>型と異なり、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Buf<ept i='1'>&lt;/c1&gt;</ept>型は整数の文字列ポジションで処理することを好みます。そしてそれらをインデックスとして直接に基本的なコンパクト配列にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは必ずしもバイトポジションである必要はありません―整数ポジションは単にあるポジションがある基本的な整数型のセルを意味する基本的なポジションの数を数えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Builtin string operations on <bpt i='2' x='2'>&lt;c2&gt;</bpt>Buf<ept i='2'>&lt;/c2&gt;</ept> types return integers and expect integers when dealing with positions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>Buf<ept i='2'>&lt;/c2&gt;</ept>型のビルトイン文字列操作は整数を返し、ポジションを処理する時には整数を期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a limiting case, <bpt i='3' x='3'>&lt;c3&gt;</bpt>buf8<ept i='3'>&lt;/c3&gt;</ept> is just an old-school byte string, and the positions are byte positions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>限られた場合として、<bpt i='3' x='3'>&lt;c3&gt;</bpt>buf8<ept i='3'>&lt;/c3&gt;</ept>はただの古い習慣のバイト文字列で、ポジションはバイトポジションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note, though, that if you remap a section of <bpt i='4' x='4'>&lt;c4&gt;</bpt>buf32<ept i='4'>&lt;/c4&gt;</ept> memory to be <bpt i='5' x='5'>&lt;c5&gt;</bpt>buf8<ept i='5'>&lt;/c5&gt;</ept>, you'll have to multiply all your positions by 4.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただし、<bpt i='4' x='4'>&lt;c4&gt;</bpt>buf32<ept i='4'>&lt;/c4&gt;</ept>のメモリのセクションを<bpt i='5' x='5'>&lt;c5&gt;</bpt>buf8<ept i='5'>&lt;/c5&gt;</ept>に再マップするなら全てのポジションを4倍する必要があるので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>utf8<ept i='0'>&lt;/c0&gt;</ept> type is derived from <bpt i='1' x='1'>&lt;c1&gt;</bpt>buf8<ept i='1'>&lt;/c1&gt;</ept>, with the additional constraint that it may only contain validly encoded UTF-8.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>utf8<ept i='0'>&lt;/c0&gt;</ept>型は<bpt i='1' x='1'>&lt;c1&gt;</bpt>buf8<ept i='1'>&lt;/c1&gt;</ept>型から派生し、正当にエンコードされたUTF-8だけを含むという追加の制約を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, <bpt i='2' x='2'>&lt;c2&gt;</bpt>utf16<ept i='2'>&lt;/c2&gt;</ept> is derived from <bpt i='3' x='3'>&lt;c3&gt;</bpt>buf16<ept i='3'>&lt;/c3&gt;</ept>, and <bpt i='4' x='4'>&lt;c4&gt;</bpt>utf32<ept i='4'>&lt;/c4&gt;</ept> from <bpt i='5' x='5'>&lt;c5&gt;</bpt>buf32<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に<bpt i='2' x='2'>&lt;c2&gt;</bpt>utf16<ept i='2'>&lt;/c2&gt;</ept>は<bpt i='3' x='3'>&lt;c3&gt;</bpt>buf16<ept i='3'>&lt;/c3&gt;</ept>から派生し、<bpt i='4' x='4'>&lt;c4&gt;</bpt>utf32<ept i='4'>&lt;/c4&gt;</ept>は<bpt i='5' x='5'>&lt;c5&gt;</bpt>buf32<ept i='5'>&lt;/c5&gt;</ept>から派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは型名であり、制約にリスト演算形式は認められないので、それらを制約として呼び出すためには括弧を使う必要があるので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は常に次のように解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> character as a standalone term captures the notion of &quot;Whatever&quot;, which is applied lazily by whatever operator it is an argument to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項としての文字<bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>は“何でも”という概念を引き受けます。それは引数に対するwhatever演算子によっていいかげんに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally it can just be thought of as a &quot;glob&quot; that gives you everything it can in that argument position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的に、それは引数のポジションに何でも与える“glob”と考えることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept> is an undefined prototype object derived from <bpt i='1' x='1'>&lt;c1&gt;</bpt>Any<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Any<ept i='1'>&lt;/c1&gt;</ept>から派生した未定義のプロトタイプオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型としては抽象型で、定義されたオブジェクトとしてインスタンス化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If for a particular MMD dispatch, nothing in the MMD system claims it, it dispatches to as an <bpt i='2' x='2'>&lt;c2&gt;</bpt>Any<ept i='2'>&lt;/c2&gt;</ept> with an undefined value, and usually blows up constructively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし特定のMMDディスパッチに対してMMDシステムが何も主張しないなら、それは未定義値を伴う<bpt i='2' x='2'>&lt;c2&gt;</bpt>Any<ept i='2'>&lt;/c2&gt;</ept>にディスパッチされ、そして普通は前向きに怒ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが例外を合理的だと思わないなら、合理的な答えを生じさせると期待しないべきかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since the <bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept> object is effectively immutable, the optimizer is free to recognize <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> and optimize in the context of what operator it is being passed to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept>オブジェクトは事実上は不変なので、オプティマイザは<bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>を自由に認識することができ、どの演算子に渡されるのかコンテキストの中で最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most of the built-in numeric operators treat an argument of <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> as indicating the desire to create a function of a single unknown, so:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどのビルトイン数値演算子は引数の<bpt i='4' x='4'>&lt;c4&gt;</bpt>*<ept i='4'>&lt;/c4&gt;</ept>を単独の未知の関数を作成することを満たすとして扱います。つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>produces a function of a single argument:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は単独の引数の関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, the single dispatcher recognizes <bpt i='0' x='0'>&lt;c0&gt;</bpt>*.meth<ept i='0'>&lt;/c0&gt;</ept> and returns <bpt i='1' x='1'>&lt;c1&gt;</bpt>{ $_.meth }<ept i='1'>&lt;/c1&gt;</ept>, so it can be used where patterns are expected:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に単独のディスパッチャーは<bpt i='0' x='0'>&lt;c0&gt;</bpt>*.meth<ept i='0'>&lt;/c0&gt;</ept>を認識して<bpt i='1' x='1'>&lt;c1&gt;</bpt>{ $_.meth }<ept i='1'>&lt;/c1&gt;</ept>を返すので、そのパターンが期待される場所で使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These closures are of type <bpt i='0' x='0'>&lt;c0&gt;</bpt>Code:($)<ept i='0'>&lt;/c0&gt;</ept>, not <bpt i='1' x='1'>&lt;c1&gt;</bpt>Whatever<ept i='1'>&lt;/c1&gt;</ept>, so that constructs can distinguish via multiple dispatch:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのクロージャーは<bpt i='1' x='1'>&lt;c1&gt;</bpt>Whatever<ept i='1'>&lt;/c1&gt;</ept>ではなく<bpt i='0' x='0'>&lt;c0&gt;</bpt>Code:($)<ept i='0'>&lt;/c0&gt;</ept>型なので、その構造はマルチディスパッチによって区別できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bare <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> form may also be called as a function, and represents the identify function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>裸の<bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>形式は関数としても呼ぶことができ、関数の識別を表します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But note that this is <bpt i='0' x='0'>&lt;i0&gt;</bpt>not<ept i='0'>&lt;/i0&gt;</ept> what is happening above, or</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし注意として、これは上で起こっていることではありません。または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>would end up meaning:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は以下を意味することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>...<ept i='0'>&lt;/c0&gt;</ept> operator is instead dispatching bare <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> to a routine that does dwimmery, and in this case decides to supply a function { * + 1 }.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>...<ept i='0'>&lt;/c0&gt;</ept>演算子は代わりに<bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>を期待通りに動作するルーチンにディスパッチしています。そしてこの場合は関数 { * + 1 } を供給すると決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final element of an array is subscripted as <bpt i='0' x='0'>&lt;c0&gt;</bpt>@a[*-1]<ept i='0'>&lt;/c0&gt;</ept>, which means that when the subscripting operation discovers a <bpt i='1' x='1'>&lt;c1&gt;</bpt>Code<ept i='1'>&lt;/c1&gt;</ept> object for a subscript, it calls it and supplies an argument indicating the number of elements in (that dimension of) the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の最後の要素は<bpt i='0' x='0'>&lt;c0&gt;</bpt>@a[*-1]<ept i='0'>&lt;/c0&gt;</ept>として添字化され、それは添字操作が<bpt i='1' x='1'>&lt;c1&gt;</bpt>Code<ept i='1'>&lt;/c1&gt;</ept>オブジェクトを添字に見つけると、それを呼んで(その次元の)配列内の要素数を示す引数を供給することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variant of <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> is the <bpt i='1' x='1'>&lt;c1&gt;</bpt>**<ept i='1'>&lt;/c1&gt;</ept> term, which is of type <bpt i='2' x='2'>&lt;c2&gt;</bpt>HyperWhatever<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>の変化形は<bpt i='1' x='1'>&lt;c1&gt;</bpt>**<ept i='1'>&lt;/c1&gt;</ept>という項で、それは<bpt i='2' x='2'>&lt;c2&gt;</bpt>HyperWhatever<ept i='2'>&lt;/c2&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is generally understood to be a multidimension form of <bpt i='3' x='3'>&lt;c3&gt;</bpt>*<ept i='3'>&lt;/c3&gt;</ept> when that makes sense.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは一般的に、意味をなす場合は多次元形式の<bpt i='3' x='3'>&lt;c3&gt;</bpt>*<ept i='3'>&lt;/c3&gt;</ept>と理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When modified by an operator that would turn <bpt i='4' x='4'>&lt;c4&gt;</bpt>*<ept i='4'>&lt;/c4&gt;</ept> into a function of one argument, <bpt i='5' x='5'>&lt;c5&gt;</bpt>**<ept i='5'>&lt;/c5&gt;</ept> instead turns into a function with a slurpy argument, of type <bpt i='6' x='6'>&lt;c6&gt;</bpt>Code:(*@)<ept i='6'>&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子によって<bpt i='4' x='4'>&lt;c4&gt;</bpt>*<ept i='4'>&lt;/c4&gt;</ept>が1つの引数の関数に変換される場合、 <bpt i='5' x='5'>&lt;c5&gt;</bpt>**<ept i='5'>&lt;/c5&gt;</ept>は代わりにすばらしい引数を伴う関数、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Code:(*@)<ept i='6'>&lt;/c6&gt;</ept>型に変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore <bpt i='0' x='0'>&lt;c0&gt;</bpt>@array[^**]<ept i='0'>&lt;/c0&gt;</ept> represents <bpt i='1' x='1'>&lt;c1&gt;</bpt>@array[{ map { ^* }, @_ }]<ept i='1'>&lt;/c1&gt;</ept>, that is to say, every element of the array, no matter how many dimensions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従って<bpt i='0' x='0'>&lt;c0&gt;</bpt>@array[^**]<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>@array[{ map { ^* }, @_ }]<ept i='1'>&lt;/c1&gt;</ept>を表し、配列の次元数を問わない配列の全要素ということになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(However, <bpt i='2' x='2'>&lt;c2&gt;</bpt>@array[**]<ept i='2'>&lt;/c2&gt;</ept> means the same thing because (as with <bpt i='3' x='3'>&lt;c3&gt;</bpt>...<ept i='3'>&lt;/c3&gt;</ept> above), the subscript operator will interpret bare <bpt i='4' x='4'>&lt;c4&gt;</bpt>**<ept i='4'>&lt;/c4&gt;</ept> as meaning all the subscripts, not the list of dimension sizes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(ただし<bpt i='2' x='2'>&lt;c2&gt;</bpt>@array[**]<ept i='2'>&lt;/c2&gt;</ept>は同じことを意味します。なぜなら (<bpt i='3' x='3'>&lt;c3&gt;</bpt>...<ept i='3'>&lt;/c3&gt;</ept>で述べたように)添字演算子は裸の<bpt i='4' x='4'>&lt;c4&gt;</bpt>**<ept i='4'>&lt;/c4&gt;</ept>を全ての添字と解釈し、次元のサイズのリストとは解釈しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The meaning of <bpt i='5' x='5'>&lt;c5&gt;</bpt>Whatever<ept i='5'>&lt;/c5&gt;</ept> is always controlled by its immediate context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='5' x='5'>&lt;c5&gt;</bpt>Whatever<ept i='5'>&lt;/c5&gt;</ept>の意味は常にその場のコンテキストによってコントロールされます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other uses for <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>**<ept i='1'>&lt;/c1&gt;</ept> will doubtless suggest themselves over time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>**<ept i='1'>&lt;/c1&gt;</ept>の他の用途はそのうちにそれら自身で示されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラがそうでなければ、これらはMMDシステムによって意味を与えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型の値は、それらの対になる大文字の型のオブジェクトとして扱われる時はautobox化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including <bpt i='0' x='0'>&lt;c0&gt;</bpt>bit<ept i='0'>&lt;/c0&gt;</ept>) default to 0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型はPerlの概念の未定義値を表現できないので、明確な初期化がなければネイティブ浮動小数点はデフォルトでNaN、整数（<bpt i='0' x='0'>&lt;c0&gt;</bpt>bit<ept i='0'>&lt;/c0&gt;</ept>含む)はデフォルトで0になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>complex型のデフォルトはNaN + NaN\iです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既知のサイズのbuf型は0の値のシーケンスがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any native type is explicitly initialized to <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> (the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept> type), no initialization is attempted and you'll get whatever was already there when the memory was allocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしネイティブ型が<bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept>型)に明示的に初期化されたら、メモリに既に割り当てられた値が割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしbuf型がユニコード文字列の値で初期化されたら、文字列はユニコードのコードポイントに分解され、それぞれのコードポイントは整数の要素に押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>buf型のサイズが指定されない場合は、初期化する文字列の長さから持ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サイズが指定された場合は文字列は必要に応じて切り詰められるか0で埋められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time; otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either <bpt i='0' x='0'>&lt;c0&gt;</bpt>U+FFFD<ept i='0'>&lt;/c0&gt;</ept> (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or <bpt i='1' x='1'>&lt;c1&gt;</bpt>U+007f<ept i='1'>&lt;/c1&gt;</ept> (DELETE) if the larger value would not fit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしコードポイントがbufの整数型にフィットしない場合は、コンパイル時に検出できるならパースエラーが発生します。そうでなければ実行時に警告され、オーバーフローしたバッファの要素は適切な代替文字<bpt i='0' x='0'>&lt;c0&gt;</bpt>U+FFFD<ept i='0'>&lt;/c0&gt;</ept> (置き換え文字、整数型が少なくとも16ビットの場合)か<bpt i='1' x='1'>&lt;c1&gt;</bpt>U+007f<ept i='1'>&lt;/c1&gt;</ept> (削除文字、より大きい値にフィットしない場合)に置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の変換を望む場合は、明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, no conversion to UTF-8 or UTF-16 is attempted; that must be specified explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特にUTF-8かUTF-16への変換は試みられません。明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それが起こったら、32ビット整数ベースのbufへの変換はネイティブエンディアンの有効なUTF-32を生成します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These can behave as values or objects of any class, except that <bpt i='0' x='0'>&lt;c0&gt;</bpt>defined<ept i='0'>&lt;/c0&gt;</ept> always returns false.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>defined<ept i='0'>&lt;/c0&gt;</ept>が常にfalseを返す場合を除き、未定義型は値または何かのクラスのオブジェクトとして振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One can create them with the built-in <bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>fail<ept i='2'>&lt;/c2&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは組み込みの<bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>fail<ept i='2'>&lt;/c2&gt;</ept>関数で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(failuresがどの様に処理されるかはS04を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どの種類のtype、class、moduleまたはpackageを定義した場合でも、自動的に同じ名前の未定義プロトタイプ値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Failure<ept i='0'>&lt;/c0&gt;</ept> value is put into a typed container, it takes on the type specified by the container but continues to carry the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Failure<ept i='1'>&lt;/c1&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Failure<ept i='0'>&lt;/c0&gt;</ept>値が型付けされたコンテナに設置された時はいつでもコンテナによって指定された型を引き受けますが、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Failure<ept i='1'>&lt;/c1&gt;</ept>のroleをもたらし続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The <bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept> function merely returns the most generic <bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept>関数は最も一般的な<bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='4' x='4'>&lt;c4&gt;</bpt>fail<ept i='4'>&lt;/c4&gt;</ept> to return more specific failures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より特定のfailuresを返すには<bpt i='4' x='4'>&lt;c4&gt;</bpt>fail<ept i='4'>&lt;/c4&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='5' x='5'>&lt;c5&gt;</bpt>Object<ept i='5'>&lt;/c5&gt;</ept> for the most generic non-failure undefined value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も一般的なnon-failureの未定義値には<bpt i='5' x='5'>&lt;c5&gt;</bpt>Object<ept i='5'>&lt;/c5&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='6' x='6'>&lt;c6&gt;</bpt>Any<ept i='6'>&lt;/c6&gt;</ept> type is also undefined, but excludes <bpt i='7' x='7'>&lt;c7&gt;</bpt>junctions<ept i='7'>&lt;/c7&gt;</ept> so that autothreading may be dispatched using normal multiple dispatch rules.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>Any<ept i='6'>&lt;/c6&gt;</ept>型も未定義ですが、autothreadingは普通のマルチディスパッチの規則でディスパッチされるので<bpt i='7' x='7'>&lt;c7&gt;</bpt>junctions<ept i='7'>&lt;/c7&gt;</ept>は除外します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>Nil<ept i='0'>&lt;/c0&gt;</ept> type is officially undefined as an item but interpolates as a null list into list context, and an empty capture into slice context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Nil<ept i='0'>&lt;/c0&gt;</ept>型は項目として公式に未定義ですが、リストコンテキストではnullリストに、スライスコンテキストでは空キャプチャに補間されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='1' x='1'>&lt;c1&gt;</bpt>Nil<ept i='1'>&lt;/c1&gt;</ept> object may also carry failure information, but if so, the object behaves as a failure only in item context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>Nil<ept i='1'>&lt;/c1&gt;</ept>オブジェクトはfailureの情報ももたらしますが、もしそうなら、オブジェクトはitemコンテキストでのみfailureとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='2' x='2'>&lt;c2&gt;</bpt>Failure<ept i='2'>&lt;/c2&gt;</ept>/<bpt i='3' x='3'>&lt;c3&gt;</bpt>undef<ept i='3'>&lt;/c3&gt;</ept> when you want to return a hard failure that will not evaporate in list context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストコンテキストで消滅しないhard failureを返したい時は <bpt i='2' x='2'>&lt;c2&gt;</bpt>Failure<ept i='2'>&lt;/c2&gt;</ept>/<bpt i='3' x='3'>&lt;c3&gt;</bpt>undef<ept i='3'>&lt;/c3&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects with these types behave like values, i.e. <bpt i='0' x='0'>&lt;c0&gt;</bpt>$x === $y<ept i='0'>&lt;/c0&gt;</ept> is true if and only if their types and contents are identical (that is, if <bpt i='1' x='1'>&lt;c1&gt;</bpt>$x.WHICH<ept i='1'>&lt;/c1&gt;</ept> eqv <bpt i='2' x='2'>&lt;c2&gt;</bpt>$y.WHICH<ept i='2'>&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型は値のように振る舞います。すなわち、<bpt i='0' x='0'>&lt;c0&gt;</bpt>$x === $y<ept i='0'>&lt;/c0&gt;</ept>はそれらの型と内容が同一の場合のみtrueです。(つまり<bpt i='1' x='1'>&lt;c1&gt;</bpt>$x.WHICH<ept i='1'>&lt;/c1&gt;</ept> eqv <bpt i='2' x='2'>&lt;c2&gt;</bpt>$y.WHICH<ept i='2'>&lt;/c2&gt;</ept>なら)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Insofar as Lists are lazy, they're really only partially immutable, in the sense that the past is fixed but the future is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Listsがlazyである限りにおいて、過去が固定され、未来がないという意味では、それらは本当に部分的にだけ不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The portion of a List yet to be determined by iterators may depend on mutable values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>まだイテレータによって決定されていないListの部分は変更可能な値に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an iterator is called upon to iterate and extend the known part of the list, some number of immutable values (which includes immutable references to mutable objects) are decided and locked in at that point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イテレータがリストの既知の部分の反復と拡張の上で呼ばれた時、いくつかの数の不変の値(変更可能なオブジェクトへの不変なリファレンスを含む)が決定され、その点でロックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterators may have several different ways of iterating depending on the degree of laziness/eagerness desired in context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテキストで望まれるlaziness/eagernessの度合いに応じてイテレータはいくつかの異なる方法を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The iterator API is described in S07.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イテレータのAPIはS07で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Instant<ept i='0'>&lt;/c0&gt;</ept>s and <bpt i='1' x='1'>&lt;c1&gt;</bpt>Duration<ept i='1'>&lt;/c1&gt;</ept>s are measured in atomic seconds with fractions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Instant<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>Duration<ept i='1'>&lt;/c1&gt;</ept>は有理数で微少時間に測定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notionally they are real numbers which may be implemented in either <bpt i='2' x='2'>&lt;c2&gt;</bpt>Num<ept i='2'>&lt;/c2&gt;</ept> or <bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>理論上、それらは<bpt i='2' x='2'>&lt;c2&gt;</bpt>Num<ept i='2'>&lt;/c2&gt;</ept>か<bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>型で実装される実数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Fixed-point implementations are strongly discouraged.) Interfaces that take <bpt i='4' x='4'>&lt;c4&gt;</bpt>Duration<ept i='4'>&lt;/c4&gt;</ept> arguments, such as sleep(), may also take <bpt i='5' x='5'>&lt;c5&gt;</bpt>Num<ept i='5'>&lt;/c5&gt;</ept> arguments, but <bpt i='6' x='6'>&lt;c6&gt;</bpt>Instant<ept i='6'>&lt;/c6&gt;</ept> arguments must be explicitly created via any of various culturally aware time specification APIs that, by and large, are outside the <bpt i='7' x='7'>&lt;c7&gt;</bpt>CORE<ept i='7'>&lt;/c7&gt;</ept> of Perl 6, with the possible exception of a constructor taking a native TAI value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(固定小数点の実装は強く推奨されません。)sleep()のような<bpt i='4' x='4'>&lt;c4&gt;</bpt>Duration<ept i='4'>&lt;/c4&gt;</ept>の引数を受け取るインターフェースは<bpt i='5' x='5'>&lt;c5&gt;</bpt>Num<ept i='5'>&lt;/c5&gt;</ept>引数も受け取りますが、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Instant<ept i='6'>&lt;/c6&gt;</ept>引数はさまざまな文化を理解した時間仕様のAPI(概してPerl 6の<bpt i='7' x='7'>&lt;c7&gt;</bpt>CORE<ept i='7'>&lt;/c7&gt;</ept>の外側で、ネイティブTAI値を受け取るコンストラクタの可能な例外を伴う)によって明示的に作成されたものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric context a <bpt i='8' x='8'>&lt;c8&gt;</bpt>Duration<ept i='8'>&lt;/c8&gt;</ept> happily returns a <bpt i='9' x='9'>&lt;c9&gt;</bpt>Num<ept i='9'>&lt;/c9&gt;</ept> representing seconds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキストでは<bpt i='8' x='8'>&lt;c8&gt;</bpt>Duration<ept i='8'>&lt;/c8&gt;</ept>は喜んで秒を表す<bpt i='9' x='9'>&lt;c9&gt;</bpt>Num<ept i='9'>&lt;/c9&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If pressed for a number, an <bpt i='10' x='10'>&lt;c10&gt;</bpt>Instant<ept i='10'>&lt;/c10&gt;</ept> will return the length of time in atomic seconds from the TAI epoch, but it will be unhappy about it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値が求められる場面では<bpt i='10' x='10'>&lt;c10&gt;</bpt>Instant<ept i='10'>&lt;/c10&gt;</ept>はTAIエポック値の微少時間の長さを返すでしょう。しかしそれに関しては適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Systems which cannot provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>POSIXのような安定したタイムベースを返すことができないシステムでは、正しい微少時間を最大限に推測できるようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects with these types have distinct <bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept> values that do not change even if the object's contents change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型のオブジェクトはそれぞれがオブジェクトの内容が変わっても変わらない<bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept>値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(Routinesは変更可能と見なされます。なぜならそれらは適所にラップされることができるからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyHash<ept i='0'>&lt;/c0&gt;</ept> differs from a normal <bpt i='1' x='1'>&lt;c1&gt;</bpt>Hash<ept i='1'>&lt;/c1&gt;</ept> in how it handles default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyHash<ept i='0'>&lt;/c0&gt;</ept>は通常の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Hash<ept i='1'>&lt;/c1&gt;</ept>とデフォルト値の扱いが異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of a <bpt i='2' x='2'>&lt;c2&gt;</bpt>KeyHash<ept i='2'>&lt;/c2&gt;</ept> element is set to the default value for the <bpt i='3' x='3'>&lt;c3&gt;</bpt>KeyHash<ept i='3'>&lt;/c3&gt;</ept>, the element is deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>KeyHash<ept i='2'>&lt;/c2&gt;</ept>の要素の値が<bpt i='3' x='3'>&lt;c3&gt;</bpt>KeyHash<ept i='3'>&lt;/c3&gt;</ept>のデフォルト値にセットされていた場合、その要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If undeclared, the default default for a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyHash<ept i='4'>&lt;/c4&gt;</ept> is 0 for numeric types, <bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept> for boolean types, and the null string for string and buffer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言されていない場合、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyHash<ept i='4'>&lt;/c4&gt;</ept>のデフォルトのデフォルトは数値型では0、ブール型では<bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept>、文字列とバッファ型ではnull文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept> of a <bpt i='7' x='7'>&lt;c7&gt;</bpt>Object<ept i='7'>&lt;/c7&gt;</ept> type defaults to the undefined prototype for that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='7' x='7'>&lt;c7&gt;</bpt>Object<ept i='7'>&lt;/c7&gt;</ept>型の<bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept>はその型の未定義プロトタイプがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More generally, the default default is whatever defined value an <bpt i='8' x='8'>&lt;c8&gt;</bpt>undef<ept i='8'>&lt;/c8&gt;</ept> would convert to for that value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より一般的には、デフォルトのデフォルトは定義された値のなんでもの型に変換されるであろう<bpt i='8' x='8'>&lt;c8&gt;</bpt>undef<ept i='8'>&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyHash<ept i='9'>&lt;/c9&gt;</ept> of <bpt i='10' x='10'>&lt;c10&gt;</bpt>Scalar<ept i='10'>&lt;/c10&gt;</ept> deletes elements that go to either 0 or the null string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='10' x='10'>&lt;c10&gt;</bpt>Scalar<ept i='10'>&lt;/c10&gt;</ept>の<bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyHash<ept i='9'>&lt;/c9&gt;</ept>は0かnull文字列の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='11' x='11'>&lt;c11&gt;</bpt>KeyHash<ept i='11'>&lt;/c11&gt;</ept> also autodeletes keys for normal undef values (that is, those undefined values that do not contain an unthrown exception).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='11' x='11'>&lt;c11&gt;</bpt>KeyHash<ept i='11'>&lt;/c11&gt;</ept>は通常のundef値のキーも削除します(つまりそれらの未定義値はスローされない例外を含みません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeySet<ept i='0'>&lt;/c0&gt;</ept> is a <bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept> of booleans with a default of <bpt i='2' x='2'>&lt;c2&gt;</bpt>False<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeySet<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>False<ept i='2'>&lt;/c2&gt;</ept>をデフォルトにしたブール値の<bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use the <bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept> interface and increment an element of a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeySet<ept i='4'>&lt;/c4&gt;</ept> its value becomes true (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし<bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept>インターフェースを使い、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeySet<ept i='4'>&lt;/c4&gt;</ept>の要素を増やした場合はその値はtrueになります(要素が存在しない場合は作成する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし要素を減らした場合はその要素はfalseになり、自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decrementing a non-existing value results in a <bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在しない値を減らすと<bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept>値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Incrementing an existing value results in <bpt i='6' x='6'>&lt;c6&gt;</bpt>True<ept i='6'>&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在する値を増やすと<bpt i='6' x='6'>&lt;c6&gt;</bpt>True<ept i='6'>&lt;/c6&gt;</ept>を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When not used as a <bpt i='7' x='7'>&lt;c7&gt;</bpt>Hash<ept i='7'>&lt;/c7&gt;</ept> (that is, when used as an <bpt i='8' x='8'>&lt;c8&gt;</bpt>Array<ept i='8'>&lt;/c8&gt;</ept> or list or <bpt i='9' x='9'>&lt;c9&gt;</bpt>Set<ept i='9'>&lt;/c9&gt;</ept> object) a <bpt i='10' x='10'>&lt;c10&gt;</bpt>KeySet<ept i='10'>&lt;/c10&gt;</ept> behaves as a <bpt i='11' x='11'>&lt;c11&gt;</bpt>Set<ept i='11'>&lt;/c11&gt;</ept> of its keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし<bpt i='7' x='7'>&lt;c7&gt;</bpt>Hash<ept i='7'>&lt;/c7&gt;</ept>として使わない場合(つまり<bpt i='8' x='8'>&lt;c8&gt;</bpt>Array<ept i='8'>&lt;/c8&gt;</ept>かリストか<bpt i='9' x='9'>&lt;c9&gt;</bpt>Set<ept i='9'>&lt;/c9&gt;</ept>オブジェクトとして使った場合)<bpt i='10' x='10'>&lt;c10&gt;</bpt>KeySet<ept i='10'>&lt;/c10&gt;</ept>はそのキーの<bpt i='11' x='11'>&lt;c11&gt;</bpt>Set<ept i='11'>&lt;/c11&gt;</ept>として振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Since the only possible value of a <bpt i='12' x='12'>&lt;c12&gt;</bpt>KeySet<ept i='12'>&lt;/c12&gt;</ept> is the <bpt i='13' x='13'>&lt;c13&gt;</bpt>True<ept i='13'>&lt;/c13&gt;</ept> value, it need not be represented in the actual implementation with any bits at all.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='12' x='12'>&lt;c12&gt;</bpt>KeySet<ept i='12'>&lt;/c12&gt;</ept>の可能な値が<bpt i='13' x='13'>&lt;c13&gt;</bpt>True<ept i='13'>&lt;/c13&gt;</ept>値だけなので、少しのことでも実際の実装では表現する必要はありません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyBag<ept i='0'>&lt;/c0&gt;</ept> is a <bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept> of <bpt i='2' x='2'>&lt;c2&gt;</bpt>UInt<ept i='2'>&lt;/c2&gt;</ept> with default of 0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyBag<ept i='0'>&lt;/c0&gt;</ept>は0をデフォルトにした<bpt i='2' x='2'>&lt;c2&gt;</bpt>UInt<ept i='2'>&lt;/c2&gt;</ept>の<bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use the <bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept> interface and increment an element of a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyBag<ept i='4'>&lt;/c4&gt;</ept> its value is increased by one (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが<bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept>インターフェースを使い、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyBag<ept i='4'>&lt;/c4&gt;</ept>の要素をインクリメントするとその値が1増加します(存在しない要素は作成されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you decrement the element the value is decreased by one; if the value goes to 0 the element is automatically deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素をデクリメントすると値が1減少します。値が0になると要素が自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An attempt to decrement a non-existing value results in a <bpt i='5' x='5'>&lt;c5&gt;</bpt>Failure<ept i='5'>&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在しない値をデクリメントしようとすると<bpt i='5' x='5'>&lt;c5&gt;</bpt>Failure<ept i='5'>&lt;/c5&gt;</ept>値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When not used as a <bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept> (that is, when used as an <bpt i='7' x='7'>&lt;c7&gt;</bpt>Array<ept i='7'>&lt;/c7&gt;</ept> or list or <bpt i='8' x='8'>&lt;c8&gt;</bpt>Bag<ept i='8'>&lt;/c8&gt;</ept> object) a <bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyBag<ept i='9'>&lt;/c9&gt;</ept> behaves as a <bpt i='10' x='10'>&lt;c10&gt;</bpt>Bag<ept i='10'>&lt;/c10&gt;</ept> of its keys, with each key replicated the number of times specified by its corresponding value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept>として使われない場合(つまり<bpt i='7' x='7'>&lt;c7&gt;</bpt>Array<ept i='7'>&lt;/c7&gt;</ept>かリスト化<bpt i='8' x='8'>&lt;c8&gt;</bpt>Bag<ept i='8'>&lt;/c8&gt;</ept>オブジェクトとして使われた場合)、<bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyBag<ept i='9'>&lt;/c9&gt;</ept>はそのキーの<bpt i='10' x='10'>&lt;c10&gt;</bpt>Bag<ept i='10'>&lt;/c10&gt;</ept>として振る舞い、それぞれのキーは対応する値によって指定された回数複製されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Use <bpt i='11' x='11'>&lt;c11&gt;</bpt>.kv<ept i='11'>&lt;/c11&gt;</ept> or <bpt i='12' x='12'>&lt;c12&gt;</bpt>.pairs<ept i='12'>&lt;/c12&gt;</ept> to suppress this behavior in list context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(リストコンテキストでこの振る舞いを抑制するには<bpt i='11' x='11'>&lt;c11&gt;</bpt>.kv<ept i='11'>&lt;/c11&gt;</ept> か<bpt i='12' x='12'>&lt;c12&gt;</bpt>.pairs<ept i='12'>&lt;/c12&gt;</ept>を使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with <bpt i='0' x='0'>&lt;c0&gt;</bpt>Hash<ept i='0'>&lt;/c0&gt;</ept> types, <bpt i='1' x='1'>&lt;c1&gt;</bpt>Pair<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>Mapping<ept i='2'>&lt;/c2&gt;</ept> are mutable in their values but not in their keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Hash<ept i='0'>&lt;/c0&gt;</ept>型のように<bpt i='1' x='1'>&lt;c1&gt;</bpt>Pair<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>Mapping<ept i='2'>&lt;/c2&gt;</ept>はそれらの値を変更できますがキーはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A key can be a reference to a mutable object, but cannot change its <bpt i='3' x='3'>&lt;c3&gt;</bpt>.WHICH<ept i='3'>&lt;/c3&gt;</ept> identity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(キーは変更可能なオブジェクトへの参照になれますが、<bpt i='3' x='3'>&lt;c3&gt;</bpt>.WHICH<ept i='3'>&lt;/c3&gt;</ept>の固有性は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、ハッシュの要素と同様に値は異なるオブジェクトに再バインドされるでしょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的な型はオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl variables have two associated types: their &quot;value type&quot; and their &quot;implementation type&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlの変数は2つの関連する型を持ちます: それらの&quot;値型&quot;と&quot;実装型&quot;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property, while the implementation type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(より一般的には、どの種類のコンテナもサブルーチンとモジュールを含む実装型を持ちます。)値型はその<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティとして格納され、コンテナの実装型は単にコンテナ自身のオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The word <bpt i='1' x='1'>&lt;c1&gt;</bpt>returns<ept i='1'>&lt;/c1&gt;</ept> is allowed as an alias for <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単語<bpt i='1' x='1'>&lt;c1&gt;</bpt>returns<ept i='1'>&lt;/c1&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>の別名として許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型はどの種類の値が変数に格納されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value type is given as a prefix or with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型は前置か<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>キーワードで与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case this sets the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property of the container to <bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらの場合でもコンテナの<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティを<bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subroutines have a variant of the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property, <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>, that sets the <bpt i='2' x='2'>&lt;c2&gt;</bpt>as<ept i='2'>&lt;/c2&gt;</ept> property instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンは<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティの変化形<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>を持ち、代わりに<bpt i='2' x='2'>&lt;c2&gt;</bpt>as<ept i='2'>&lt;/c2&gt;</ept>プロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to <bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept> or by implicit fall-off-the-end return).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>プロパティは返値に強制される制約(もしかしたら抑制) を指定します(<bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept>によって明示的に呼ばれるか最後の暗黙の返値のいずれかによって)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This constraint, unlike the <bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept> property, is not advertised as the type of the routine.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept>プロパティのようでないこの制約はルーチンの型としては表に出ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of it as the implicit type signature of the (possibly implicit) return statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは(もしかしたら暗黙の)return文の暗黙の型シグネチャと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's therefore available for type inferencing within the routine but not outside it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従ってルーチン内で型推論が利用できますが外側ではできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no <bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept> type is declared, it is assumed to be the same as the <bpt i='7' x='7'>&lt;c7&gt;</bpt>of<ept i='7'>&lt;/c7&gt;</ept> type, if declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept>型が宣言されていない場合、<bpt i='7' x='7'>&lt;c7&gt;</bpt>of<ept i='7'>&lt;/c7&gt;</ept>型が宣言されている場合と同じと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列かハッシュでの値型はそれぞれの格納された要素の型を指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュのキーの型はshape traitで指定されます―S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implementation type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実装型は変数自身がどの様に実装されているかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは変数のtraitとして与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実装型を定義することはPerl 6ではPerl 5の変数のtieに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time <bpt i='0' x='0'>&lt;c0&gt;</bpt>tie<ept i='0'>&lt;/c0&gt;</ept> statement unless the variable is explicitly declared with an implementation type that does the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしPerl 6の変数は宣言時に直接tieされ、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> roleを行う実装型で明示的に宣言された変数でなければパフォーマンス上の理由で実行時に<bpt i='0' x='0'>&lt;c0&gt;</bpt>tie<ept i='0'>&lt;/c0&gt;</ept>文でtieされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, package variables are always considered <bpt i='0' x='0'>&lt;c0&gt;</bpt>Tieable<ept i='0'>&lt;/c0&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながらパッケージ変数は常にデフォルトで<bpt i='0' x='0'>&lt;c0&gt;</bpt>Tieable<ept i='0'>&lt;/c0&gt;</ept>とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a consequence, all named packages are also <bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、全ての名前付きパッケージもデフォルトで<bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスとモジュールはtieされたパッケージとは異なると見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Package<ept i='2'>&lt;/c2&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の方向から見れば、グローバルパッケージにバインドされることを希望するクラスとモジュールは<bpt i='2' x='2'>&lt;c2&gt;</bpt>Package<ept i='2'>&lt;/c2&gt;</ept> roleが可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どの型の値がそれぞれの要素に格納されているか指定するため、非スカラー型は修飾されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each successive <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> makes the type on its right a parameter of the type on its left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの連続する<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>はその右のパラメータの型を、その左の型にさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ付きの型は角括弧を使って名前を付けられます。だから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は実際には以下のような意味になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑な型が指定された場合は実際の変数を理解するのが大変なので、同様の後置形式があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> form may be used in subroutines:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンでは<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>形式が使われるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに返値の型はシグネチャ内で指定されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is a slight difference, insofar as the type inferencer will ignore a <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> but pay attention to <bpt i='1' x='1'>&lt;c1&gt;</bpt>--&gt;<ept i='1'>&lt;/c1&gt;</ept> or prefix type declarations, also known as the <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の推測者が<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>を無視する限りにおいて、そこには微妙な違いがあります。しかし<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型としても知られる<bpt i='1' x='1'>&lt;c1&gt;</bpt>--&gt;<ept i='1'>&lt;/c1&gt;</ept>または後置の型宣言に注意を払って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only the inside of the subroutine pays attention to <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>, and essentially coerces the return value to the indicated type, just as if you'd coerced each return expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンの内側だけが<bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>に注意を払っており、本質的に返値はそれぞれのreturn式を強制したかのように指定された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may also specify the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> type as the <bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> trait (with <bpt i='2' x='2'>&lt;c2&gt;</bpt>returns<ept i='2'>&lt;/c2&gt;</ept> allowed as a synonym):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>型を<bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> trait(<bpt i='2' x='2'>&lt;c2&gt;</bpt>returns<ept i='2'>&lt;/c2&gt;</ept>が同義語として許可される)として指定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &quot;or&quot; junction:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>&quot;or&quot;かjunctionであるかのように、単一の型をセットで使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fancier type constraints may be expressed through a subtype:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手の込んだ型制約はsubtypeを通して表現されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &quot;anded&quot; together (the variable itself supplies type constraints, and <bpt i='0' x='0'>&lt;c0&gt;</bpt>where<ept i='0'>&lt;/c0&gt;</ept> clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &quot;and&quot; junction:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータの項は暗黙に一緒に&quot;anded&quot;された制約のセットと見ることができるので(変数自身は型制約を供給し、<bpt i='0' x='0'>&lt;c0&gt;</bpt>where<ept i='0'>&lt;/c0&gt;</ept>条項かツリーマッチングはさらに制約を加えるだけです)、我々は&quot;and&quot; junctionのように型の並びを許可するためにこれを緩和します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータは他のどの様な変数と同じように型を与えられるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言の中で、クラス変数(それ自身か既存の型名の後のどちらか)は新しい型名を宣言し、実際のパラメータの型と関連づけられているパラメータ付きの値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It declares the new type name in the same scope as the associated declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは関連付けられた宣言として同じスコープ内で新しい型名を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい型名は直ちに取り込まれ、同じシグネチャ内の2つのそのような型は同じ名前の場合は互換性を統一する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a scoped subroutine, a return type can be specified before or after the name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スコープ付きサブルーチンでは、返値の型は名前の前か後で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We call all return types &quot;return types&quot;, but distinguish two kinds of return types, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> type and the <bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> type, because the <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type is normally an &quot;official&quot; named type and declares the official interface to the routine, while the <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> type is merely a constraint on what may be returned by the routine from the routine's point of view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>我々は返値の型を&quot;return types&quot;と呼びますが、<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>型と<bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept>型の2種類の返値の型は区別します。なぜなら<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型は通常は&quot;official&quot;な名前を付けられた型名で、ルーチンに対するオフィシャルなインターフェースを宣言します。<bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>は単にルーチン視点でルーチンによって何が返されるかの制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it's scoped with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>our<ept i='0'>&lt;/c0&gt;</ept> scope modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしサブルーチンが明示的にスコープ化されていないなら、それは<bpt i='0' x='0'>&lt;c0&gt;</bpt>our<ept i='0'>&lt;/c0&gt;</ept>スコープ修飾子でスコープ化されるかのように現在の名前空間(モジュール、クラス、grammarまたはパッケージ)に属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any return type must go after the name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返値の型はどれでも名前の後に移動する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On an anonymous subroutine, any return type can only go after the <bpt i='0' x='0'>&lt;c0&gt;</bpt>sub<ept i='0'>&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無名サブルーチンでは、どの返値の型も<bpt i='0' x='0'>&lt;c0&gt;</bpt>sub<ept i='0'>&lt;/c0&gt;</ept>キーワードの後にしか移動できません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>but you can use a scope modifier to introduce an <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> prefix type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>後置型を導入するためにスコープ修飾子を使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because they are anonymous, you can change the <bpt i='0' x='0'>&lt;c0&gt;</bpt>my<ept i='0'>&lt;/c0&gt;</ept> modifier to <bpt i='1' x='1'>&lt;c1&gt;</bpt>our<ept i='1'>&lt;/c1&gt;</ept> without affecting the meaning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは無名なので、<bpt i='0' x='0'>&lt;c0&gt;</bpt>my<ept i='0'>&lt;/c0&gt;</ept>修飾子は意味に影響を与えずに <bpt i='1' x='1'>&lt;c1&gt;</bpt>our<ept i='1'>&lt;/c1&gt;</ept>に変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type may also be specified after a <bpt i='0' x='0'>&lt;c0&gt;</bpt>--&gt;<ept i='0'>&lt;/c0&gt;</ept> token within the signature.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返値の型はシグネチャの中で<bpt i='0' x='0'>&lt;c0&gt;</bpt>--&gt;<ept i='0'>&lt;/c0&gt;</ept>トークンの後で指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This doesn't mean exactly the same thing as <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>と正確に同じ意味があるものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type is the &quot;official&quot; return type, and may therefore be used to do type inferencing outside the sub.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型は&quot;official&quot;な返値の型で、サブルーチンの外側で型推論を行うために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> type only makes the return type available to the internals of the sub so that the <bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept> statement can know its context, but outside the sub we don't know anything about the return value, as if no return type had been declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>型はサブルーチンの内部で利用できる返値の型を作るだけで、<bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept>文がそのコンテキストを知ることができますが、サブルーチンの外側では返値の型が宣言されていないかのように返値の型に関して何も知ることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The prefix form specifies the <bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept> type rather than the <bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept> type, so the return type of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置形式は<bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept>型よりも<bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept>型を指定するので、返値の型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is known to return an object of type Fish, as if you'd said:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>はあなたが次のようにしたかのようにFish型のオブジェクトを返すと知ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>not<ept i='0'>&lt;/i0&gt;</ept> as if you'd said</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のようにではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is possible for the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> type to disagree with the <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>型と<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>型を区別することが可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または同じに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 includes a system of <bpt i='0' x='0'>&lt;s0&gt;</bpt>sigils<ept i='0'>&lt;/s0&gt;</ept> to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は変数の基本的な構造をマークするための<bpt i='0' x='0'>&lt;s0&gt;</bpt>sigils<ept i='0'>&lt;/s0&gt;</ept>システムを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a declaration, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;<ept i='0'>&lt;/c0&gt;</ept> sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言内で<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;<ept i='0'>&lt;/c0&gt;</ept> sigilはスコープ宣言内のsigil無しにサブルーチン名の可視性も宣言します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a signature or other declaration, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept> sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャか他の宣言内で、識別子が続く<bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept> sigilはpackage/type名の可視性をスコープ宣言のsigil無しに宣言する型変数をマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初はそのようなスコープ付きの宣言はバインドされない型とみなされ、その関連付けられた引数の実際の型を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く同じスコープの宣言内のsigilは任意なので、裸の型名も宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>内側をネストする宣言は同じ型を参照したい場合はsigilを使うことは出来ません。内側の宣言は型を再バインドするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(pointy blockのシグネチャは外側のブロックではなく内側のブロックとして数えられルので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsはバインドされたオブジェクトの正確な型ではなく、全体的なインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なるsigilsはわずかな異なる能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept> may be bound to any object, including any object that can be bound to any other sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept> は，どんなオブジェクトにでも束縛されることが許されています。それにはそれ以外の sigil に束縛されたものをも含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなスカラー変数はオブジェクトが本質的に複合型か単一型かどうかに関わらず常にどのようなリストコンテキストでも単数形アイテムとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの種類のデリファレンスコンテキストに置かれなければ、その内容は自動的にデリファレンスされないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, when interpolating into list context, <bpt i='1' x='1'>&lt;c1&gt;</bpt>$x<ept i='1'>&lt;/c1&gt;</ept> never expands its object to anything other than the object itself as a single item, even if the object is a container object containing multiple items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、リストコンテキストに差し込まれている場合、<bpt i='1' x='1'>&lt;c1&gt;</bpt>$x<ept i='1'>&lt;/c1&gt;</ept> は単一のアイテムとしてオブジェクト自身以外の何か他のものとしてそのオブジェクトを展開しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>@x<ept i='0'>&lt;/c0&gt;</ept> may be bound to an object of the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept> class, but it may also be bound to any object that does the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Positional<ept i='2'>&lt;/c2&gt;</ept> role, such as a <bpt i='3' x='3'>&lt;c3&gt;</bpt>List<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>Seq<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>Range<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept>, or <bpt i='7' x='7'>&lt;c7&gt;</bpt>Capture<ept i='7'>&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>@x<ept i='0'>&lt;/c0&gt;</ept>は、単体の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept> クラスのオブジェクトに束縛されることが許されていますし、<bpt i='3' x='3'>&lt;c3&gt;</bpt>List<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>Seq<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>Range<ept i='5'>&lt;/c5&gt;</ept>、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>Capture<ept i='7'>&lt;/c7&gt;</ept>のような<bpt i='2' x='2'>&lt;c2&gt;</bpt>Positional<ept i='2'>&lt;/c2&gt;</ept> role を負う全てのオブジェクトに束縛されることも許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='8' x='8'>&lt;c8&gt;</bpt>Positional<ept i='8'>&lt;/c8&gt;</ept> role implies the ability to support <bpt i='9' x='9'>&lt;c9&gt;</bpt>postcircumfix:&lt;[ ]&gt;<ept i='9'>&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='8' x='8'>&lt;c8&gt;</bpt>Positional<ept i='8'>&lt;/c8&gt;</ept> role は、<bpt i='9' x='9'>&lt;c9&gt;</bpt>postcircumfix:&lt;[ ]&gt;<ept i='9'>&lt;/c9&gt;</ept>をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, <bpt i='0' x='0'>&lt;c0&gt;</bpt>%x<ept i='0'>&lt;/c0&gt;</ept> may be bound to any object that does the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Associative<ept i='1'>&lt;/c1&gt;</ept> role, such as <bpt i='2' x='2'>&lt;c2&gt;</bpt>Pair<ept i='2'>&lt;/c2&gt;</ept>, <bpt i='3' x='3'>&lt;c3&gt;</bpt>Mapping<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>Set<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>Bag<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept>, or <bpt i='7' x='7'>&lt;c7&gt;</bpt>Capture<ept i='7'>&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に<bpt i='0' x='0'>&lt;c0&gt;</bpt>%x<ept i='0'>&lt;/c0&gt;</ept> は，<bpt i='2' x='2'>&lt;c2&gt;</bpt>Pair<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Mapping<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>Set<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>Bag<ept i='5'>&lt;/c5&gt;</ept>、<bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>Capture<ept i='7'>&lt;/c7&gt;</ept>のような<bpt i='1' x='1'>&lt;c1&gt;</bpt>Associative<ept i='1'>&lt;/c1&gt;</ept> role を負う全てのオブジェクトに束縛されることが許されています．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='8' x='8'>&lt;c8&gt;</bpt>Associative<ept i='8'>&lt;/c8&gt;</ept> role implies the ability to support <bpt i='9' x='9'>&lt;c9&gt;</bpt>postcircumfix:&lt;{ }&gt;<ept i='9'>&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='8' x='8'>&lt;c8&gt;</bpt>Associative<ept i='8'>&lt;/c8&gt;</ept> role は、<bpt i='9' x='9'>&lt;c9&gt;</bpt>postcircumfix:&lt;{ }&gt;<ept i='9'>&lt;/c9&gt;</ept>をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;x<ept i='0'>&lt;/c0&gt;</ept> may be bound to any object that does the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Callable<ept i='1'>&lt;/c1&gt;</ept> role, such as any <bpt i='2' x='2'>&lt;c2&gt;</bpt>Block<ept i='2'>&lt;/c2&gt;</ept> or <bpt i='3' x='3'>&lt;c3&gt;</bpt>Routine<ept i='3'>&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;x<ept i='0'>&lt;/c0&gt;</ept>は、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Block<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Routine<ept i='3'>&lt;/c3&gt;</ept>のような<bpt i='1' x='1'>&lt;c1&gt;</bpt>Callable<ept i='1'>&lt;/c1&gt;</ept> role を負う全てのオブジェクトに束縛されることを許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='4' x='4'>&lt;c4&gt;</bpt>Callable<ept i='4'>&lt;/c4&gt;</ept> role implies the ability to support <bpt i='5' x='5'>&lt;c5&gt;</bpt>postcircumfix:&lt;( )&gt;<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='4' x='4'>&lt;c4&gt;</bpt>Callable<ept i='4'>&lt;/c4&gt;</ept> role は、<bpt i='5' x='5'>&lt;c5&gt;</bpt>postcircumfix:&lt;( )&gt;<ept i='5'>&lt;/c5&gt;</ept>をサポートする能力のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>::x<ept i='0'>&lt;/c0&gt;</ept> may be bound to any object that does the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Abstraction<ept i='1'>&lt;/c1&gt;</ept> role, such as a package, module, class, role, grammar, or any other type object, or any immutable value object that can be used as a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>::x<ept i='0'>&lt;/c0&gt;</ept> は、package、module、class、role、grammar、それ以外の全ての型オブジェクトや型として使われるimmutable な値オブジェクトのような<bpt i='1' x='1'>&lt;c1&gt;</bpt>Abstraction<ept i='1'>&lt;/c1&gt;</ept> role を負う全てのオブジェクトに束縛されることを許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i='2' x='2'>&lt;c2&gt;</bpt>Abstraction<ept i='2'>&lt;/c2&gt;</ept> role implies the ability to do various symbol table and/or typological manipulations which may or may not be supported by any given abstraction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>Abstraction<ept i='2'>&lt;/c2&gt;</ept> role は、抽象化によりサポートすることを許可されたり，そうでないような様々なシンボルテーブルや型論理を操作する能力を意味します．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mostly though it just means that you want to give some abstraction an official name that you can then use later in the compilation without any sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはコンパイル中になんらかのsigil無しに抽象化に後で使えるように公式な名前を与えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのような場合でも、sigilによって意味づけされた最小のコンテナroleは最新のバインディング時にチェックされ、文法エラーがすぐに検出できるなら（コンパイル時のような）早期に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to bind an object that doesn't yet do the appropriate role, you must either stick with the generic <bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept> sigil, or mix in the appropriate role before binding to a more specific sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適切なroleを負わないオブジェクトを束縛したい場合、一般的な<bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept> sigilにこだわるか、より特定されたsigilと束縛する前に適切なroleをミックスインしてやらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object is allowed to support both <bpt i='0' x='0'>&lt;c0&gt;</bpt>Positional<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>Associative<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Positional<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>Associative<ept i='1'>&lt;/c1&gt;</ept>をサポートするオブジェクトも許されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object that does not support <bpt i='2' x='2'>&lt;c2&gt;</bpt>Positional<ept i='2'>&lt;/c2&gt;</ept> may not be bound directly to <bpt i='3' x='3'>&lt;c3&gt;</bpt>@x<ept i='3'>&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>Positional<ept i='2'>&lt;/c2&gt;</ept>をサポートしないオブジェクトを<bpt i='3' x='3'>&lt;c3&gt;</bpt>@x<ept i='3'>&lt;/c3&gt;</ept>に直接束縛することは許されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, any construct such as <bpt i='4' x='4'>&lt;c4&gt;</bpt>%x<ept i='4'>&lt;/c4&gt;</ept> that can interpolate the contents of such an object into list context can automatically construct a list value that may then be bound to an array variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただし、リストコンテキスト内でのオブジェクトの内容を挿入するような<bpt i='4' x='4'>&lt;c4&gt;</bpt>%x<ept i='4'>&lt;/c4&gt;</ept>の構築は、1つの配列変数に束縛されているリスト値を自動的に構築する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなリストの添字は元のオブジェクトの添字を意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と違い、もはやsigilとそれに続く名前または構造の間に空白を置けないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通のsigilsは通常のスコープ変数、レキシカルかパッケージスコープを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Oddly scoped variables include a secondary sigil (a <bpt i='0' x='0'>&lt;s0&gt;</bpt>twigil<ept i='0'>&lt;/s0&gt;</ept>) that indicates what kind of strange scoping the variable is subject to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変なスコープ変数は変数がどの種類の奇妙なスコープに従属するかを示す2つ目のsigil(<bpt i='0' x='0'>&lt;s0&gt;</bpt>twigil<ept i='0'>&lt;/s0&gt;</ept>)を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &quot;my&quot; or &quot;our&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどのtwigils変数は暗黙に他のスコープに宣言されるか宣言されていると見なされ、&quot;my&quot;か&quot;our&quot;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attribute variables are declared with <bpt i='0' x='0'>&lt;c0&gt;</bpt>has<ept i='0'>&lt;/c0&gt;</ept>, though.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性変数は<bpt i='0' x='0'>&lt;c0&gt;</bpt>has<ept i='0'>&lt;/c0&gt;</ept>で宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsは今は変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept> always means a scalar variable, <bpt i='1' x='1'>&lt;c1&gt;</bpt>@<ept i='1'>&lt;/c1&gt;</ept> an array variable, and <bpt i='2' x='2'>&lt;c2&gt;</bpt>%<ept i='2'>&lt;/c2&gt;</ept> a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept>は常にスカラー変数を意味し、添字がある場合でも<bpt i='1' x='1'>&lt;c1&gt;</bpt>@<ept i='1'>&lt;/c1&gt;</ept>は配列、<bpt i='2' x='2'>&lt;c2&gt;</bpt>%<ept i='2'>&lt;/c2&gt;</ept>はハッシュ変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In item context, variables such as <bpt i='3' x='3'>&lt;c3&gt;</bpt>@array<ept i='3'>&lt;/c3&gt;</ept> and <bpt i='4' x='4'>&lt;c4&gt;</bpt>%hash<ept i='4'>&lt;/c4&gt;</ept> simply return themselves as <bpt i='5' x='5'>&lt;c5&gt;</bpt>Array<ept i='5'>&lt;/c5&gt;</ept> and <bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept> objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アイテムコンテキストでは<bpt i='3' x='3'>&lt;c3&gt;</bpt>@array<ept i='3'>&lt;/c3&gt;</ept>や<bpt i='4' x='4'>&lt;c4&gt;</bpt>%hash<ept i='4'>&lt;/c4&gt;</ept>のような変数は単純にそれら自身を<bpt i='5' x='5'>&lt;c5&gt;</bpt>Array<ept i='5'>&lt;/c5&gt;</ept>や<bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept>オブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Item context was formerly known as scalar context, but we now reserve the &quot;scalar&quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(アイテムコンテキストは以前はスカラーコンテキストとして知られていましたが、われわれは&quot;scalar&quot;の概念をコンテキスト（リストコンテキストからの配列の解除）よりも変数のことに関しての話と予約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列コンテキストではコンテナオブジェクトは自動的に適切な文字列値に文字列化(空白で区切られた)されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールコンテキストでは、コンテナに要素がある場合だけtrue値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a Perlish representation of any object, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.perl<ept i='0'>&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのPerlっぽい表現を得るには<bpt i='0' x='0'>&lt;c0&gt;</bpt>.perl<ept i='0'>&lt;/c0&gt;</ept>メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Data::Dumper<ept i='1'>&lt;/c1&gt;</ept> module in Perl 5, the <bpt i='2' x='2'>&lt;c2&gt;</bpt>.perl<ept i='2'>&lt;/c2&gt;</ept> method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Data::Dumper<ept i='1'>&lt;/c1&gt;</ept>モジュールのように、<bpt i='2' x='2'>&lt;c2&gt;</bpt>.perl<ept i='2'>&lt;/c2&gt;</ept>メソッドは文字列にクォートを置き、リスト値に角括弧を置き、ハッシュ値にカーリーを置きます。なのでPerlは結果を評価して同じオブジェクトに戻せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>.perl<ept i='3'>&lt;/c3&gt;</ept> method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>.perl<ept i='3'>&lt;/c3&gt;</ept>メソッドはオブジェクトの想定の表現を返し、もしコードが同じ点で再解析されたら、アイテムコンテキストでオブジェクトをスカラーとして再出力するのに使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use <bpt i='4' x='4'>&lt;c4&gt;</bpt>&lt;prefix:&lt;|<ept i='4'>&lt;/c4&gt;</ept> &gt;&gt; to force interpolation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし再解析されたオブジェクトをリストコンテキストに挿入したいなら、<bpt i='4' x='4'>&lt;c4&gt;</bpt>&lt;prefix:&lt;|<ept i='4'>&lt;/c4&gt;</ept> &gt;&gt;を強制挿入のために使う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d')<ept i='0'>&lt;/c0&gt;</ept> method to do an implicit <bpt i='1' x='1'>&lt;c1&gt;</bpt>sprintf<ept i='1'>&lt;/c1&gt;</ept> on the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スカラー値のフォーマットされた表現を得るには、値に暗黙の<bpt i='1' x='1'>&lt;c1&gt;</bpt>sprintf<ept i='1'>&lt;/c1&gt;</ept>を行う<bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d')<ept i='0'>&lt;/c0&gt;</ept>メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: <bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d', ', ')<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の値をコンマで区切ってフォーマットするには<bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d', ', ')<ept i='0'>&lt;/c0&gt;</ept>のように第二引数を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: <bpt i='1' x='1'>&lt;c1&gt;</bpt>.fmt('%s: %s', &quot;\n&quot;)<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ値やペアのリストをフォーマットするには<bpt i='1' x='1'>&lt;c1&gt;</bpt>.fmt('%s: %s', &quot;\n&quot;)<ept i='1'>&lt;/c1&gt;</ept>のように最初の文字列にキィとバリューの両方に対してのフォーマットを含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は一貫して左にあるどんなものにでも作られたコンテナをデリファレンスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数名と添字の間の空白は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、構造を視覚的に引き延ばす2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since a subscript is a kind of postfix operator, there is a corresponding <bpt i='0' x='0'>&lt;s0&gt;</bpt>dot<ept i='0'>&lt;/s0&gt;</ept> form of each subscript (<bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.[1]<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>%bar.{'a'}<ept i='2'>&lt;/c2&gt;</ept>) that makes the dereference a little more explicit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は後置演算子の一種なので、それぞれの添字に対応する<bpt i='0' x='0'>&lt;s0&gt;</bpt>dot<ept i='0'>&lt;/s0&gt;</ept>形式があります(<bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.[1]<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>%bar.{'a'}<ept i='2'>&lt;/c2&gt;</ept>)。それはデリファレンスをより少し明示的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant string subscripts may be placed in angles, so <bpt i='3' x='3'>&lt;c3&gt;</bpt>%bar.{'a'}<ept i='3'>&lt;/c3&gt;</ept> may also be written as <bpt i='4' x='4'>&lt;c4&gt;</bpt>%bar&lt;a&gt;<ept i='4'>&lt;/c4&gt;</ept> or <bpt i='5' x='5'>&lt;c5&gt;</bpt>%bar.&lt;a&gt;<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字が定数文字列の場合は、山括弧内に置くこともできます。つまり<bpt i='3' x='3'>&lt;c3&gt;</bpt>%bar.{'a'}<ept i='3'>&lt;/c3&gt;</ept>は<bpt i='4' x='4'>&lt;c4&gt;</bpt>%bar&lt;a&gt;<ept i='4'>&lt;/c4&gt;</ept>か<bpt i='5' x='5'>&lt;c5&gt;</bpt>%bar.&lt;a&gt;<ept i='5'>&lt;/c5&gt;</ept>とも書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、unspaceを使って追加の空白を挿入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライシングは添字の性質で指定され、sigilによってではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The context in which a subscript is evaluated is no longer controlled by the sigil either.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字が評価されているコンテキストは、もはやsigilによって制御されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(More specifically, they are evaluated in a variant of list context known as <bpt i='0' x='0'>&lt;i0&gt;</bpt>slice<ept i='0'>&lt;/i0&gt;</ept> context, which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(より正確には、それらは<bpt i='0' x='0'>&lt;i0&gt;</bpt>slice<ept i='0'>&lt;/i0&gt;</ept>コンテキストというリストコンテキストの変化形で評価され、それは次元的情報を保存し、あなたはmulti-dimensionalスライスをセミコロンを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a slice context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、それぞれの次元のスライスは普通のリストコンテキストなので添字の一部で呼ばれた関数はsliceコンテキストを認識しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし内部のコンテキストをアイテム(スカラー)コンテキストに強制したいなら+を数値コンテキスト、~を文字列コンテキストに指定するなどの便利な単一文字のspecifiersがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils used either as functions or as list prefix operators also force context, so these also work:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsを関数として、またはリストの前置演算子として使うかどちらかによってもコンテキストを強制できます。なのでこれらはこのようにも動きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしこれらは同じではないので注意して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストバインディングからリストの割り当てを識別する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストの割り当てはPerl 5のように、値をコピーして動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's a new <bpt i='0' x='0'>&lt;c0&gt;</bpt>:=<ept i='0'>&lt;/c0&gt;</ept> binding operator that lets you bind names to <bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept> objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i='0' x='0'>&lt;c0&gt;</bpt>:=<ept i='0'>&lt;/c0&gt;</ept>バインディング演算子があり、それはコピー無しに<bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept>オブジェクトを名前にバインディングし、サブルーチンの引数の同じ方法ではパラメータに正式にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バインディングについて詳しくはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An argument list may be captured into an object with backslashed parens:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数リストはバックスラッシュ括弧でオブジェクトに取り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values in a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept> object are parsed as ordinary expressions, then marked as positional or named.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept>オブジェクト内の値は普通の式としてパースされ、順番か名前でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように解決されるかは最終的に何にバインドされるかに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他がそうでない場合に、いくつかのバインディングは複数の次元に敏感です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When cast into an array, you can access all the positional arguments; into a hash, all named arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列にキャストすると全てのポジショナル引数にアクセスできます。ハッシュなら全ての名前付き引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての前置sigil演算子は一つのポジショナル引数を許容します。それは右辺値としてアイテムコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらはもし括弧で呼ばれたら文字列に差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of them as &quot;fat&quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは&quot;fat&quot;リファレンスと考えることができます。それは現在のシングルオブジェクトのアイデンティティだけでなく、関連するいくつかのオブジェクトを取り込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signature object (<bpt i='0' x='0'>&lt;c0&gt;</bpt>Signature<ept i='0'>&lt;/c0&gt;</ept>) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャオブジェクト(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Signature<ept i='0'>&lt;/c0&gt;</ept>)はコロン前置の括弧で作成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャ中の式は普通の式ではなくパラメータ宣言として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータの文法の詳細についてはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型変数にバインドされたシグネチャオブジェクト(上記の例のように)は追加の型制約を適用するために他のシグネチャと共に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, the notation <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept> merely stands for the <bpt i='1' x='1'>&lt;c1&gt;</bpt>foo<ept i='1'>&lt;/c1&gt;</ept> function as a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Routine<ept i='2'>&lt;/c2&gt;</ept> object without calling it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と異なり、<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept>という表記は単に関数<bpt i='1' x='1'>&lt;c1&gt;</bpt>foo<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>Routine<ept i='2'>&lt;/c2&gt;</ept>オブジェクトとして呼び出さないで取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧でデリファレンスしてCodeオブジェクトを呼べるでしょう(もちろん引数を含めて):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧の前に空白は許されません。なぜなら括弧は後置として解析されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with any postfix, there is also a corresponding <bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept> operator, and you may use the &quot;unspace&quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのpostfixとも同じように、対応する<bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept>演算子があり、オプショナルな空白やコメントを挿入するために間にバックスラッシュで&quot;unspace&quot;を使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note however that the parentheses around arguments in the &quot;normal&quot; named forms of function and method calls are not postfix operators, so do not allow the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept> form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通の形式の名前に付けられた括弧は関数かメソッド呼び出しですが後置演算子ではありません。そのため<bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept>形式は許されません。なぜならドットは実際にはデリファレンス演算子を示すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you <bpt i='0' x='0'>&lt;i0&gt;</bpt>do<ept i='0'>&lt;/i0&gt;</ept> use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの特別な場合にドット形式を使う場合は、引数無しに名前付き形式を呼ぶか、結果をデリファレンスしたいということを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With multiple dispatch, <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept> may actually be the name of a set of candidate functions (which you can use as if it were an ordinary function).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マルチディスパッチにおいては<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept>は実際には候補関数のセットの名前になります(それは普通の関数であるかのように使うことが出来ます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in that case <bpt i='1' x='1'>&lt;c1&gt;</bpt>&amp;foo<ept i='1'>&lt;/c1&gt;</ept> by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしこの場合は<bpt i='1' x='1'>&lt;c1&gt;</bpt>&amp;foo<ept i='1'>&lt;/c1&gt;</ept>自身は特定の関数の関数名となるには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定するために、型は後置演算子のシグネチャリテラルを使ってリファインされるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It still just returns the <bpt i='0' x='0'>&lt;c0&gt;</bpt>Routine<ept i='0'>&lt;/c0&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはまだ<bpt i='0' x='0'>&lt;c0&gt;</bpt>Routine<ept i='0'>&lt;/c0&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A call may also be partially applied by using the <bpt i='1' x='1'>&lt;c1&gt;</bpt>.assuming<ept i='1'>&lt;/c1&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>呼び出しは<bpt i='1' x='1'>&lt;c1&gt;</bpt>.assuming<ept i='1'>&lt;/c1&gt;</ept>を使うことによっても部分的に適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライシング文法はS09でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多次元スライスは個々のスライスサブリストの間のセミコロンで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each such slice sublist is evaluated lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのスライスサブリストは曖昧に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスの添字を値以外の何かを返すようにさせるには、添字に適切な副詞を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの副詞的形式は存在しないエントリーを取り去ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may also perform an existence test, which will return true if all the elements of the slice exist:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのスライスの要素が存在するならtrueを返すテストを実行することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>likewise,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>deletes the entries &quot;en passant&quot; while returning them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は値を返すついでに削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(もちろん単一のインデックスのスライスでもこれらの形式は動きます。)添字が最も前の演算子であるという事実のおかげでこれらが動くということに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(このようなスライス修飾子はめったには起こりません。なぜならそれらは普通はコンマの優先順位を操作するリストコンテキストで使用されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric context (i.e. when cast into <bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept> or <bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>), a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept> object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキスト(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>か<bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>にキャストされる場合)、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept>オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値コンテキストではなんらかのペアがハッシュにあればtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, any intrinsic iterator would be reset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらかの場合で、内在のイテレータはリセットされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペアのリストをソートするとデフォルトでキーでソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting a list of lists should sort on the first elements, then the second elements, etc.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストのリストをソートすると最初の要素でソートし、次に2番目の要素で、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on <bpt i='0' x='0'>&lt;c0&gt;</bpt>sort<ept i='0'>&lt;/c0&gt;</ept> see S29.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>sort<ept i='0'>&lt;/c0&gt;</ept>の詳細についてはS29を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5の特殊変数はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残りの特殊変数はレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes <bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>@_<ept i='1'>&lt;/c1&gt;</ept>, as well as the new <bpt i='2' x='2'>&lt;c2&gt;</bpt>$/<ept i='2'>&lt;/c2&gt;</ept>, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>@_<ept i='1'>&lt;/c1&gt;</ept>を含み、同様に新しい<bpt i='2' x='2'>&lt;c2&gt;</bpt>$/<ept i='2'>&lt;/c2&gt;</ept>は最後の正規表現マッチの返値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>$0<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>$1<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>$2<ept i='5'>&lt;/c5&gt;</ept>, etc., are aliases into the <bpt i='6' x='6'>&lt;c6&gt;</bpt>$/<ept i='6'>&lt;/c6&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>$0<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>$1<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>$2<ept i='5'>&lt;/c5&gt;</ept>などは<bpt i='6' x='6'>&lt;c6&gt;</bpt>$/<ept i='6'>&lt;/c6&gt;</ept>オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>$#foo<ept i='0'>&lt;/c0&gt;</ept> notation is dead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$#foo<ept i='0'>&lt;/c0&gt;</ept>表記法はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.end<ept i='1'>&lt;/c1&gt;</ept> or <bpt i='2' x='2'>&lt;c2&gt;</bpt>@foo[*-1]<ept i='2'>&lt;/c2&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.end<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>@foo[*-1]<ept i='2'>&lt;/c2&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Or <bpt i='3' x='3'>&lt;c3&gt;</bpt>@foo.shape[$dimension]<ept i='3'>&lt;/c3&gt;</ept> for multidimensional arrays.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(または<bpt i='3' x='3'>&lt;c3&gt;</bpt>@foo.shape[$dimension]<ept i='3'>&lt;/c3&gt;</ept>を多次元配列に使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i='0' x='0'>&lt;i0&gt;</bpt>identifier<ept i='0'>&lt;/i0&gt;</ept> is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>識別子<ept i='0'>&lt;/i0&gt;</ept>は英数字が続くアルファベットで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アルファベットと数字の定義は適切なユニコード文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アンダースコアは常にアルファベットと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子は次の文字がアルファベットの孤立したアポストロフィかハイフンを含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;i0&gt;</bpt>name<ept i='0'>&lt;/i0&gt;</ept> is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>名前<ept i='0'>&lt;/i0&gt;</ept>は変数名の適正な部分のことです(sigilは数えません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは以下を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When not used as a sigil, the semantic function of <bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept> within a name is to force the preceding portion of the name to be considered a package through which the subsequent portion of the name is to be located.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>sigilとして使わない場合、名前の範囲での<bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept>の意味関数は後の位置の名前を伴っていれば、前の位置にパッケージとみなされる名前を強制します．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon not followed by an identifier, or any kind of bracket or whitespace (including Unicode brackets and whitespace), it will be taken to be a sigil without a name rather than a punctuational variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl5と違って、sigilにコンマ、セミコロン、識別子が後に続かないコロン、括弧、空白(これにはUnicodeの括弧、空白を含む)が続く場合、お決まりの変数ではなく名前無しのsigilとみなされます．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows you to use sigils as coercion operators:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはsigilをcoercion演算子として使えるということです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In declarative contexts bare sigils may be used as placeholders for anonymous variables:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言コンテキストでは、裸のsigilは無名変数のプレイスホルダとして使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Outside of declarative contexts you may use <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> for a placeholder:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言コンテキストの外側では、プレイスホルダとして<bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempts to say something like:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>似たようなことを言おうとして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will result in the message, &quot;Anonymous variable requires declarator&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とすると&quot;Anonymous variable requires declarator&quot;というメッセージを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other all-caps names are semi-reserved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以外の全てが大文字の名前は準予約になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When &quot;strict&quot; is in effect (which is the default except for one-liners), non-qualified variables (such as <bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>@y<ept i='1'>&lt;/c1&gt;</ept>) are only looked up from lexical scopes, but never from package scopes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>&quot;strict&quot;が有効な場合(これはワンライナー以外ではデフォルトの動作です)では、資格を持たない変数(<bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept>や<bpt i='1' x='1'>&lt;c1&gt;</bpt>@y<ept i='1'>&lt;/c1&gt;</ept>のような)は、レキシカルスコープからのみ見付けられますが，パッケージスコープからは見付けられません．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To bind package variables into a lexical scope, simply say <bpt i='0' x='0'>&lt;c0&gt;</bpt>our ($x, @y)<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レキシカルスコープへパッケージスコープの変数を束縛するには、単に<bpt i='0' x='0'>&lt;c0&gt;</bpt>our ($x, @y)<ept i='0'>&lt;/c0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To bind global variables into a lexical scope, predeclare them with <bpt i='1' x='1'>&lt;c1&gt;</bpt>use<ept i='1'>&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバル変数をレキシカルスコープに束縛するには、<bpt i='1' x='1'>&lt;c1&gt;</bpt>use<ept i='1'>&lt;/c1&gt;</ept>でそれらをあらかじめ宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or just refer to them as <bpt i='0' x='0'>&lt;c0&gt;</bpt>$*IN<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>$*OUT<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>か，<bpt i='0' x='0'>&lt;c0&gt;</bpt>$*IN<ept i='0'>&lt;/c0&gt;</ept>や<bpt i='1' x='1'>&lt;c1&gt;</bpt>$*OUT<ept i='1'>&lt;/c1&gt;</ept>のように参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every block is a closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのブロックはクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This synopsis summarizes Apocalypse 10, which discusses packages despite never having been written.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この概要は、Apocalypse 10 をまとめたもので、これ以前に書かれなかったパッケージについて話しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As in Perl 5, packages are the basis of modules and classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5のように、パッケージは、モジュールとクラスの基礎となるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, modules and classes are declared with distinct keywords, but they're still just packages with extra behaviors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl5とは異なり、モジュールとクラスは別々のキーワードで宣言されますが、それらは追加の機能を持ったパッケージでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise every typename has an associated package namespace, even if unused.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に全ての型名は、パッケージを使うかどうかに関係なく、関係を持つパッケージの名前空間を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An ordinary package is declared with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常のパッケージは、<bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept>キーワードで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, in Perl 6 it can only be used with a block:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl5と違い、Perl6 ではブロックを伴ってのみ使用されることが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A named package declaration can occur as part of an expression, just like named subroutine declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前付きのパッケージ宣言は、表現の一部として現われ、ただの名前付きサブルーチン宣言のようでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a special exception, if a braceless <bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept> declaration occurs as the first executable statement in a file, then it's taken to mean that the rest of the file is Perl 5 code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特別な表現として、括弧を伴わない<bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept>宣言がファイルの実行可能な最初の文として現れた場合、ファイルの残りはPerl5のコードを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This form is illegal in a Perl 6 file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式は、Perl6のファイルとしては違法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to have a file-scoped package, either use the brace form or declare it with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>module<ept i='0'>&lt;/c0&gt;</ept> keyword instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファイルスコープのパッケージを作りたいなら、括弧形式を使うか、(packageの)代わりに<bpt i='0' x='0'>&lt;c0&gt;</bpt>module<ept i='0'>&lt;/c0&gt;</ept>キーワードを使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since there are no barewords in Perl 6, package names must be predeclared, or use the sigil-like <bpt i='0' x='0'>&lt;c0&gt;</bpt>::PackageName<ept i='0'>&lt;/c0&gt;</ept> syntax to indicate that the type will be supplied some other way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl6 では裸のワードは存在しないので、パッケージ名はあらかじめ宣言されていなければならず、そうでなければ型が他の場所で提供されている可能性を示すのにシジルみたいな<bpt i='0' x='0'>&lt;c0&gt;</bpt>::PackageName<ept i='0'>&lt;/c0&gt;</ept>構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='1' x='1'>&lt;c1&gt;</bpt>::<ept i='1'>&lt;/c1&gt;</ept> prefix does not imply globalness as it does in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>::<ept i='1'>&lt;/c1&gt;</ept>の接頭辞は、perl5でのようにグローバル性を示す訳ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Use <bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL::<ept i='2'>&lt;/c2&gt;</ept> for that.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それを示すためには<bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL::<ept i='2'>&lt;/c2&gt;</ept>を使いましょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bare <bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept> declarator (without an explicit scope declarator such as <bpt i='1' x='1'>&lt;c1&gt;</bpt>my<ept i='1'>&lt;/c1&gt;</ept>) declares an <bpt i='2' x='2'>&lt;c2&gt;</bpt>our<ept i='2'>&lt;/c2&gt;</ept> package within the current package (or module, or class, or role, or...).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>裸の<bpt i='0' x='0'>&lt;c0&gt;</bpt>package<ept i='0'>&lt;/c0&gt;</ept>宣言(<bpt i='1' x='1'>&lt;c1&gt;</bpt>my<ept i='1'>&lt;/c1&gt;</ept>のようなスコープ宣言子を付けないような)は、現在のパッケージ(やモジュール、クラス、ロールなど)の中の<bpt i='2' x='2'>&lt;c2&gt;</bpt>our<ept i='2'>&lt;/c2&gt;</ept>パッケージを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='3' x='3'>&lt;c3&gt;</bpt>GLOBAL::<ept i='3'>&lt;/c3&gt;</ept> to declare a global package name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルなパッケージ名を宣言するには、<bpt i='3' x='3'>&lt;c3&gt;</bpt>GLOBAL::<ept i='3'>&lt;/c3&gt;</ept>を使いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a lexically scoped package, use <bpt i='0' x='0'>&lt;c0&gt;</bpt>my package<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レキシカルスコープなパッケージを宣言するには、<bpt i='0' x='0'>&lt;c0&gt;</bpt>my package<ept i='0'>&lt;/c0&gt;</ept>を使いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare an anonymous package you can use either of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>匿名のパッケージを宣言するには、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All files start out being parsed in the <bpt i='0' x='0'>&lt;c0&gt;</bpt>GLOBAL<ept i='0'>&lt;/c0&gt;</ept> package, but may switch to some other package scope depending on the first package-ish declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>のどちらかが使えます。全てのファイルが<bpt i='0' x='0'>&lt;c0&gt;</bpt>GLOBAL<ept i='0'>&lt;/c0&gt;</ept>パッケージの中にあるとしてパースされますが，最初のパッケージ的な宣言に依存してそれ以外のパッケージスコープに変化していることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If that first declaration is not a package variant, then the parsing switches to the &quot;<bpt i='1' x='1'>&lt;c1&gt;</bpt>main<ept i='1'>&lt;/c1&gt;</ept>&quot; package for Perl 5 code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の宣言がパッケージ変数でない場合、パースはPerl5コードとしてなら&quot;<bpt i='1' x='1'>&lt;c1&gt;</bpt>main<ept i='1'>&lt;/c1&gt;</ept>&quot;パッケージに変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 code stays <bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL<ept i='2'>&lt;/c2&gt;</ept> in that situation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じようにPerl6のコードなら<bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL<ept i='2'>&lt;/c2&gt;</ept>のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The mainline code is thus in the <bpt i='3' x='3'>&lt;c3&gt;</bpt>GLOBAL<ept i='3'>&lt;/c3&gt;</ept> namespace unless declared otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以外に宣言されていなければ、メインラインのコードは<bpt i='3' x='3'>&lt;c3&gt;</bpt>GLOBAL<ept i='3'>&lt;/c3&gt;</ept>名前空間のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Package traits are set using <bpt i='0' x='0'>&lt;c0&gt;</bpt>is<ept i='0'>&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パッケージトレイトは<bpt i='0' x='0'>&lt;c0&gt;</bpt>is<ept i='0'>&lt;/c0&gt;</ept>を使って設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All symbolic links are done with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>::($expr)<ept i='0'>&lt;/c0&gt;</ept> syntax, which is legal in any variable, package, module, or class name anywhere a <bpt i='1' x='1'>&lt;c1&gt;</bpt>::Ident<ept i='1'>&lt;/c1&gt;</ept> is legal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シンボリックリンクは、<bpt i='0' x='0'>&lt;c0&gt;</bpt>::($expr)<ept i='0'>&lt;/c0&gt;</ept>構文を使います、これは<bpt i='1' x='1'>&lt;c1&gt;</bpt>::Ident<ept i='1'>&lt;/c1&gt;</ept>が有効な場所のどこででも全ての変数、パッケージ、モジュール、クラスの名前で有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string returned by the expression will be parsed for <bpt i='2' x='2'>&lt;c2&gt;</bpt>::<ept i='2'>&lt;/c2&gt;</ept> indicating subpackage names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この表現によって返される文字列は、<bpt i='2' x='2'>&lt;c2&gt;</bpt>::<ept i='2'>&lt;/c2&gt;</ept>の中のサブパッケージ名を差すとしてパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not confuse this with the</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これをシンボルテーブルの中を検索できるようにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>syntax that lets you do a lookup in a particular symbol table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構文と混同しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the key is not parsed for <bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、キィは<bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept>の中としてパースされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's just a hash lookup.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはハッシュの検索として働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A declaration of any object of the form <bpt i='0' x='0'>&lt;c0&gt;</bpt>A::B::c<ept i='0'>&lt;/c0&gt;</ept> also creates (if needed) an empty package <bpt i='1' x='1'>&lt;c1&gt;</bpt>A<ept i='1'>&lt;/c1&gt;</ept>, and an empty package <bpt i='2' x='2'>&lt;c2&gt;</bpt>B<ept i='2'>&lt;/c2&gt;</ept> inside of <bpt i='3' x='3'>&lt;c3&gt;</bpt>A<ept i='3'>&lt;/c3&gt;</ept>, in addition to creating <bpt i='4' x='4'>&lt;c4&gt;</bpt>c<ept i='4'>&lt;/c4&gt;</ept> inside of <bpt i='5' x='5'>&lt;c5&gt;</bpt>B<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>A::B::c<ept i='0'>&lt;/c0&gt;</ept>形式のオブジェクトの宣言は(必要であれば)空のパッケージ<bpt i='1' x='1'>&lt;c1&gt;</bpt>A<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>A<ept i='3'>&lt;/c3&gt;</ept>の中の空のパッケージ<bpt i='2' x='2'>&lt;c2&gt;</bpt>B<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>B<ept i='5'>&lt;/c5&gt;</ept>の中の<bpt i='4' x='4'>&lt;c4&gt;</bpt>c<ept i='4'>&lt;/c4&gt;</ept>を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such empty packages may be subsequently be redeclared as any other package-like object (module, class, etc.), and no redeclaration warning will be issued for such a redeclaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このように空のパッケージは他のパッケージ的なオブジェクト(モジュール、クラス他)によって再宣言されるかもしれません。このような再宣言には再宣言の警告を引き起しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a parent package already exists, no stub package needs to be created, and no declaration of the form <bpt i='6' x='6'>&lt;c6&gt;</bpt>A::B::c<ept i='6'>&lt;/c6&gt;</ept> has anything to say about the type of package <bpt i='7' x='7'>&lt;c7&gt;</bpt>A<ept i='7'>&lt;/c7&gt;</ept> or package <bpt i='8' x='8'>&lt;c8&gt;</bpt>A::B<ept i='8'>&lt;/c8&gt;</ept>, since any package variant can function as a package for the purposes of naming things.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>親パッケージが既に存在する場合、スタブパッケージが作成される必要がありません。パッケージ変数は名前付けされた通りにパッケージとして機能しますので、<bpt i='6' x='6'>&lt;c6&gt;</bpt>A::B::c<ept i='6'>&lt;/c6&gt;</ept>形式の宣言は<bpt i='7' x='7'>&lt;c7&gt;</bpt>A<ept i='7'>&lt;/c7&gt;</ept>パッケージ、<bpt i='8' x='8'>&lt;c8&gt;</bpt>A::B<ept i='8'>&lt;/c8&gt;</ept>パッケージに何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apart of package declaration constructs, package names are always searched for from the innermost lexical scope to outermost.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パッケージ宣言の構成の一部であるパッケージ名は常に最も内側のレキシカルスコープから最も外側のそれの範囲から探されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If not defined in any surrounding lexical scope, the package is searched for from the current package up through the containing packages to <bpt i='0' x='0'>&lt;c0&gt;</bpt>GLOBAL<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レキシカルスコープに囲まれて定義されていなければ、そのパッケージは現在のパッケージから<bpt i='0' x='0'>&lt;c0&gt;</bpt>GLOBAL<ept i='0'>&lt;/c0&gt;</ept>に向かって含んでいるパッケージを探されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it is not found, a compiler error results.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでも見付からなければ、結果としてコンパイルエラーを生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with an initial <bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept>, the presence of a <bpt i='1' x='1'>&lt;c1&gt;</bpt>::<ept i='1'>&lt;/c1&gt;</ept> within the name does not imply globalness (unlike in Perl 5).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先頭の<bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept>のような、名前の中の<bpt i='1' x='1'>&lt;c1&gt;</bpt>::<ept i='1'>&lt;/c1&gt;</ept>は，グローバル性を意味するものではありません(Perl5と違い)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>True globals are always in the <bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL::<ept i='2'>&lt;/c2&gt;</ept> namespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>真のグローバルは常に<bpt i='2' x='2'>&lt;c2&gt;</bpt>GLOBAL::<ept i='2'>&lt;/c2&gt;</ept>名前空間の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>PROCESS::<ept i='0'>&lt;/c0&gt;</ept> namespace, shared by all interpreters within the process, is notionally outside of <bpt i='1' x='1'>&lt;c1&gt;</bpt>GLOBAL::<ept i='1'>&lt;/c1&gt;</ept>, but package searches do not look there for anything.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>PROCESS::<ept i='0'>&lt;/c0&gt;</ept>名前空間は，プロセスの範囲でのインタプリタ全体で共有され、表記として<bpt i='1' x='1'>&lt;c1&gt;</bpt>GLOBAL::<ept i='1'>&lt;/c1&gt;</ept>の外側にあり、パッケージ検索はそこを探しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Contextual variable searches do; <bpt i='2' x='2'>&lt;c2&gt;</bpt>$*PID<ept i='2'>&lt;/c2&gt;</ept> will eventually locate <bpt i='3' x='3'>&lt;c3&gt;</bpt>$PROCESS::PID<ept i='3'>&lt;/c3&gt;</ept> if not hidden by an inner context's <bpt i='4' x='4'>&lt;c4&gt;</bpt>$PID<ept i='4'>&lt;/c4&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(コンテキスト変数検索は探すようになっていて、内側のコンテキストの<bpt i='4' x='4'>&lt;c4&gt;</bpt>$PID<ept i='4'>&lt;/c4&gt;</ept>によって隠されていなければ、<bpt i='2' x='2'>&lt;c2&gt;</bpt>$*PID<ept i='2'>&lt;/c2&gt;</ept>は最終的には<bpt i='3' x='3'>&lt;c3&gt;</bpt>$PROCESS::PID<ept i='3'>&lt;/c3&gt;</ept>を探し出せます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A package (or any other similar namespace) can control autoloading.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パッケージ(やそれ以外の同様な名前空間)はオートロードを制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, Perl 5's <bpt i='0' x='0'>&lt;c0&gt;</bpt>AUTOLOAD<ept i='0'>&lt;/c0&gt;</ept> is being superseded by MMD autoloaders that distinguish declaration from definition, but are not restricted to declaring subs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl5の<bpt i='0' x='0'>&lt;c0&gt;</bpt>AUTOLOAD<ept i='0'>&lt;/c0&gt;</ept>は定義と宣言を区別するMMDのオートローダに取って代わられ、スタブを宣言することに制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A run-time declarator multisub is declared as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時の宣言のマルチスタブは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>which stands in for the declaration of a container object within another container object; it is called when anyone is searching for a name in the package (or module, or class), and the name doesn't already exist in the package.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>のように宣言されています。これは別のコンテナオブジェクトの中のコンテナオブジェクトの宣言の代わりをしています。パッケージ(やモジュールやクラス)の中で名前を探す場合に呼ばれます。その名前はパッケージの中に既に存在している訳ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In particular, <bpt i='0' x='0'>&lt;c0&gt;</bpt>.can<ept i='0'>&lt;/c0&gt;</ept> calls <bpt i='1' x='1'>&lt;c1&gt;</bpt>CANDO<ept i='1'>&lt;/c1&gt;</ept> when trying to determine if a class supports a particular method.) The arguments to <bpt i='2' x='2'>&lt;c2&gt;</bpt>CANDO<ept i='2'>&lt;/c2&gt;</ept> include type information on what kind of object is expected in context, or this may be intuited from the name requested.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(特にクラスが特定のメソッドをサポートしているかどうかを判断しようとする場合には<bpt i='0' x='0'>&lt;c0&gt;</bpt>.can<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>CANDO<ept i='1'>&lt;/c1&gt;</ept>を呼び出します。)<bpt i='2' x='2'>&lt;c2&gt;</bpt>CANDO<ept i='2'>&lt;/c2&gt;</ept>への引数はコンテキストで期待されるオブジェクトの種類の型情報を含みます。これは呼び出される名前からも直感的でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In any case, there may be multiple <bpt i='3' x='3'>&lt;c3&gt;</bpt>CANDO<ept i='3'>&lt;/c3&gt;</ept> routines that are dispatched via MMD:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての場合で、MMD経由でディスパッチされるマルチな<bpt i='3' x='3'>&lt;c3&gt;</bpt>CANDO<ept i='3'>&lt;/c3&gt;</ept>ルーチンが存在する可能性はある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The package itself is just passed as the first argument, since it's the container object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パッケージ自身はコンテナオブジェクトなので、最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subsequent arguments identify the desired type of the inner container and the &quot;name&quot; or &quot;key&quot; by which the object is to be looked up in the outer container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後続の引数は外側のコンテナから探されたオブジェクトによって内部コンテナとして望まれた型と&quot;名前&quot;や&quot;キィ&quot;を特定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such a name does not include its container name, unlike Perl 5's magical <bpt i='0' x='0'>&lt;c0&gt;</bpt>$AUTOLOAD<ept i='0'>&lt;/c0&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その名前にはコンテナの名前を含みません。Perl5のマジカルな<bpt i='0' x='0'>&lt;c0&gt;</bpt>$AUTOLOAD<ept i='0'>&lt;/c0&gt;</ept>変数と違い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nor does it include the type information of a Code object's &quot;long name&quot;; this information comes in via the type parameter, and may be matched against using ordinary subsignature matching:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードオブジェクトの&quot;長い名前&quot;の型情報は含んでいないが、この情報は型パラメータに現われ、通常のサブシグネチャマッチを使いマッチされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The slurpy <bpt i='0' x='0'>&lt;c0&gt;</bpt>%args<ept i='0'>&lt;/c0&gt;</ept> hash is likely to be empty in standard Perl 6 usage, but it's possible that some dialects of Perl will desire a mechanism to pass in additional contextual information, so this parameter is reserved for such purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常のPerl6 の使用法では、丸呑み<bpt i='0' x='0'>&lt;c0&gt;</bpt>%args<ept i='0'>&lt;/c0&gt;</ept>ハッシュは空になりそうですが、渡すメカニズムを追加のコンテキスト情報の中で要求することが可能なPerlの方言もあります。そのためこのパラメータはこのような目的に対して予約されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>CANDO<ept i='0'>&lt;/c0&gt;</ept> is expected to return an inner container object of the proper sort (i.e. a variable, subroutine, or method object), or a proxy object that can &quot;autovivify&quot; lazily, or <bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept> if that name is not to be considered declared in the namespace in question.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その名前が質問の際に名前空間に宣言されていないと考えられる場合、適切な種類(例えば、変数、サブルーチン、メソッドオブジェクト)の内部のコンテナオブジェクト、怠惰な&quot;自動活性&quot;のプロキシオブジェクト、<bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept>を返すことを<bpt i='0' x='0'>&lt;c0&gt;</bpt>CANDO<ept i='0'>&lt;/c0&gt;</ept>は期待されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Only bare <bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept> is interpreted as &quot;not there&quot;, since typed undefs may function as autovivifiable proxy objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(型付けられたundefは自動活性可能なプロキシオブジェクトとして機能しますので、裸の<bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept>は、&quot;そこに無い&quot;として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S12.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S12 参照のこと。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration merely defines the interface to the new object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言は単に新しいオブジェクトへのインターフェイスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That object need not be completely defined yet, though the <bpt i='0' x='0'>&lt;c0&gt;</bpt>CANDO<ept i='0'>&lt;/c0&gt;</ept> routine is certainly <bpt i='1' x='1'>&lt;i1&gt;</bpt>allowed<ept i='1'>&lt;/i1&gt;</ept> to define it eagerly, and even install the inner object into the outer container (the symbol table) if it wants to cache the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのオブジェクトはそのときまでには完全に定義されることを必要としませんが、宣言のキャッシュを望めば<bpt i='0' x='0'>&lt;c0&gt;</bpt>CANDO<ept i='0'>&lt;/c0&gt;</ept>ルーチンはそれを積極的に定義すること、内部オブジェクトを外部コンテナ(シンボルテーブル)に設定することを確実に<bpt i='1' x='1'>&lt;i1&gt;</bpt>許可<ept i='1'>&lt;/i1&gt;</ept>します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At declaration time it might not yet be known whether the inner container object will be used in lvalue or rvalue context; the use of a proxy object can supply either readonly or rw semantics later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言時には、まだ内部コンテナオブジェクトがlvalue、rvalueコンテキストのどちらで使われるかがわかっていないかもしれません。プロキシオブジェクトを使う場合、読み込み専用か読み書き可能な動作のどちらかが後で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the package in question is a class, it is also possible to declare real methods or submethods:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>質問時のパッケージがクラスの場合、実際のメソッドやサブメソッドを宣言することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The method form is inherited by subclasses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド形式はサブクラスにっよって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Submethods are never inherited but may still do MMD within the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブメソッドは継承されませんが、クラスの範囲でMMDは起きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Ordinary multisubs are inherited only to the extent allowed by the MMD mechanism.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(通常のマルチスタブはMMDメカニズムによって許可された拡張に対してのみ継承されます。)</seg>
      </tuv>
    </tu>
  </body>
</tmx>
