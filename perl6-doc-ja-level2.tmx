<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This document originally summarized Apocalypse 1, which covers the initial design concept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このドキュメントはApocalypse 1を要約したもので、初期のデザインコンセプトを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That original summary may be found below under &quot;Random Thoughts&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>原文の概要は &quot;Random Thoughts&quot; 以下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>歴史的資料として凍結されるApocalypsesと違い、SynopsesはPerl 6の設計の更新も反映します 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの更新点は記録されません ― SynopsisがApocalypseと違う場合はSynopsisが正しいと見なして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another assumption has been that if we don't talk about something in these Synopses, it's the same as it is in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一つの前提として、これらSynopsesで我々が話題にしないことはPerl5と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Soon we plan to fill in the gaps with the Perl 5 details though.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もうすぐ我々はPerl 5の細部とのずれを埋める予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mostly, we're just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大抵の場合、我々は餌を巣に運ぶアリのような集団に過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>主にボランティアによって、多くのグループが適当にこまごまとした仕事を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This document does not attempt to summarize all these subprojects--see the various websites for Parrot and Pugs and Perl 6 for such information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このドキュメントはこれらのサブプロジェクトを全て要約するわけではありません。そのような情報はParrotやPugsやPerl 6のウェブサイトなどを参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>我々が言えることは、Perl 5の場合と違ってこれらのプロジェクトは公式のPerlとは異なるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 is anything that passes the official test suite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公式のテストスイートをパスしたものは全てPerl 6なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This test suite was initially developed under the Pugs project because that project is the furthest along in exploring the high-level semantics of Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>当初、このテストスイートはPugsプロジェクトの元で開発されました。Perl 6の開発に関してPugsプロジェクトが最も先行していたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Other projects are better at other things, such as speed or interoperability.) However, the Pugs project views the test suite as community property, and is working towards platform neutrality, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(他のプロジェクトは速度や相互運用性などの面では優れています。)しかしPugsプロジェクトはテストスイートをコミュニティの所有物と考えており、プラットフォームに対して中立になることを目指しているので、このテストが動作するものをPerl 6とすることにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another aspect of this is the Perl 6 compiler will be self-hosting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の側面は、Perl 6コンパイラをセルフホスティングすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>様々なコード出力バックエンドが開発されたら、最終的にはコンパイラ自身をコンパイルするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは主にフロントエンドからプラットフォームの依存性を取り除き、バックエンドだけがプラットフォーム固有の問題を気にするようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The word &quot;apocalypse&quot; historically meant merely &quot;a revealing&quot;, and we're using it in that unexciting sense.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>&quot;apocalypse&quot; という言葉は歴史的には啓示することを意味します。我々はそのありきたりな意味で使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたがRFCを一般人に尋ねたら、興味深いが矛盾した多くのアイデアを得るでしょう。人々の意見は極端に分かれがちで、どのアイデアもお互いに構築することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Larry's First Law of Language Redesign: Everyone wants the colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Larryによる新しい言語設計の最初の秩序：みんながcolonを望む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブ言語のパーサーによる拡張を許容するため、Perlはワンパスの予測的パーサーでパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, lookahead of more than one &quot;longest token&quot; is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、1つより多くの「最も長いトークン」の先読みは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在知られている例外は、パーサーが以下のことをしなければならない場所:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>印で始まり、ブロックで終わるか終わらない補完された式の終わりに設置しなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Recognize that a reduce operator is not really beginning a <bpt i='0' x='0'>&lt;c0&gt;</bpt>[...]<ept i='0'>&lt;/c0&gt;</ept> composer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減少演算子が<bpt i='0' x='0'>&lt;c0&gt;</bpt>[...]<ept i='0'>&lt;/c0&gt;</ept>の作成者の始まりとは限らないと認識しなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlはユニコードで記述され、論理的には基礎的なテキスト表現に関わらず一貫性のあるユニコードの意味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default Perl presents Unicode in &quot;NFG&quot; formation, where each grapheme counts as one character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの書記素が1文字として数えられる場所では、デフォルトでPerlはユニコードをNFG形式で表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書記素とは初心者ユーザーが日常生活の中で考えると思われるどんな発音記号も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlはユニコードの行とパラグラフのセパレータを行マーカーとして数えることが出来ます。しかし、その振る舞いはあなたのエディタが考えるユニコードの行とPerlの行番号のアイデアとマッチするように設定出来るべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードの水平空白は空白として数えられます。しかし、単一のトークンに見えるような隣接したトークンを生成するような場所では細い空白を使わないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方でPerlはインデントを文法として使わないので、空白が意味をなす場所ではいくらでも自由に空白を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメントは常に空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの構文上の目的で、Perlは括弧でないものから括弧文字を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧文字は双方向ミラーリングかPs/Pe/Pi/Pfプロパティのユニコード文字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実用上はPs/Pe/Pi/Pfプロパティの文字を使うのが安全ですが、ASCIIの角括弧はPs/Pe/Pi/Pfセットではないのに双方向なので注目すべき例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応する閉じ文字がない文字は括弧の開始と見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはユニコードBidiMirroringデータテーブルの第2セクションを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字が既にPs/Pe/Pi/Pfマッピングで使用されている場合、どのBidiMirroringのエントリも無視されます（前方、後方マッピング両方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>POD sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6ではPODセクションは複数行コメントとして確実に使用できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, POD syntax now lets you use <bpt i='0' x='0'>&lt;c0&gt;</bpt>=begin comment<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>=end comment<ept i='1'>&lt;/c1&gt;</ept> delimit a POD block correctly without the need for <bpt i='2' x='2'>&lt;c2&gt;</bpt>=cut<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と違い、<bpt i='0' x='0'>&lt;c0&gt;</bpt>=begin comment<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>=end comment<ept i='1'>&lt;/c1&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>=cut<ept i='2'>&lt;/c2&gt;</ept>無しでPODブロックを正しく区切ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In fact, <bpt i='3' x='3'>&lt;c3&gt;</bpt>=cut<ept i='3'>&lt;/c3&gt;</ept> is now gone.) The format name does not have to be <bpt i='4' x='4'>&lt;c4&gt;</bpt>comment<ept i='4'>&lt;/c4&gt;</ept> -- any unrecognized format name will do to make it a comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(現に、<bpt i='3' x='3'>&lt;c3&gt;</bpt>=cut<ept i='3'>&lt;/c3&gt;</ept>は無くなりました)フォーマット名は <bpt i='4' x='4'>&lt;c4&gt;</bpt>comment<ept i='4'>&lt;/c4&gt;</ept>である必要はありません。識別されないフォーマット名はコメントになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(However, bare <bpt i='5' x='5'>&lt;c5&gt;</bpt>=begin<ept i='5'>&lt;/c5&gt;</ept> and <bpt i='6' x='6'>&lt;c6&gt;</bpt>=end<ept i='6'>&lt;/c6&gt;</ept> probably aren't good enough, because all comments in them will show up in the formatted output.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(しかし、裸の<bpt i='5' x='5'>&lt;c5&gt;</bpt>=begin<ept i='5'>&lt;/c5&gt;</ept>と<bpt i='6' x='6'>&lt;c6&gt;</bpt>=end<ept i='6'>&lt;/c6&gt;</ept>ではおそらく不十分です。その中の全てのコメントがフォーマットされて表示されてしまうからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We have single paragraph comments with <bpt i='0' x='0'>&lt;c0&gt;</bpt>=for comment<ept i='0'>&lt;/c0&gt;</ept> as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに、単独のパラグラフコメント<bpt i='0' x='0'>&lt;c0&gt;</bpt>=for comment<ept i='0'>&lt;/c0&gt;</ept>があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That lets <bpt i='1' x='1'>&lt;c1&gt;</bpt>=for<ept i='1'>&lt;/c1&gt;</ept> keep its meaning as the equivalent of a <bpt i='2' x='2'>&lt;c2&gt;</bpt>=begin<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>=end<ept i='3'>&lt;/c3&gt;</ept> combined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='1' x='1'>&lt;c1&gt;</bpt>=for<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>=begin<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>=end<ept i='3'>&lt;/c3&gt;</ept>が結合したものと同等の意味を持つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with <bpt i='4' x='4'>&lt;c4&gt;</bpt>=begin<ept i='4'>&lt;/c4&gt;</ept> and <bpt i='5' x='5'>&lt;c5&gt;</bpt>=end<ept i='5'>&lt;/c5&gt;</ept>, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='4' x='4'>&lt;c4&gt;</bpt>=begin<ept i='4'>&lt;/c4&gt;</ept>と<bpt i='5' x='5'>&lt;c5&gt;</bpt>=end<ept i='5'>&lt;/c5&gt;</ept>のように、コメントはコードの前から後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みドキュメントの詳細はS26を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Except within a string literal, a <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6では文字列リテラルを除いて、<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>は常にコメントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two forms of comment based on <bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>#<ept i='1'>&lt;/c1&gt;</ept>のコメントは2つの形態があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Embedded comments require the <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> to be followed by one or more opening bracketing characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントは括弧の開始文字に続いた<bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは分割を目的とした改行と同じく空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Embedded comments are supported as a variant on quoting syntax, introduced by <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> plus any user-selected bracket characters (as defined in <bpt i='1' x='1'>&lt;a1&gt;</bpt>Lexical Conventions<ept i='1'>&lt;/a1&gt;</ept> above):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントはクォーティング文法の変形としてサポートされ、<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>とユーザーが選んだ括弧文字(<bpt i='1' x='1'>&lt;a1&gt;</bpt>Lexical Conventions<ept i='1'>&lt;/a1&gt;</ept>で定義されているもの)で導入されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧は普通の引用括弧と同じにネストするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An embedded comment is not allowed as the first thing on the line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行頭で埋め込みコメントは許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to have a comment there, you must disambiguate it to either an embedded comment or a line-end comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしそこにコメントを置きたいなら、埋め込みコメントか行コメントの曖昧さをなくす必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can put a space in front of it to make it an embedded comment:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>埋め込みコメントにするために、前に空白を置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or you can put something other than a single <bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept> to make it a line-end comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または行コメントにするために単一の<bpt i='0' x='0'>&lt;c0&gt;</bpt>#<ept i='0'>&lt;/c0&gt;</ept>以外のものを置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, if you are commenting out a block of code using the line-comment form, we recommend that you use <bpt i='1' x='1'>&lt;c1&gt;</bpt>##<ept i='1'>&lt;/c1&gt;</ept>, or <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> followed by some whitespace, preferably a tab to keep any tab formatting consistent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、もしコードブロックを行コメントを使ってコメントアウトするなら、<bpt i='1' x='1'>&lt;c1&gt;</bpt>##<ept i='1'>&lt;/c1&gt;</ept>または空白(できればタブ)が続く<bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>を使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it's often better to use pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、PODコメントは暗黙的に行指向なのでそちらの方が良い場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユーザーが選んだ括弧のクォート構文で、複数の一致する括弧文字を使うことが出来ます。閉じ括弧は同じ数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧のネストは開き括弧と同じ長さでなければ適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note however that bare circumfix or postcircumfix <bpt i='0' x='0'>&lt;c0&gt;</bpt>&lt;&lt;...&gt;&gt;<ept i='0'>&lt;/c0&gt;</ept> is not a user-selected bracket, but the ASCII variant of the <bpt i='1' x='1'>&lt;c1&gt;</bpt>«...»<ept i='1'>&lt;/c1&gt;</ept> interpolating word list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>裸のcircumfixまたはpostcircumfix <bpt i='0' x='0'>&lt;c0&gt;</bpt>&lt;&lt;...&gt;&gt;<ept i='0'>&lt;/c0&gt;</ept>はユーザーが使用可能な括弧ではありません。しかしASCIIの変形の<bpt i='1' x='1'>&lt;c1&gt;</bpt>«...»<ept i='1'>&lt;/c1&gt;</ept>補完単語リストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only <bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept> and the <bpt i='3' x='3'>&lt;c3&gt;</bpt>q<ept i='3'>&lt;/c3&gt;</ept>-style quoters (including <bpt i='4' x='4'>&lt;c4&gt;</bpt>m<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>s<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>tr<ept i='6'>&lt;/c6&gt;</ept>, and <bpt i='7' x='7'>&lt;c7&gt;</bpt>rx<ept i='7'>&lt;/c7&gt;</ept>) enable subsequent user-selected brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>#<ept i='2'>&lt;/c2&gt;</ept>と<bpt i='3' x='3'>&lt;c3&gt;</bpt>q<ept i='3'>&lt;/c3&gt;</ept>-style(<bpt i='4' x='4'>&lt;c4&gt;</bpt>m<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>s<ept i='5'>&lt;/c5&gt;</ept>、 <bpt i='6' x='6'>&lt;c6&gt;</bpt>tr<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>rx<ept i='7'>&lt;/c7&gt;</ept>)だけがユーザーが選んだ括弧を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cのようないくつかの言語は、行を結合するために改行をエスケープすることを許可しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正規表現のような他の言語はバックスラッシュをを様々な理由で使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はこれをあらゆる種類の空白という概念に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with <bpt i='0' x='0'>&lt;c0&gt;</bpt>\<ept i='0'>&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての連続する空白(コメント含む)は<bpt i='0' x='0'>&lt;c0&gt;</bpt>\<ept i='0'>&lt;/c0&gt;</ept>を前に置くことによってパーサーから隠されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as the &quot;unspace&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは&quot;unspace&quot;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>unspaceはPerlの様々な空白を抑制することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えばPerlは名詞と後置演算子の間に空白を無いことを要求しますが、unspaceを使うことで後置演算子をつなげることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特別なケースで、後置演算子の所のバックスラッシュはunspaceの縮退した形式と見なします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これの前に空白は置けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will be parsed as a list operator with a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept> argument:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は<bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept>と一緒のリスト演算子とパースされます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、他の形式のunspaceは空白に先行して役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の後置演算子もunspaceを活用できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一つの典型的な使い方は、ドット後置演算子を次の行に置くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But unspace is mainly about language extensibility: it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしunspaceは主に言語の拡張性に関するものです。あなたが現在インストールしているパーサーに関わらず、改行がパーサーを混乱させるようなあらゆる場面で行を継続することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、unspaceはパーサーから空白を隠しますが、レクサーからは隠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果として、unspaceはトークンとして許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、unspaceが改行を含むなら行として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>PODチャンクは空白として数えられるので、unspaceで飲み込むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヒアドキュメントの境界は抑制されます。けれども、あなたは過度に長いヒアドキュメントの出だしの行をこのように分割できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヒアドキュメントのパーサーは次のようにしか見ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>unspaceはコメントを含むかもしれませんが、コメントはunspaceを含まないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、行コメントはバックスラッシュを意味のあるものと見なしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが次のようにするなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般に、単一のトークンか他の構文単位と誤解される構造を分離する必要がある場合を除いて、Perl 6では空白は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In other words, Perl 6 follows the standard <bpt i='0' x='0'>&lt;i0&gt;</bpt>longest-token<ept i='0'>&lt;/i0&gt;</ept> principle, or in the cases of large constructs, a <bpt i='1' x='1'>&lt;i1&gt;</bpt>prefer shifting to reducing<ept i='1'>&lt;/i1&gt;</ept> principle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(言い換えれば、Perl 6は標準の<bpt i='0' x='0'>&lt;i0&gt;</bpt>最も長いトークン<ept i='0'>&lt;/i0&gt;</ept>の原則、または大きな構文の場合、<bpt i='1' x='1'>&lt;i1&gt;</bpt>prefer shifting to reducing<ept i='1'>&lt;/i1&gt;</ept>の原則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは不変の深いルールです。しかしPerl 6は変化する言語として設計されているので、表面上の影響は様々な演算子に変化し、マクロが言語に加えられるか削除されることを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に項の後の後置演算子と2項演算子の間で競合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし与えられたトークンが後置演算子か2項演算子と解釈されそうなら、2項演算子の前に空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置演算子は間に入る空白を持ちませんが、間に入るドットを持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる分離が望まれ、空白でないものがunspaceか埋め込みコメントの外側に発生するなら、前述のunspaceか埋め込みコメントが使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on <bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept> where a term is expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(クォートで区切るかunspaceを終了することは除いて)項が期待される場所で前に空白を伴うドットは<bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept>のメソッド呼び出しと解釈されます。 それが後置のルールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その点で項が期待されていないなら構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(もちろんドットで始まる2項演算子は有りません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You could, for instance, define a Fortranly <bpt i='1' x='1'>&lt;c1&gt;</bpt>infix:&lt;.EQ.&gt;<ept i='1'>&lt;/c1&gt;</ept> if the fit took you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えばフォートランっぽい<bpt i='1' x='1'>&lt;c1&gt;</bpt>infix:&lt;.EQ.&gt;<ept i='1'>&lt;/c1&gt;</ept>を定義して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は常に以下のように解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの変化形は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし後置のメソッド呼び出しを意味するなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば、続く文字が数字なら、数に続くドットは小数点にしかなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以外の場合は後置のドットはいくつかの種類のメソッド呼び出しの開始と解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In support of OO encapsulation, there is a new fundamental datatype: <bpt i='0' x='0'>&lt;s0&gt;</bpt>P6opaque<ept i='0'>&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクト指向のカプセル化で、<bpt i='0' x='0'>&lt;s0&gt;</bpt>P6opaque<ept i='0'>&lt;/s0&gt;</ept>という新しい基本データ型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>opaqueオブジェクトへの外部からのアクセスは常にメソッド呼び出しで行われます。属性でさえそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はより良く動作する安全なコードを書く助けとなる任意的な型システムを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが提供した型からの情報の推測はコンパイラーが自由に行います。しかし型の情報が欠落していても文句は言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型は正式には構造的な等価性よりも名前の等価性で比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、我々は名前を考えるのは自由であることを好みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &quot;anonymous&quot;).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、(型自体が無名であったとしても)名前は型を定義するモジュールに関連するバージョンと権限を含むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &quot;long name&quot; of the resulting type, so one <bpt i='0' x='0'>&lt;c0&gt;</bpt>Array of Int<ept i='0'>&lt;/c0&gt;</ept> is equivalent to another <bpt i='1' x='1'>&lt;c1&gt;</bpt>Array of Int<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上で、パラメータ付きの型をインスタンス化する場合、引数は結果の型の&quot;長い名前&quot;の一部と考えられるので、ある<bpt i='0' x='0'>&lt;c0&gt;</bpt>Array of Int<ept i='0'>&lt;/c0&gt;</ept>は他の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Array of Int<ept i='1'>&lt;/c1&gt;</ept>と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Another way to look at it is that the type instantiation &quot;factory&quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それを見るもう一つの方法は、インスタンス化する&quot;factory&quot;がメモ化されることです。)型名の別名は元の型と同等と考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Array of Int<ept i='2'>&lt;/c2&gt;</ept> syntax is just sugar for <bpt i='3' x='3'>&lt;c3&gt;</bpt>Array:of(Int)<ept i='3'>&lt;/c3&gt;</ept>, which is the canonical form of an instantiated generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に<bpt i='2' x='2'>&lt;c2&gt;</bpt>Array of Int<ept i='2'>&lt;/c2&gt;</ept>という構文は単にジェネリックタイプをインスタンス化する<bpt i='3' x='3'>&lt;c3&gt;</bpt>Array:of(Int)<ept i='3'>&lt;/c3&gt;</ept>の標準的なシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このパラメータ付きの型の名前の等価性は不変(または少なくとも不変のパラメータのスナップショットを撮ることが出来る)と考えられるパラメータだけを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは不変と考えられないので、2つの明らかに異なるクラスが同じ属性を持っているとしても同じとは見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 supports the notion of <bpt i='0' x='0'>&lt;s0&gt;</bpt>properties<ept i='0'>&lt;/s0&gt;</ept> on various kinds of objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は様々な種類のオブジェクトで<bpt i='0' x='0'>&lt;s0&gt;</bpt>プロパティ<ept i='0'>&lt;/s0&gt;</ept>の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのクラスではなく個々のオブジェクトに管理されているのを除いて、プロパティはオブジェクトの属性に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S12によれば、プロパティは実際にはミックスインのメカニズムで実装され、そのようなミックスインはオブジェクトに対する個々の無名クラスの生成によって完成します(同一の無名クラスが既に存在し、安全に共有できるのでなければ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called <bpt i='0' x='0'>&lt;s0&gt;</bpt>traits<ept i='0'>&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティはコンパイル時に構成される変数やクラスのようなオブジェクトに適用され、<bpt i='0' x='0'>&lt;s0&gt;</bpt>traits<ept i='0'>&lt;/s0&gt;</ept>とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Traitsは実行時に変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時のプロパティの変更は代わりにミックスインによって行われます。これによってコンパイラーは宣言されたtraitsを元に最適化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンですが、それが不便な時は大抵は必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、ファイルハンドルのようないくつかのビルトインの概念はPerl 5以上にオブジェクト指向的になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数の型は変数が含む可能性がある値の性質を示す制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &quot;role&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より正確には、オブジェクトまたは変数に含まれるオブジェクトが&quot;role&quot;が示すメソッドに応答できることの保証です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数自体はどの種類のものが含まれているか指定すること無しに、コンテナがどの様に動作するか指定するコンテナ型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制約とコンテナの型は一緒に使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept> is also initialized to the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept> type object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$x<ept i='0'>&lt;/c0&gt;</ept>はまた、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Int<ept i='1'>&lt;/c1&gt;</ept>型オブジェクトで初期化されることに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これについて詳しくは以下を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>my Dog $spot<ept i='0'>&lt;/c0&gt;</ept> by itself does not automatically call a <bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept> constructor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>my Dog $spot<ept i='0'>&lt;/c0&gt;</ept>それ自体は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>のコンストラクターを自動で呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It merely assigns an undefined <bpt i='2' x='2'>&lt;c2&gt;</bpt>Dog<ept i='2'>&lt;/c2&gt;</ept> prototype object to <bpt i='3' x='3'>&lt;c3&gt;</bpt>$spot<ept i='3'>&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは単に未定義の<bpt i='2' x='2'>&lt;c2&gt;</bpt>Dog<ept i='2'>&lt;/c2&gt;</ept>のプロトタイプオブジェクトを<bpt i='3' x='3'>&lt;c3&gt;</bpt>$spot<ept i='3'>&lt;/c3&gt;</ept>に割り当てます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type name used as a value is an undefined instance of that type's prototype object, or <bpt i='0' x='0'>&lt;i0&gt;</bpt>type object<ept i='0'>&lt;/i0&gt;</ept> for short.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値として使われる任意の型名はその型のプロトタイプオブジェクト、または短くはタイプオブジェクトの未定義のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>右辺のコンテキストでの型名は単一の型の値としてパースされ、引数がないことを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、タイプオブジェクトは関数呼び出しインターフェースに応答するので、あなたは型の名前を括弧と一緒に関数であるかのように使用するでしょう。そして呼び出しに供給されるどんな引数もタイプオブジェクトの示す型によって強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし引数が括弧にないなら、タイプオブジェクト自体が返されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a real <bpt i='0' x='0'>&lt;c0&gt;</bpt>Dog<ept i='0'>&lt;/c0&gt;</ept> object, call a constructor method such as <bpt i='1' x='1'>&lt;c1&gt;</bpt>new<ept i='1'>&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本当の<bpt i='0' x='0'>&lt;c0&gt;</bpt>Dog<ept i='0'>&lt;/c0&gt;</ept>オブジェクトを得るために、<bpt i='1' x='1'>&lt;c1&gt;</bpt>new<ept i='1'>&lt;/c1&gt;</ept>のようなコンストラクタメソッドを呼んで下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンストラクタに引数を渡すことも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>you are declaring that the elements of <bpt i='0' x='0'>&lt;c0&gt;</bpt>@array<ept i='0'>&lt;/c0&gt;</ept> are native integers, but that the array itself is implemented by the <bpt i='1' x='1'>&lt;c1&gt;</bpt>MyArray<ept i='1'>&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>@array<ept i='0'>&lt;/c0&gt;</ept>の要素がネイティブの整数と宣言しますが、配列自体は<bpt i='1' x='1'>&lt;c1&gt;</bpt>MyArray<ept i='1'>&lt;/c1&gt;</ept>クラスで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型指定されない配列とハッシュはまだ完全に何でも受け入れますが、Perl 5と同じパフォーマンスの問題があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get the number of elements in an array, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.elems<ept i='0'>&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素数を得るには<bpt i='0' x='0'>&lt;c0&gt;</bpt>.elems<ept i='0'>&lt;/c0&gt;</ept>メソッドを使用して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also ask for the total string length of an array's elements, in bytes, codepoints or graphemes, using these methods <bpt i='1' x='1'>&lt;c1&gt;</bpt>.bytes<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>.codes<ept i='2'>&lt;/c2&gt;</ept> or <bpt i='3' x='3'>&lt;c3&gt;</bpt>.graphs<ept i='3'>&lt;/c3&gt;</ept> respectively on the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i='1' x='1'>&lt;c1&gt;</bpt>.bytes<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>.codes<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>.graphs<ept i='3'>&lt;/c3&gt;</ept>メソッドを使用してバイト、コードポイント、書記素で配列の要素の文字列の長さの合計を求めることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列にも同じメソッドを適用することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that <bpt i='4' x='4'>&lt;c4&gt;</bpt>.bytes<ept i='4'>&lt;/c4&gt;</ept> is not guaranteed to be well-defined when the encoding is unknown.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='4' x='4'>&lt;c4&gt;</bpt>.bytes<ept i='4'>&lt;/c4&gt;</ept>はエンコーディングが不明な場合は明確には保証されないので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i='5' x='5'>&lt;c5&gt;</bpt>.codes<ept i='5'>&lt;/c5&gt;</ept> is not well-defined unless you know which canonicalization is in effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i='5' x='5'>&lt;c5&gt;</bpt>.codes<ept i='5'>&lt;/c5&gt;</ept>はどの正規化が有効なのか不明な場合は明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビルトインオブジェクト型は大文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes immutable types (e.g. <bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>, <bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>Complex<ept i='2'>&lt;/c2&gt;</ept>, <bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>Bit<ept i='5'>&lt;/c5&gt;</ept>, <bpt i='6' x='6'>&lt;c6&gt;</bpt>Regex<ept i='6'>&lt;/c6&gt;</ept>, <bpt i='7' x='7'>&lt;c7&gt;</bpt>Set<ept i='7'>&lt;/c7&gt;</ept>, <bpt i='8' x='8'>&lt;c8&gt;</bpt>Block<ept i='8'>&lt;/c8&gt;</ept>, <bpt i='9' x='9'>&lt;c9&gt;</bpt>List<ept i='9'>&lt;/c9&gt;</ept>, <bpt i='10' x='10'>&lt;c10&gt;</bpt>Seq<ept i='10'>&lt;/c10&gt;</ept>), as well as mutable (container) types, such as <bpt i='11' x='11'>&lt;c11&gt;</bpt>Scalar<ept i='11'>&lt;/c11&gt;</ept>, <bpt i='12' x='12'>&lt;c12&gt;</bpt>Array<ept i='12'>&lt;/c12&gt;</ept>, <bpt i='13' x='13'>&lt;c13&gt;</bpt>Hash<ept i='13'>&lt;/c13&gt;</ept>, <bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>, <bpt i='15' x='15'>&lt;c15&gt;</bpt>Routine<ept i='15'>&lt;/c15&gt;</ept>, <bpt i='16' x='16'>&lt;c16&gt;</bpt>Module<ept i='16'>&lt;/c16&gt;</ept>, and non-instantiable Roles such as <bpt i='17' x='17'>&lt;c17&gt;</bpt>Callable<ept i='17'>&lt;/c17&gt;</ept>, <bpt i='18' x='18'>&lt;c18&gt;</bpt>Failure<ept i='18'>&lt;/c18&gt;</ept>, and <bpt i='19' x='19'>&lt;c19&gt;</bpt>Integral<ept i='19'>&lt;/c19&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは不変の型を含みます。(例えば<bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Complex<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>Bit<ept i='5'>&lt;/c5&gt;</ept>、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Regex<ept i='6'>&lt;/c6&gt;</ept>、<bpt i='7' x='7'>&lt;c7&gt;</bpt>Set<ept i='7'>&lt;/c7&gt;</ept>、<bpt i='8' x='8'>&lt;c8&gt;</bpt>Block<ept i='8'>&lt;/c8&gt;</ept>、<bpt i='9' x='9'>&lt;c9&gt;</bpt>List<ept i='9'>&lt;/c9&gt;</ept>、<bpt i='10' x='10'>&lt;c10&gt;</bpt>Seq<ept i='10'>&lt;/c10&gt;</ept>)変更可能な型(コンテナ)も同様です。<bpt i='11' x='11'>&lt;c11&gt;</bpt>Scalar<ept i='11'>&lt;/c11&gt;</ept>、<bpt i='12' x='12'>&lt;c12&gt;</bpt>Array<ept i='12'>&lt;/c12&gt;</ept>、<bpt i='13' x='13'>&lt;c13&gt;</bpt>Hash<ept i='13'>&lt;/c13&gt;</ept>、<bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>、<bpt i='15' x='15'>&lt;c15&gt;</bpt>Routine<ept i='15'>&lt;/c15&gt;</ept>、<bpt i='16' x='16'>&lt;c16&gt;</bpt>Module<ept i='16'>&lt;/c16&gt;</ept>など。そしてインスタンス化できない<bpt i='17' x='17'>&lt;c17&gt;</bpt>Callable<ept i='17'>&lt;/c17&gt;</ept>、<bpt i='18' x='18'>&lt;c18&gt;</bpt>Failure<ept i='18'>&lt;/c18&gt;</ept>、<bpt i='19' x='19'>&lt;c19&gt;</bpt>Integral<ept i='19'>&lt;/c19&gt;</ept>も同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型は主にコンパクトな配列を宣言するためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、Perlは対応する大文字の型のように扱えるようにしようとするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In other words, it does autoboxing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(言い換えれば、autoboxingを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのオブジェクトは値型として振る舞うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every object can produce a &quot;WHICH&quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのオブジェクトはハッシュと値ベースの比較のために一意に識別するための&quot;WHICH&quot;という値を出力できます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables with non-native types can always contain <bpt i='0' x='0'>&lt;i0&gt;</bpt>undefined<ept i='0'>&lt;/i0&gt;</ept> values, such as <bpt i='1' x='1'>&lt;c1&gt;</bpt>Object<ept i='1'>&lt;/c1&gt;</ept>, <bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept> and <bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept> objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非ネイティブ型の値は常に<bpt i='0' x='0'>&lt;i0&gt;</bpt>undefined<ept i='0'>&lt;/i0&gt;</ept>値を含むことが出来ます。<bpt i='1' x='1'>&lt;c1&gt;</bpt>Object<ept i='1'>&lt;/c1&gt;</ept>、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept>、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept>のオブジェクトなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S04 for more about failures (i.e. unthrown exceptions):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>failures(例えばunthrown exceptions)についてはS04を参照して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型は未定義をサポートしません: 未定義値をそれらに割り当てるとエラーになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>推測: 浮動小数点形式がこの概念を表現できるなら、numはundefをNaNにする自動変換をサポートするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その変換を任意に出来るなら良いかもしれません。ロケットの設計者は事故破壊を即座に行うか後で行うか決めることが出来るように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables of non-native types start out containing an undefined value unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非ネイティブ型は明示的に定義された値で初期化されるのでなければ未定義値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every object supports a <bpt i='0' x='0'>&lt;c0&gt;</bpt>HOW<ept i='0'>&lt;/c0&gt;</ept> function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのオブジェクトは、オブジェクトが定義されているかどうかに関わらずそれを管理するメタクラスのインスタンスを返す<bpt i='0' x='0'>&lt;c0&gt;</bpt>HOW<ept i='0'>&lt;/c0&gt;</ept>関数/メソッドをサポートします。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(プロトタイプシステム(クラスベースでないオブジェクトシステム)のために全てのオブジェクトは同じメタオブジェクトによって管理されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は本質的にシステムの型宣言を通してbig integersとrationalsをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept> automatically supports promotion to arbitrary precision, as well as holding <bpt i='1' x='1'>&lt;c1&gt;</bpt>Inf<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>NaN<ept i='2'>&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Inf<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>NaN<ept i='2'>&lt;/c2&gt;</ept>を保持するのと同じに任意の精度を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i='3' x='3'>&lt;c3&gt;</bpt>Int<ept i='3'>&lt;/c3&gt;</ept> assumes 2's complement arithmetic, so <bpt i='4' x='4'>&lt;c4&gt;</bpt>+^1 == -2<ept i='4'>&lt;/c4&gt;</ept> is guaranteed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>Int<ept i='3'>&lt;/c3&gt;</ept>は2の補数演算を推測することに注意して下さい。<bpt i='4' x='4'>&lt;c4&gt;</bpt>+^1 == -2<ept i='4'>&lt;/c4&gt;</ept>は保証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Native <bpt i='5' x='5'>&lt;c5&gt;</bpt>int<ept i='5'>&lt;/c5&gt;</ept> operations need not support this on machines that are not natively 2's complement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(ネイティブ<bpt i='5' x='5'>&lt;c5&gt;</bpt>int<ept i='5'>&lt;/c5&gt;</ept>の演算は2の歩数をネイティブにサポートしないマシンではこれをサポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 should by default make standard IEEE floating point concepts visible, such as <bpt i='0' x='0'>&lt;c0&gt;</bpt>Inf<ept i='0'>&lt;/c0&gt;</ept> (infinity) and <bpt i='1' x='1'>&lt;c1&gt;</bpt>NaN<ept i='1'>&lt;/c1&gt;</ept> (not a number).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6はデフォルトで<bpt i='0' x='0'>&lt;c0&gt;</bpt>Inf<ept i='0'>&lt;/c0&gt;</ept>(無限)と<bpt i='1' x='1'>&lt;c1&gt;</bpt>NaN<ept i='1'>&lt;/c1&gt;</ept>(数でない)のような標準のIEEE小数点概念を見えるようにするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レキシカルスコープではプログラムは一時的な値の性質、そして様々な環境で浮動小数点がどの様に振る舞うか指定するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>機能しないプラットフォームをバイパスするために壮大な努力を必要とする場合を除いて、全てのIEEEモードがプラグマによってレキシカルに有効でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デフォルトの浮動小数点モードは例外をスローしませんが、InfとNaNを伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ボックス化されたオブジェクト型はオーバーフローかアンダーフローが起こったところでより詳細な情報を伝達するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlでは数値は同一の答えを与えるように設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(本当によいプログラマーは時にはより良くします。) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept> is a Unicode string object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Str<ept i='0'>&lt;/c0&gt;</ept>はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no corresponding native <bpt i='1' x='1'>&lt;c1&gt;</bpt>str<ept i='1'>&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応するネイティブな<bpt i='1' x='1'>&lt;c1&gt;</bpt>str<ept i='1'>&lt;/c1&gt;</ept>型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, since a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Str<ept i='2'>&lt;/c2&gt;</ept> object may fill multiple roles, we say that a <bpt i='3' x='3'>&lt;c3&gt;</bpt>Str<ept i='3'>&lt;/c3&gt;</ept> keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら<bpt i='2' x='2'>&lt;c2&gt;</bpt>Str<ept i='2'>&lt;/c2&gt;</ept>オブジェクトは複数のroleを果たすので、<bpt i='3' x='3'>&lt;c3&gt;</bpt>Str<ept i='3'>&lt;/c3&gt;</ept>はユニコードの抽象的レベルで最小と最大のトラックを保持し、現在のレキシカルスコープの考える理想的な文字を演じます。バイト、コードポイント、 graphemesまたはある言語の文字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For all builtin operations, all <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept> positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての組み込み操作について、全ての<bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>の位置はポジションオブジェクトとして報告され、整数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i='5' x='5'>&lt;c5&gt;</bpt>StrPos<ept i='5'>&lt;/c5&gt;</ept> objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='5' x='5'>&lt;c5&gt;</bpt>StrPos<ept i='5'>&lt;/c5&gt;</ept>オブジェクトは特定の文字列の特定の場所を抽象化レベルに依存せずポイントします。文字列と位置を直接に追跡するか、あらゆるコンテキストで同じ文字列に適用される同じ結果を与える文字列の始まりのオフセットを抽象化に依存しない表現で出力するかどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is assuming the string isn't modified in the meanwhile; a <bpt i='6' x='6'>&lt;c6&gt;</bpt>StrPos<ept i='6'>&lt;/c6&gt;</ept> is not a &quot;marker&quot; and is not required to follow changes to a mutable string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはその間に文字列が変更されないと仮定します;<bpt i='6' x='6'>&lt;c6&gt;</bpt>StrPos<ept i='6'>&lt;/c6&gt;</ept>は&quot;マーカー&quot;ではなく、変更される文字列を追跡する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、置換された文字列の位置を求めるとしたら、その答えは元の文字列のものです(今はアクセスできないでしょう！)。 変更された文字列のものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポジションオブジェクトが期待されるところで整数を使用すると、現在のレキシカルスコープのユニコード抽象化レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(デフォルトはgraphemesです。)それ以外は適切な単位を強要する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もちろんそのような次元数は文字列が適切な抽象化レベルを提供しないなら失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような次元的でない数を間違った単位で解釈するルーチンに渡すのは間違っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>Buf<ept i='0'>&lt;/c0&gt;</ept> is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of <bpt i='1' x='1'>&lt;c1&gt;</bpt>Str<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Buf<ept i='0'>&lt;/c0&gt;</ept>は文字列的な整数の配列です。明示的にいくつかの種類の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Str<ept i='1'>&lt;/c1&gt;</ept>に変換されるのでなければユニコードか文字のプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A <bpt i='2' x='2'>&lt;c2&gt;</bpt>buf<ept i='2'>&lt;/c2&gt;</ept> is the native counterpart.) Typically it's an array of bytes serving as a buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>buf<ept i='2'>&lt;/c2&gt;</ept>はネイティブ対応です。)通常はバッファを受け取るためのバイト列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise operations on a <bpt i='3' x='3'>&lt;c3&gt;</bpt>Buf<ept i='3'>&lt;/c3&gt;</ept> treat the entire buffer as a single large integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>Buf<ept i='3'>&lt;/c3&gt;</ept>のビット演算は一つの巨大な整数として扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise operations on a <bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept> generally fail unless the <bpt i='5' x='5'>&lt;c5&gt;</bpt>Str<ept i='5'>&lt;/c5&gt;</ept> in question can provide an abstract <bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept> interface somehow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='4' x='4'>&lt;c4&gt;</bpt>Str<ept i='4'>&lt;/c4&gt;</ept>のビット演算は普通は失敗します。<bpt i='5' x='5'>&lt;c5&gt;</bpt>Str<ept i='5'>&lt;/c5&gt;</ept>が <bpt i='6' x='6'>&lt;c6&gt;</bpt>Buf<ept i='6'>&lt;/c6&gt;</ept>の抽象インターフェースを何とか提供しなければ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Coercion to <bpt i='7' x='7'>&lt;c7&gt;</bpt>Buf<ept i='7'>&lt;/c7&gt;</ept> should generally invalidate the <bpt i='8' x='8'>&lt;c8&gt;</bpt>Str<ept i='8'>&lt;/c8&gt;</ept> interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='7' x='7'>&lt;c7&gt;</bpt>Buf<ept i='7'>&lt;/c7&gt;</ept>への強制は一般的には<bpt i='8' x='8'>&lt;c8&gt;</bpt>Str<ept i='8'>&lt;/c8&gt;</ept>のインターフェースを無効にするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a generic type <bpt i='9' x='9'>&lt;c9&gt;</bpt>Buf<ept i='9'>&lt;/c9&gt;</ept> may be instantiated as (or bound to) any of <bpt i='10' x='10'>&lt;c10&gt;</bpt>buf8<ept i='10'>&lt;/c10&gt;</ept>, <bpt i='11' x='11'>&lt;c11&gt;</bpt>buf16<ept i='11'>&lt;/c11&gt;</ept>, or <bpt i='12' x='12'>&lt;c12&gt;</bpt>buf32<ept i='12'>&lt;/c12&gt;</ept> (or to any type that provides the appropriate <bpt i='13' x='13'>&lt;c13&gt;</bpt>Buf<ept i='13'>&lt;/c13&gt;</ept> interface), but when used to create a buffer <bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept> defaults to <bpt i='15' x='15'>&lt;c15&gt;</bpt>buf8<ept i='15'>&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ジェネリック型としての<bpt i='9' x='9'>&lt;c9&gt;</bpt>Buf<ept i='9'>&lt;/c9&gt;</ept>は<bpt i='10' x='10'>&lt;c10&gt;</bpt>buf8<ept i='10'>&lt;/c10&gt;</ept>、<bpt i='11' x='11'>&lt;c11&gt;</bpt>buf16<ept i='11'>&lt;/c11&gt;</ept>、<bpt i='12' x='12'>&lt;c12&gt;</bpt>buf32<ept i='12'>&lt;/c12&gt;</ept>のどれか(または<bpt i='13' x='13'>&lt;c13&gt;</bpt>Buf<ept i='13'>&lt;/c13&gt;</ept>の適切なインターフェースを提供する何かの型)によってインスタンス化（またはバインド）されます。バッファとして使われる時の<bpt i='14' x='14'>&lt;c14&gt;</bpt>Buf<ept i='14'>&lt;/c14&gt;</ept>のデフォルトは<bpt i='15' x='15'>&lt;c15&gt;</bpt>buf8<ept i='15'>&lt;/c15&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは必ずしもバイト位置ではありません ― 整数位置は単に基礎的な位置の数を数えるだけです。それはあるセルを意味するある位置の基礎的な整数型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>utf8<ept i='0'>&lt;/c0&gt;</ept> type is derived from <bpt i='1' x='1'>&lt;c1&gt;</bpt>buf8<ept i='1'>&lt;/c1&gt;</ept>, with the additional constraint that it may only contain validly encoded UTF-8.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>utf8<ept i='0'>&lt;/c0&gt;</ept>型は<bpt i='1' x='1'>&lt;c1&gt;</bpt>buf8<ept i='1'>&lt;/c1&gt;</ept>型から派生し、正当にエンコードされたUTF-8だけであるという追加の制約があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, <bpt i='2' x='2'>&lt;c2&gt;</bpt>utf16<ept i='2'>&lt;/c2&gt;</ept> is derived from <bpt i='3' x='3'>&lt;c3&gt;</bpt>buf16<ept i='3'>&lt;/c3&gt;</ept>, and <bpt i='4' x='4'>&lt;c4&gt;</bpt>utf32<ept i='4'>&lt;/c4&gt;</ept> from <bpt i='5' x='5'>&lt;c5&gt;</bpt>buf32<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に<bpt i='2' x='2'>&lt;c2&gt;</bpt>utf16<ept i='2'>&lt;/c2&gt;</ept>は<bpt i='3' x='3'>&lt;c3&gt;</bpt>buf16<ept i='3'>&lt;/c3&gt;</ept>から派生し、<bpt i='4' x='4'>&lt;c4&gt;</bpt>utf32<ept i='4'>&lt;/c4&gt;</ept>は<bpt i='5' x='5'>&lt;c5&gt;</bpt>buf32<ept i='5'>&lt;/c5&gt;</ept>から派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは型名なので、リスト演算形式は制約には許可されないので、それらを制約として呼び出すために必ず括弧が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は常に次のようにパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> character as a standalone term captures the notion of &quot;Whatever&quot;, which is applied lazily by whatever operator it is an argument to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項の文字<bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>は&quot;何でも&quot;という概念をとらえます。それはwhatever演算子が引数にいい加減に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally it can just be thought of as a &quot;glob&quot; that gives you everything it can in that argument position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的にはそれは引数の位置に何でも与える&quot;glob&quot;と考えることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept> is an undefined prototype object derived from <bpt i='1' x='1'>&lt;c1&gt;</bpt>Any<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>Any<ept i='1'>&lt;/c1&gt;</ept>を継承した未定義のプロトタイプオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型としては抽象型で、定義されたオブジェクトとしてインスタンス化されないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例外が理にかなっていると考えないなら、理にかなった答えが与えられると期待しない方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since the <bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept> object is effectively immutable, the optimizer is free to recognize <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> and optimize in the context of what operator it is being passed to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Whatever<ept i='0'>&lt;/c0&gt;</ept>オブジェクトは不変なので、オプティマイザは <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>を自由に認識することができ、どの演算子に渡されるのかコンテキストの中で最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>produces a function of a single argument:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数1つの関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, the single dispatcher recognizes <bpt i='0' x='0'>&lt;c0&gt;</bpt>*.meth<ept i='0'>&lt;/c0&gt;</ept> and returns <bpt i='1' x='1'>&lt;c1&gt;</bpt>{ $_.meth }<ept i='1'>&lt;/c1&gt;</ept>, so it can be used where patterns are expected:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に単一のディスパッチャーは<bpt i='0' x='0'>&lt;c0&gt;</bpt>*.meth<ept i='0'>&lt;/c0&gt;</ept>を認識して<bpt i='1' x='1'>&lt;c1&gt;</bpt>{ $_.meth }<ept i='1'>&lt;/c1&gt;</ept>を返すので、そのパターンが期待される場所で使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These closures are of type <bpt i='0' x='0'>&lt;c0&gt;</bpt>Code:($)<ept i='0'>&lt;/c0&gt;</ept>, not <bpt i='1' x='1'>&lt;c1&gt;</bpt>Whatever<ept i='1'>&lt;/c1&gt;</ept>, so that constructs can distinguish via multiple dispatch:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Code:($)<ept i='0'>&lt;/c0&gt;</ept>はクロージャー型で<bpt i='1' x='1'>&lt;c1&gt;</bpt>Whatever<ept i='1'>&lt;/c1&gt;</ept>ではないので、構造はマルチディスパッチによって区別できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bare <bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept> form may also be called as a function, and represents the identify function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>裸の<bpt i='0' x='0'>&lt;c0&gt;</bpt>*<ept i='0'>&lt;/c0&gt;</ept>形式は関数としても呼ぶことができ、関数の識別を表します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But note that this is <bpt i='0' x='0'>&lt;i0&gt;</bpt>not<ept i='0'>&lt;/i0&gt;</ept> what is happening above, or</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしこれは上で起こっていることではありません。または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>would end up meaning:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は以下を意味することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>...<ept i='0'>&lt;/c0&gt;</ept> operator is instead dispatching bare <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> to a routine that does dwimmery, and in this case decides to supply a function { * + 1 }.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>...<ept i='0'>&lt;/c0&gt;</ept>演算子は代わりに<bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>を期待通りに動作するルーチンにディスパッチしています。そしてこの場合は関数{ * + 1 }を供給すると決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore <bpt i='0' x='0'>&lt;c0&gt;</bpt>@array[^**]<ept i='0'>&lt;/c0&gt;</ept> represents <bpt i='1' x='1'>&lt;c1&gt;</bpt>@array[{ map { ^* }, @_ }]<ept i='1'>&lt;/c1&gt;</ept>, that is to say, every element of the array, no matter how many dimensions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従って<bpt i='0' x='0'>&lt;c0&gt;</bpt>@array[^**]<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='1' x='1'>&lt;c1&gt;</bpt>@array[{ map { ^* }, @_ }]<ept i='1'>&lt;/c1&gt;</ept>を表し、配列の次元数を問わない配列の全要素ということになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(However, <bpt i='2' x='2'>&lt;c2&gt;</bpt>@array[**]<ept i='2'>&lt;/c2&gt;</ept> means the same thing because (as with <bpt i='3' x='3'>&lt;c3&gt;</bpt>...<ept i='3'>&lt;/c3&gt;</ept> above), the subscript operator will interpret bare <bpt i='4' x='4'>&lt;c4&gt;</bpt>**<ept i='4'>&lt;/c4&gt;</ept> as meaning all the subscripts, not the list of dimension sizes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(ただし<bpt i='2' x='2'>&lt;c2&gt;</bpt>@array[**]<ept i='2'>&lt;/c2&gt;</ept>は同じことを意味します。なぜなら (<bpt i='3' x='3'>&lt;c3&gt;</bpt>...<ept i='3'>&lt;/c3&gt;</ept>で述べたように)添字演算子は裸の<bpt i='4' x='4'>&lt;c4&gt;</bpt>**<ept i='4'>&lt;/c4&gt;</ept>を全ての添字と解釈し、次元のサイズのリストとは解釈しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラがそうでなければ、これらはMMDシステムによって意味を与えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型の値は、それらの対になる大文字の型のオブジェクトとして扱われる時はautobox化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including <bpt i='0' x='0'>&lt;c0&gt;</bpt>bit<ept i='0'>&lt;/c0&gt;</ept>) default to 0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ネイティブ型はPerlの概念の未定義値を表現できないので、明確な初期化がなければネイティブ浮動小数点はデフォルトでNaN、整数（<bpt i='0' x='0'>&lt;c0&gt;</bpt>bit<ept i='0'>&lt;/c0&gt;</ept>含む)はデフォルトで0になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>complex型のデフォルトはNaN + NaN\iです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既知のサイズのbuf型は0の値のシーケンスがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any native type is explicitly initialized to <bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept> (the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept> type), no initialization is attempted and you'll get whatever was already there when the memory was allocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしネイティブ型が<bpt i='1' x='1'>&lt;c1&gt;</bpt>*<ept i='1'>&lt;/c1&gt;</ept>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>Whatever<ept i='2'>&lt;/c2&gt;</ept>型)に明示的に初期化されたら、メモリに既に割り当てられた値が割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしbuf型がユニコード文字列の値で初期化されたら、文字列はユニコードのコードポイントに分解され、それぞれのコードポイントは整数の要素に押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>buf型のサイズが指定されない場合は、初期化する文字列の長さから持ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サイズが指定された場合は文字列は必要に応じて切り詰められるか0で埋められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time; otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either <bpt i='0' x='0'>&lt;c0&gt;</bpt>U+FFFD<ept i='0'>&lt;/c0&gt;</ept> (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or <bpt i='1' x='1'>&lt;c1&gt;</bpt>U+007f<ept i='1'>&lt;/c1&gt;</ept> (DELETE) if the larger value would not fit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしコードポイントがbufの整数型にフィットしない場合は、コンパイル時に検出できるならパースエラーが発生します。そうでなければ実行時に警告され、オーバーフローしたバッファの要素は適切な代替文字<bpt i='0' x='0'>&lt;c0&gt;</bpt>U+FFFD<ept i='0'>&lt;/c0&gt;</ept> (置き換え文字、整数型が少なくとも16ビットの場合)か<bpt i='1' x='1'>&lt;c1&gt;</bpt>U+007f<ept i='1'>&lt;/c1&gt;</ept> (削除文字、より大きい値にフィットしない場合)に置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の変換を望む場合は、明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, no conversion to UTF-8 or UTF-16 is attempted; that must be specified explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特にUTF-8かUTF-16への変換は試みられません。明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(それが起こったら、32ビット整数ベースのbufへの変換はネイティブエンディアンの有効なUTF-32を生成します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These can behave as values or objects of any class, except that <bpt i='0' x='0'>&lt;c0&gt;</bpt>defined<ept i='0'>&lt;/c0&gt;</ept> always returns false.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>defined<ept i='0'>&lt;/c0&gt;</ept>が常にfalseを返す場合を除き、未定義型は値または何かのクラスのオブジェクトとして振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One can create them with the built-in <bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>fail<ept i='2'>&lt;/c2&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは組み込みの<bpt i='1' x='1'>&lt;c1&gt;</bpt>undef<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>fail<ept i='2'>&lt;/c2&gt;</ept>関数で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(failuresがどの様に処理されるかはS04を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どの種類のtype、class、moduleまたはpackageを定義した場合でも、自動的に同じ名前の未定義プロトタイプ値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Failure<ept i='0'>&lt;/c0&gt;</ept> value is put into a typed container, it takes on the type specified by the container but continues to carry the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Failure<ept i='1'>&lt;/c1&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Failure<ept i='0'>&lt;/c0&gt;</ept>値が型付けされたコンテナに設置された時はいつでもコンテナによって指定された型を引き受けますが、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Failure<ept i='1'>&lt;/c1&gt;</ept>のroleをもたらし続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The <bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept> function merely returns the most generic <bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='2' x='2'>&lt;c2&gt;</bpt>undef<ept i='2'>&lt;/c2&gt;</ept>関数は最も一般的な<bpt i='3' x='3'>&lt;c3&gt;</bpt>Failure<ept i='3'>&lt;/c3&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='4' x='4'>&lt;c4&gt;</bpt>fail<ept i='4'>&lt;/c4&gt;</ept> to return more specific failures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より特定のfailuresを返すには<bpt i='4' x='4'>&lt;c4&gt;</bpt>fail<ept i='4'>&lt;/c4&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='5' x='5'>&lt;c5&gt;</bpt>Object<ept i='5'>&lt;/c5&gt;</ept> for the most generic non-failure undefined value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も一般的なnon-failureの未定義値には<bpt i='5' x='5'>&lt;c5&gt;</bpt>Object<ept i='5'>&lt;/c5&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='6' x='6'>&lt;c6&gt;</bpt>Any<ept i='6'>&lt;/c6&gt;</ept> type is also undefined, but excludes <bpt i='7' x='7'>&lt;c7&gt;</bpt>junctions<ept i='7'>&lt;/c7&gt;</ept> so that autothreading may be dispatched using normal multiple dispatch rules.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>Any<ept i='6'>&lt;/c6&gt;</ept>型も未定義ですが、autothreadingは普通のマルチディスパッチの規則でディスパッチされるので<bpt i='7' x='7'>&lt;c7&gt;</bpt>junctions<ept i='7'>&lt;/c7&gt;</ept>は除外します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>Nil<ept i='0'>&lt;/c0&gt;</ept> type is officially undefined as an item but interpolates as a null list into list context, and an empty capture into slice context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Nil<ept i='0'>&lt;/c0&gt;</ept>型は項目として公式に未定義ですが、リストコンテキストではnullリストに、スライスコンテキストでは空キャプチャに補間されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='1' x='1'>&lt;c1&gt;</bpt>Nil<ept i='1'>&lt;/c1&gt;</ept> object may also carry failure information, but if so, the object behaves as a failure only in item context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>Nil<ept i='1'>&lt;/c1&gt;</ept>オブジェクトはfailureの情報ももたらしますが、もしそうなら、オブジェクトはitemコンテキストでのみfailureとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='2' x='2'>&lt;c2&gt;</bpt>Failure<ept i='2'>&lt;/c2&gt;</ept>/<bpt i='3' x='3'>&lt;c3&gt;</bpt>undef<ept i='3'>&lt;/c3&gt;</ept> when you want to return a hard failure that will not evaporate in list context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストコンテキストで消滅しないhard failureを返したい時は <bpt i='2' x='2'>&lt;c2&gt;</bpt>Failure<ept i='2'>&lt;/c2&gt;</ept>/<bpt i='3' x='3'>&lt;c3&gt;</bpt>undef<ept i='3'>&lt;/c3&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects with these types behave like values, i.e. <bpt i='0' x='0'>&lt;c0&gt;</bpt>$x === $y<ept i='0'>&lt;/c0&gt;</ept> is true if and only if their types and contents are identical (that is, if <bpt i='1' x='1'>&lt;c1&gt;</bpt>$x.WHICH<ept i='1'>&lt;/c1&gt;</ept> eqv <bpt i='2' x='2'>&lt;c2&gt;</bpt>$y.WHICH<ept i='2'>&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型は値のように振る舞います。すなわち、<bpt i='0' x='0'>&lt;c0&gt;</bpt>$x === $y<ept i='0'>&lt;/c0&gt;</ept>はそれらの型と内容が同一の場合のみtrueです。(つまり<bpt i='1' x='1'>&lt;c1&gt;</bpt>$x.WHICH<ept i='1'>&lt;/c1&gt;</ept> eqv <bpt i='2' x='2'>&lt;c2&gt;</bpt>$y.WHICH<ept i='2'>&lt;/c2&gt;</ept>なら)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Insofar as Lists are lazy, they're really only partially immutable, in the sense that the past is fixed but the future is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Listsがlazyである限りにおいて、過去が固定され、未来がないという意味では、それらは本当に部分的にだけ不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The portion of a List yet to be determined by iterators may depend on mutable values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>まだイテレータによって決定されていないListの部分は変更可能な値に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an iterator is called upon to iterate and extend the known part of the list, some number of immutable values (which includes immutable references to mutable objects) are decided and locked in at that point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イテレータがリストの既知の部分の反復と拡張の上で呼ばれた時、いくつかの数の不変の値(変更可能なオブジェクトへの不変なリファレンスを含む)が決定され、その点でロックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterators may have several different ways of iterating depending on the degree of laziness/eagerness desired in context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテキストで望まれるlaziness/eagernessの度合いに応じてイテレータはいくつかの異なる方法を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The iterator API is described in S07.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イテレータのAPIはS07で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Instant<ept i='0'>&lt;/c0&gt;</ept>s and <bpt i='1' x='1'>&lt;c1&gt;</bpt>Duration<ept i='1'>&lt;/c1&gt;</ept>s are measured in atomic seconds with fractions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Instant<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>Duration<ept i='1'>&lt;/c1&gt;</ept>は有理数で微少時間に測定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notionally they are real numbers which may be implemented in either <bpt i='2' x='2'>&lt;c2&gt;</bpt>Num<ept i='2'>&lt;/c2&gt;</ept> or <bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>理論上、それらは<bpt i='2' x='2'>&lt;c2&gt;</bpt>Num<ept i='2'>&lt;/c2&gt;</ept>か<bpt i='3' x='3'>&lt;c3&gt;</bpt>Rat<ept i='3'>&lt;/c3&gt;</ept>型で実装される実数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Fixed-point implementations are strongly discouraged.) Interfaces that take <bpt i='4' x='4'>&lt;c4&gt;</bpt>Duration<ept i='4'>&lt;/c4&gt;</ept> arguments, such as sleep(), may also take <bpt i='5' x='5'>&lt;c5&gt;</bpt>Num<ept i='5'>&lt;/c5&gt;</ept> arguments, but <bpt i='6' x='6'>&lt;c6&gt;</bpt>Instant<ept i='6'>&lt;/c6&gt;</ept> arguments must be explicitly created via any of various culturally aware time specification APIs that, by and large, are outside the <bpt i='7' x='7'>&lt;c7&gt;</bpt>CORE<ept i='7'>&lt;/c7&gt;</ept> of Perl 6, with the possible exception of a constructor taking a native TAI value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(固定小数点の実装は強く推奨されません。)sleep()のような<bpt i='4' x='4'>&lt;c4&gt;</bpt>Duration<ept i='4'>&lt;/c4&gt;</ept>の引数を受け取るインターフェースは<bpt i='5' x='5'>&lt;c5&gt;</bpt>Num<ept i='5'>&lt;/c5&gt;</ept>引数も受け取りますが、<bpt i='6' x='6'>&lt;c6&gt;</bpt>Instant<ept i='6'>&lt;/c6&gt;</ept>引数はさまざまな文化を理解した時間仕様のAPI(概してPerl 6の<bpt i='7' x='7'>&lt;c7&gt;</bpt>CORE<ept i='7'>&lt;/c7&gt;</ept>の外側で、ネイティブTAI値を受け取るコンストラクタの可能な例外を伴う)によって明示的に作成されたものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric context a <bpt i='8' x='8'>&lt;c8&gt;</bpt>Duration<ept i='8'>&lt;/c8&gt;</ept> happily returns a <bpt i='9' x='9'>&lt;c9&gt;</bpt>Num<ept i='9'>&lt;/c9&gt;</ept> representing seconds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキストでは<bpt i='8' x='8'>&lt;c8&gt;</bpt>Duration<ept i='8'>&lt;/c8&gt;</ept>は喜んで秒を表す<bpt i='9' x='9'>&lt;c9&gt;</bpt>Num<ept i='9'>&lt;/c9&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If pressed for a number, an <bpt i='10' x='10'>&lt;c10&gt;</bpt>Instant<ept i='10'>&lt;/c10&gt;</ept> will return the length of time in atomic seconds from the TAI epoch, but it will be unhappy about it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値が求められる場面では<bpt i='10' x='10'>&lt;c10&gt;</bpt>Instant<ept i='10'>&lt;/c10&gt;</ept>はTAIエポック値の微少時間の長さを返すでしょう。しかしそれに関しては適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Systems which cannot provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>POSIXのような安定したタイムベースを返すことができないシステムでは、正しい微少時間を最大限に推測できるようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects with these types have distinct <bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept> values that do not change even if the object's contents change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型のオブジェクトはそれぞれがオブジェクトの内容が変わっても変わらない<bpt i='0' x='0'>&lt;c0&gt;</bpt>.WHICH<ept i='0'>&lt;/c0&gt;</ept>値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(Routinesは変更可能と見なされます。なぜならそれらは適所にラップされることができるからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyHash<ept i='0'>&lt;/c0&gt;</ept> differs from a normal <bpt i='1' x='1'>&lt;c1&gt;</bpt>Hash<ept i='1'>&lt;/c1&gt;</ept> in how it handles default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyHash<ept i='0'>&lt;/c0&gt;</ept>は通常の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Hash<ept i='1'>&lt;/c1&gt;</ept>とデフォルト値の扱いが異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of a <bpt i='2' x='2'>&lt;c2&gt;</bpt>KeyHash<ept i='2'>&lt;/c2&gt;</ept> element is set to the default value for the <bpt i='3' x='3'>&lt;c3&gt;</bpt>KeyHash<ept i='3'>&lt;/c3&gt;</ept>, the element is deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>KeyHash<ept i='2'>&lt;/c2&gt;</ept>の要素の値が<bpt i='3' x='3'>&lt;c3&gt;</bpt>KeyHash<ept i='3'>&lt;/c3&gt;</ept>のデフォルト値にセットされていた場合、その要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If undeclared, the default default for a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyHash<ept i='4'>&lt;/c4&gt;</ept> is 0 for numeric types, <bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept> for boolean types, and the null string for string and buffer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言されていない場合、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyHash<ept i='4'>&lt;/c4&gt;</ept>のデフォルトのデフォルトは数値型では0、ブール型では<bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept>、文字列とバッファ型ではnull文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept> of a <bpt i='7' x='7'>&lt;c7&gt;</bpt>Object<ept i='7'>&lt;/c7&gt;</ept> type defaults to the undefined prototype for that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='7' x='7'>&lt;c7&gt;</bpt>Object<ept i='7'>&lt;/c7&gt;</ept>型の<bpt i='6' x='6'>&lt;c6&gt;</bpt>KeyHash<ept i='6'>&lt;/c6&gt;</ept>はその型の未定義プロトタイプがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More generally, the default default is whatever defined value an <bpt i='8' x='8'>&lt;c8&gt;</bpt>undef<ept i='8'>&lt;/c8&gt;</ept> would convert to for that value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より一般的には、デフォルトのデフォルトは定義された値のなんでもの型に変換されるであろう<bpt i='8' x='8'>&lt;c8&gt;</bpt>undef<ept i='8'>&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyHash<ept i='9'>&lt;/c9&gt;</ept> of <bpt i='10' x='10'>&lt;c10&gt;</bpt>Scalar<ept i='10'>&lt;/c10&gt;</ept> deletes elements that go to either 0 or the null string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='10' x='10'>&lt;c10&gt;</bpt>Scalar<ept i='10'>&lt;/c10&gt;</ept>の<bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyHash<ept i='9'>&lt;/c9&gt;</ept>は0かnull文字列の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='11' x='11'>&lt;c11&gt;</bpt>KeyHash<ept i='11'>&lt;/c11&gt;</ept> also autodeletes keys for normal undef values (that is, those undefined values that do not contain an unthrown exception).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='11' x='11'>&lt;c11&gt;</bpt>KeyHash<ept i='11'>&lt;/c11&gt;</ept>は通常のundef値のキーも削除します(つまりそれらの未定義値はスローされない例外を含みません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeySet<ept i='0'>&lt;/c0&gt;</ept> is a <bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept> of booleans with a default of <bpt i='2' x='2'>&lt;c2&gt;</bpt>False<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeySet<ept i='0'>&lt;/c0&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>False<ept i='2'>&lt;/c2&gt;</ept>をデフォルトにしたブール値の<bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use the <bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept> interface and increment an element of a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeySet<ept i='4'>&lt;/c4&gt;</ept> its value becomes true (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし<bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept>インターフェースを使い、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeySet<ept i='4'>&lt;/c4&gt;</ept>の要素を増やした場合はその値はtrueになります(要素が存在しない場合は作成する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし要素を減らした場合はその要素はfalseになり、自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decrementing a non-existing value results in a <bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在しない値を減らすと<bpt i='5' x='5'>&lt;c5&gt;</bpt>False<ept i='5'>&lt;/c5&gt;</ept>値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Incrementing an existing value results in <bpt i='6' x='6'>&lt;c6&gt;</bpt>True<ept i='6'>&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在する値を増やすと<bpt i='6' x='6'>&lt;c6&gt;</bpt>True<ept i='6'>&lt;/c6&gt;</ept>を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When not used as a <bpt i='7' x='7'>&lt;c7&gt;</bpt>Hash<ept i='7'>&lt;/c7&gt;</ept> (that is, when used as an <bpt i='8' x='8'>&lt;c8&gt;</bpt>Array<ept i='8'>&lt;/c8&gt;</ept> or list or <bpt i='9' x='9'>&lt;c9&gt;</bpt>Set<ept i='9'>&lt;/c9&gt;</ept> object) a <bpt i='10' x='10'>&lt;c10&gt;</bpt>KeySet<ept i='10'>&lt;/c10&gt;</ept> behaves as a <bpt i='11' x='11'>&lt;c11&gt;</bpt>Set<ept i='11'>&lt;/c11&gt;</ept> of its keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし<bpt i='7' x='7'>&lt;c7&gt;</bpt>Hash<ept i='7'>&lt;/c7&gt;</ept>として使わない場合(つまり<bpt i='8' x='8'>&lt;c8&gt;</bpt>Array<ept i='8'>&lt;/c8&gt;</ept>かリストか<bpt i='9' x='9'>&lt;c9&gt;</bpt>Set<ept i='9'>&lt;/c9&gt;</ept>オブジェクトとして使った場合)<bpt i='10' x='10'>&lt;c10&gt;</bpt>KeySet<ept i='10'>&lt;/c10&gt;</ept>はそのキーの<bpt i='11' x='11'>&lt;c11&gt;</bpt>Set<ept i='11'>&lt;/c11&gt;</ept>として振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Since the only possible value of a <bpt i='12' x='12'>&lt;c12&gt;</bpt>KeySet<ept i='12'>&lt;/c12&gt;</ept> is the <bpt i='13' x='13'>&lt;c13&gt;</bpt>True<ept i='13'>&lt;/c13&gt;</ept> value, it need not be represented in the actual implementation with any bits at all.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(<bpt i='12' x='12'>&lt;c12&gt;</bpt>KeySet<ept i='12'>&lt;/c12&gt;</ept>の可能な値が<bpt i='13' x='13'>&lt;c13&gt;</bpt>True<ept i='13'>&lt;/c13&gt;</ept>値だけなので、少しのことでも実際の実装では表現する必要はありません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyBag<ept i='0'>&lt;/c0&gt;</ept> is a <bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept> of <bpt i='2' x='2'>&lt;c2&gt;</bpt>UInt<ept i='2'>&lt;/c2&gt;</ept> with default of 0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>KeyBag<ept i='0'>&lt;/c0&gt;</ept>は0をデフォルトにした<bpt i='2' x='2'>&lt;c2&gt;</bpt>UInt<ept i='2'>&lt;/c2&gt;</ept>の<bpt i='1' x='1'>&lt;c1&gt;</bpt>KeyHash<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use the <bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept> interface and increment an element of a <bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyBag<ept i='4'>&lt;/c4&gt;</ept> its value is increased by one (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたが<bpt i='3' x='3'>&lt;c3&gt;</bpt>Hash<ept i='3'>&lt;/c3&gt;</ept>インターフェースを使い、<bpt i='4' x='4'>&lt;c4&gt;</bpt>KeyBag<ept i='4'>&lt;/c4&gt;</ept>の要素をインクリメントするとその値が1増加します(存在しない要素は作成されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you decrement the element the value is decreased by one; if the value goes to 0 the element is automatically deleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素をデクリメントすると値が1減少します。値が0になると要素が自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An attempt to decrement a non-existing value results in a <bpt i='5' x='5'>&lt;c5&gt;</bpt>Failure<ept i='5'>&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在しない値をデクリメントしようとすると<bpt i='5' x='5'>&lt;c5&gt;</bpt>Failure<ept i='5'>&lt;/c5&gt;</ept>値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When not used as a <bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept> (that is, when used as an <bpt i='7' x='7'>&lt;c7&gt;</bpt>Array<ept i='7'>&lt;/c7&gt;</ept> or list or <bpt i='8' x='8'>&lt;c8&gt;</bpt>Bag<ept i='8'>&lt;/c8&gt;</ept> object) a <bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyBag<ept i='9'>&lt;/c9&gt;</ept> behaves as a <bpt i='10' x='10'>&lt;c10&gt;</bpt>Bag<ept i='10'>&lt;/c10&gt;</ept> of its keys, with each key replicated the number of times specified by its corresponding value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept>として使われない場合(つまり<bpt i='7' x='7'>&lt;c7&gt;</bpt>Array<ept i='7'>&lt;/c7&gt;</ept>かリスト化<bpt i='8' x='8'>&lt;c8&gt;</bpt>Bag<ept i='8'>&lt;/c8&gt;</ept>オブジェクトとして使われた場合)、<bpt i='9' x='9'>&lt;c9&gt;</bpt>KeyBag<ept i='9'>&lt;/c9&gt;</ept>はそのキーの<bpt i='10' x='10'>&lt;c10&gt;</bpt>Bag<ept i='10'>&lt;/c10&gt;</ept>として振る舞い、それぞれのキーは対応する値によって指定された回数複製されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Use <bpt i='11' x='11'>&lt;c11&gt;</bpt>.kv<ept i='11'>&lt;/c11&gt;</ept> or <bpt i='12' x='12'>&lt;c12&gt;</bpt>.pairs<ept i='12'>&lt;/c12&gt;</ept> to suppress this behavior in list context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(リストコンテキストでこの振る舞いを抑制するには<bpt i='11' x='11'>&lt;c11&gt;</bpt>.kv<ept i='11'>&lt;/c11&gt;</ept> か<bpt i='12' x='12'>&lt;c12&gt;</bpt>.pairs<ept i='12'>&lt;/c12&gt;</ept>を使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with <bpt i='0' x='0'>&lt;c0&gt;</bpt>Hash<ept i='0'>&lt;/c0&gt;</ept> types, <bpt i='1' x='1'>&lt;c1&gt;</bpt>Pair<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>Mapping<ept i='2'>&lt;/c2&gt;</ept> are mutable in their values but not in their keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Hash<ept i='0'>&lt;/c0&gt;</ept>型のように<bpt i='1' x='1'>&lt;c1&gt;</bpt>Pair<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>Mapping<ept i='2'>&lt;/c2&gt;</ept>はそれらの値を変更できますがキーはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A key can be a reference to a mutable object, but cannot change its <bpt i='3' x='3'>&lt;c3&gt;</bpt>.WHICH<ept i='3'>&lt;/c3&gt;</ept> identity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(キーは変更可能なオブジェクトへの参照になれますが、<bpt i='3' x='3'>&lt;c3&gt;</bpt>.WHICH<ept i='3'>&lt;/c3&gt;</ept>の固有性は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、ハッシュの要素と同様に値は異なるオブジェクトに再バインドされるでしょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的な型はオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl variables have two associated types: their &quot;value type&quot; and their &quot;implementation type&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perlの変数は2つの関連する型を持ちます: それらの&quot;値型&quot;と&quot;実装型&quot;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property, while the implementation type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(より一般的には、どの種類のコンテナもサブルーチンとモジュールを含む実装型を持ちます。)値型はその<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティとして格納され、コンテナの実装型は単にコンテナ自身のオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The word <bpt i='1' x='1'>&lt;c1&gt;</bpt>returns<ept i='1'>&lt;/c1&gt;</ept> is allowed as an alias for <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単語<bpt i='1' x='1'>&lt;c1&gt;</bpt>returns<ept i='1'>&lt;/c1&gt;</ept>は<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>の別名として許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型はどの種類の値が変数に格納されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value type is given as a prefix or with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型は前置か<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>キーワードで与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case this sets the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property of the container to <bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらの場合でもコンテナの<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティを<bpt i='1' x='1'>&lt;c1&gt;</bpt>Dog<ept i='1'>&lt;/c1&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subroutines have a variant of the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> property, <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>, that sets the <bpt i='2' x='2'>&lt;c2&gt;</bpt>as<ept i='2'>&lt;/c2&gt;</ept> property instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンは<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>プロパティの変化形<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>を持ち、代わりに<bpt i='2' x='2'>&lt;c2&gt;</bpt>as<ept i='2'>&lt;/c2&gt;</ept>プロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to <bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept> or by implicit fall-off-the-end return).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>プロパティは返値に強制される制約(もしかしたら抑制) を指定します(<bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept>によって明示的に呼ばれるか最後の暗黙の返値のいずれかによって)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This constraint, unlike the <bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept> property, is not advertised as the type of the routine.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept>プロパティのようでないこの制約はルーチンの型としては表に出ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of it as the implicit type signature of the (possibly implicit) return statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは(もしかしたら暗黙の)return文の暗黙の型シグネチャと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's therefore available for type inferencing within the routine but not outside it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>従ってルーチン内で型推論が利用できますが外側ではできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no <bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept> type is declared, it is assumed to be the same as the <bpt i='7' x='7'>&lt;c7&gt;</bpt>of<ept i='7'>&lt;/c7&gt;</ept> type, if declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept>型が宣言されていない場合、<bpt i='7' x='7'>&lt;c7&gt;</bpt>of<ept i='7'>&lt;/c7&gt;</ept>型が宣言されている場合と同じと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列かハッシュでの値型はそれぞれの格納された要素の型を指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュのキーの型はshape traitで指定されます―S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implementation type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実装型は変数自身がどの様に実装されているかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは変数のtraitとして与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実装型を定義することはPerl 6ではPerl 5の変数のtieに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time <bpt i='0' x='0'>&lt;c0&gt;</bpt>tie<ept i='0'>&lt;/c0&gt;</ept> statement unless the variable is explicitly declared with an implementation type that does the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしPerl 6の変数は宣言時に直接tieされ、<bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> roleを行う実装型で明示的に宣言された変数でなければパフォーマンス上の理由で実行時に<bpt i='0' x='0'>&lt;c0&gt;</bpt>tie<ept i='0'>&lt;/c0&gt;</ept>文でtieされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, package variables are always considered <bpt i='0' x='0'>&lt;c0&gt;</bpt>Tieable<ept i='0'>&lt;/c0&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながらパッケージ変数は常にデフォルトで<bpt i='0' x='0'>&lt;c0&gt;</bpt>Tieable<ept i='0'>&lt;/c0&gt;</ept>とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a consequence, all named packages are also <bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、全ての名前付きパッケージもデフォルトで<bpt i='1' x='1'>&lt;c1&gt;</bpt>Tieable<ept i='1'>&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスとモジュールはtieされたパッケージとは異なると見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the <bpt i='2' x='2'>&lt;c2&gt;</bpt>Package<ept i='2'>&lt;/c2&gt;</ept> role.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の方向から見れば、グローバルパッケージにバインドされることを希望するクラスとモジュールは<bpt i='2' x='2'>&lt;c2&gt;</bpt>Package<ept i='2'>&lt;/c2&gt;</ept> roleが可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どの型の値がそれぞれの要素に格納されているか指定するため、非スカラー型は修飾されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each successive <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> makes the type on its right a parameter of the type on its left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの連続する<bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>はその右のパラメータの型を、その左の型にさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ付きの型は角括弧を使って名前を付けられます。だから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は実際には以下のような意味になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑な型が指定された場合は実際の変数を理解するのが大変なので、同様の後置形式があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> form may be used in subroutines:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンでは<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>形式が使われるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに返値の型はシグネチャ内で指定されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is a slight difference, insofar as the type inferencer will ignore a <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> but pay attention to <bpt i='1' x='1'>&lt;c1&gt;</bpt>--&gt;<ept i='1'>&lt;/c1&gt;</ept> or prefix type declarations, also known as the <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の推測者が<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>を無視する限りにおいて、そこには微妙な違いがあります。しかし<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型としても知られる<bpt i='1' x='1'>&lt;c1&gt;</bpt>--&gt;<ept i='1'>&lt;/c1&gt;</ept>または後置の型宣言に注意を払って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only the inside of the subroutine pays attention to <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>, and essentially coerces the return value to the indicated type, just as if you'd coerced each return expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブルーチンの内側だけが<bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>に注意を払っており、本質的に返値はそれぞれのreturn式を強制したかのように指定された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may also specify the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> type as the <bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> trait (with <bpt i='2' x='2'>&lt;c2&gt;</bpt>returns<ept i='2'>&lt;/c2&gt;</ept> allowed as a synonym):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>型を<bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> trait(<bpt i='2' x='2'>&lt;c2&gt;</bpt>returns<ept i='2'>&lt;/c2&gt;</ept>が同義語として許可される)として指定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &quot;or&quot; junction:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>&quot;or&quot;かjunctionであるかのように、単一の型をセットで使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fancier type constraints may be expressed through a subtype:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手の込んだ型制約はsubtypeを通して表現されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &quot;anded&quot; together (the variable itself supplies type constraints, and <bpt i='0' x='0'>&lt;c0&gt;</bpt>where<ept i='0'>&lt;/c0&gt;</ept> clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &quot;and&quot; junction:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータの項は暗黙に一緒に&quot;anded&quot;された制約のセットと見ることができるので(変数自身は型制約を供給し、<bpt i='0' x='0'>&lt;c0&gt;</bpt>where<ept i='0'>&lt;/c0&gt;</ept>条項かツリーマッチングはさらに制約を加えるだけです)、我々は&quot;and&quot; junctionのように型の並びを許可するためにこれを緩和します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータは他のどの様な変数と同じように型を与えられるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言の中で、クラス変数(それ自身か既存の型名の後のどちらか)は新しい型名を宣言し、実際のパラメータの型と関連づけられているパラメータ付きの値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It declares the new type name in the same scope as the associated declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは関連付けられた宣言として同じスコープ内で新しい型名を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい型名は直ちに取り込まれ、同じシグネチャ内の2つのそのような型は同じ名前の場合は互換性を統一する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a scoped subroutine, a return type can be specified before or after the name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スコープ付きサブルーチンでは、返値の型は名前の前か後で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We call all return types &quot;return types&quot;, but distinguish two kinds of return types, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept> type and the <bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept> type, because the <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type is normally an &quot;official&quot; named type and declares the official interface to the routine, while the <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> type is merely a constraint on what may be returned by the routine from the routine's point of view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>我々は返値の型を&quot;return types&quot;と呼びますが、<bpt i='0' x='0'>&lt;c0&gt;</bpt>as<ept i='0'>&lt;/c0&gt;</ept>型と<bpt i='1' x='1'>&lt;c1&gt;</bpt>of<ept i='1'>&lt;/c1&gt;</ept>型の2種類の返値の型は区別します。なぜなら<bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型は通常は&quot;official&quot;な名前を付けられた型名で、ルーチンに対するオフィシャルなインターフェースを宣言します。<bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>は単にルーチン視点でルーチンによって何が返されるかの制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it's scoped with the <bpt i='0' x='0'>&lt;c0&gt;</bpt>our<ept i='0'>&lt;/c0&gt;</ept> scope modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしサブルーチンが明示的にスコープ化されていないなら、それは<bpt i='0' x='0'>&lt;c0&gt;</bpt>our<ept i='0'>&lt;/c0&gt;</ept>スコープ修飾子でスコープ化されるかのように現在の名前空間(モジュール、クラス、grammarまたはパッケージ)に属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any return type must go after the name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返値の型はどれでも名前の後に移動する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On an anonymous subroutine, any return type can only go after the <bpt i='0' x='0'>&lt;c0&gt;</bpt>sub<ept i='0'>&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無名サブルーチンでは、どの返値の型も<bpt i='0' x='0'>&lt;c0&gt;</bpt>sub<ept i='0'>&lt;/c0&gt;</ept>キーワードの後にしか移動できません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>but you can use a scope modifier to introduce an <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> prefix type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>後置型を導入するためにスコープ修飾子を使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because they are anonymous, you can change the <bpt i='0' x='0'>&lt;c0&gt;</bpt>my<ept i='0'>&lt;/c0&gt;</ept> modifier to <bpt i='1' x='1'>&lt;c1&gt;</bpt>our<ept i='1'>&lt;/c1&gt;</ept> without affecting the meaning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは無名なので、<bpt i='0' x='0'>&lt;c0&gt;</bpt>my<ept i='0'>&lt;/c0&gt;</ept>修飾子は意味に影響を与えずに <bpt i='1' x='1'>&lt;c1&gt;</bpt>our<ept i='1'>&lt;/c1&gt;</ept>に変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type may also be specified after a <bpt i='0' x='0'>&lt;c0&gt;</bpt>--&gt;<ept i='0'>&lt;/c0&gt;</ept> token within the signature.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返値の型はシグネチャの中で<bpt i='0' x='0'>&lt;c0&gt;</bpt>--&gt;<ept i='0'>&lt;/c0&gt;</ept>トークンの後で指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This doesn't mean exactly the same thing as <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>と正確に同じ意味があるものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept> type is the &quot;official&quot; return type, and may therefore be used to do type inferencing outside the sub.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='2' x='2'>&lt;c2&gt;</bpt>of<ept i='2'>&lt;/c2&gt;</ept>型は&quot;official&quot;な返値の型で、サブルーチンの外側で型推論を行うために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept> type only makes the return type available to the internals of the sub so that the <bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept> statement can know its context, but outside the sub we don't know anything about the return value, as if no return type had been declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>as<ept i='3'>&lt;/c3&gt;</ept>型はサブルーチンの内部で利用できる返値の型を作るだけで、<bpt i='4' x='4'>&lt;c4&gt;</bpt>return<ept i='4'>&lt;/c4&gt;</ept>文がそのコンテキストを知ることができますが、サブルーチンの外側では返値の型が宣言されていないかのように返値の型に関して何も知ることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The prefix form specifies the <bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept> type rather than the <bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept> type, so the return type of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置形式は<bpt i='6' x='6'>&lt;c6&gt;</bpt>as<ept i='6'>&lt;/c6&gt;</ept>型よりも<bpt i='5' x='5'>&lt;c5&gt;</bpt>of<ept i='5'>&lt;/c5&gt;</ept>型を指定するので、返値の型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is known to return an object of type Fish, as if you'd said:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>はあなたが次のようにしたかのようにFish型のオブジェクトを返すと知ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>not<ept i='0'>&lt;/i0&gt;</ept> as if you'd said</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のようにではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is possible for the <bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept> type to disagree with the <bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>of<ept i='0'>&lt;/c0&gt;</ept>型と<bpt i='1' x='1'>&lt;c1&gt;</bpt>as<ept i='1'>&lt;/c1&gt;</ept>型を区別することが可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または同じに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perl 6 includes a system of <bpt i='0' x='0'>&lt;s0&gt;</bpt>sigils<ept i='0'>&lt;/s0&gt;</ept> to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 6は変数の基本的な構造をマークするための<bpt i='0' x='0'>&lt;s0&gt;</bpt>sigils<ept i='0'>&lt;/s0&gt;</ept>システムを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a declaration, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;<ept i='0'>&lt;/c0&gt;</ept> sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言内で<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;<ept i='0'>&lt;/c0&gt;</ept> sigilはスコープ宣言内のsigil無しにサブルーチン名の可視性も宣言します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within a signature or other declaration, the <bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept> sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャか他の宣言内で、識別子が続く<bpt i='0' x='0'>&lt;c0&gt;</bpt>::<ept i='0'>&lt;/c0&gt;</ept> sigilはpackage/type名の可視性をスコープ宣言のsigil無しに宣言する型変数をマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初はそのようなスコープ付きの宣言はバインドされない型とみなされ、その関連付けられた引数の実際の型を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く同じスコープの宣言内のsigilは任意なので、裸の型名も宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>内側をネストする宣言は同じ型を参照したい場合はsigilを使うことは出来ません。内側の宣言は型を再バインドするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(pointy blockのシグネチャは外側のブロックではなく内側のブロックとして数えられルので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsはバインドされたオブジェクトの正確な型ではなく、全体的なインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なるsigilsはわずかな異なる能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなスカラー変数はオブジェクトが本質的に複合型か単一型かどうかに関わらず常にどのようなリストコンテキストでも単数形アイテムとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの種類のデリファレンスコンテキストに置かれなければ、その内容は自動的にデリファレンスされないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mostly though it just means that you want to give some abstraction an official name that you can then use later in the compilation without any sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはコンパイル中になんらかのsigil無しに抽象化に後で使えるように公式な名前を与えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのような場合でも、sigilによって意味づけされた最小のコンテナroleは最新のバインディング時にチェックされ、文法エラーがすぐに検出できるなら（コンパイル時のような）早期に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなリストの添字は元のオブジェクトの添字を意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と違い、もはやsigilとそれに続く名前または構造の間に空白を置けないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通のsigilsは通常のスコープ変数、レキシカルかパッケージスコープを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Oddly scoped variables include a secondary sigil (a <bpt i='0' x='0'>&lt;s0&gt;</bpt>twigil<ept i='0'>&lt;/s0&gt;</ept>) that indicates what kind of strange scoping the variable is subject to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変なスコープ変数は変数がどの種類の奇妙なスコープに従属するかを示す2つ目のsigil(<bpt i='0' x='0'>&lt;s0&gt;</bpt>twigil<ept i='0'>&lt;/s0&gt;</ept>)を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &quot;my&quot; or &quot;our&quot;.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどのtwigils変数は暗黙に他のスコープに宣言されるか宣言されていると見なされ、&quot;my&quot;か&quot;our&quot;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attribute variables are declared with <bpt i='0' x='0'>&lt;c0&gt;</bpt>has<ept i='0'>&lt;/c0&gt;</ept>, though.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性変数は<bpt i='0' x='0'>&lt;c0&gt;</bpt>has<ept i='0'>&lt;/c0&gt;</ept>で宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsは今は変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept> always means a scalar variable, <bpt i='1' x='1'>&lt;c1&gt;</bpt>@<ept i='1'>&lt;/c1&gt;</ept> an array variable, and <bpt i='2' x='2'>&lt;c2&gt;</bpt>%<ept i='2'>&lt;/c2&gt;</ept> a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$<ept i='0'>&lt;/c0&gt;</ept>は常にスカラー変数を意味し、添字がある場合でも<bpt i='1' x='1'>&lt;c1&gt;</bpt>@<ept i='1'>&lt;/c1&gt;</ept>は配列、<bpt i='2' x='2'>&lt;c2&gt;</bpt>%<ept i='2'>&lt;/c2&gt;</ept>はハッシュ変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In item context, variables such as <bpt i='3' x='3'>&lt;c3&gt;</bpt>@array<ept i='3'>&lt;/c3&gt;</ept> and <bpt i='4' x='4'>&lt;c4&gt;</bpt>%hash<ept i='4'>&lt;/c4&gt;</ept> simply return themselves as <bpt i='5' x='5'>&lt;c5&gt;</bpt>Array<ept i='5'>&lt;/c5&gt;</ept> and <bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept> objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アイテムコンテキストでは<bpt i='3' x='3'>&lt;c3&gt;</bpt>@array<ept i='3'>&lt;/c3&gt;</ept>や<bpt i='4' x='4'>&lt;c4&gt;</bpt>%hash<ept i='4'>&lt;/c4&gt;</ept>のような変数は単純にそれら自身を<bpt i='5' x='5'>&lt;c5&gt;</bpt>Array<ept i='5'>&lt;/c5&gt;</ept>や<bpt i='6' x='6'>&lt;c6&gt;</bpt>Hash<ept i='6'>&lt;/c6&gt;</ept>オブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Item context was formerly known as scalar context, but we now reserve the &quot;scalar&quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(アイテムコンテキストは以前はスカラーコンテキストとして知られていましたが、われわれは&quot;scalar&quot;の概念をコンテキスト（リストコンテキストからの配列の解除）よりも変数のことに関しての話と予約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列コンテキストではコンテナオブジェクトは自動的に適切な文字列値に文字列化(空白で区切られた)されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールコンテキストでは、コンテナに要素がある場合だけtrue値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a Perlish representation of any object, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.perl<ept i='0'>&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのPerlっぽい表現を得るには<bpt i='0' x='0'>&lt;c0&gt;</bpt>.perl<ept i='0'>&lt;/c0&gt;</ept>メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the <bpt i='1' x='1'>&lt;c1&gt;</bpt>Data::Dumper<ept i='1'>&lt;/c1&gt;</ept> module in Perl 5, the <bpt i='2' x='2'>&lt;c2&gt;</bpt>.perl<ept i='2'>&lt;/c2&gt;</ept> method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5の<bpt i='1' x='1'>&lt;c1&gt;</bpt>Data::Dumper<ept i='1'>&lt;/c1&gt;</ept>モジュールのように、<bpt i='2' x='2'>&lt;c2&gt;</bpt>.perl<ept i='2'>&lt;/c2&gt;</ept>メソッドは文字列にクォートを置き、リスト値に角括弧を置き、ハッシュ値にカーリーを置きます。なのでPerlは結果を評価して同じオブジェクトに戻せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='3' x='3'>&lt;c3&gt;</bpt>.perl<ept i='3'>&lt;/c3&gt;</ept> method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>.perl<ept i='3'>&lt;/c3&gt;</ept>メソッドはオブジェクトの想定の表現を返し、もしコードが同じ点で再解析されたら、アイテムコンテキストでオブジェクトをスカラーとして再出力するのに使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use <bpt i='4' x='4'>&lt;c4&gt;</bpt>&lt;prefix:&lt;|<ept i='4'>&lt;/c4&gt;</ept> &gt;&gt; to force interpolation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし再解析されたオブジェクトをリストコンテキストに挿入したいなら、<bpt i='4' x='4'>&lt;c4&gt;</bpt>&lt;prefix:&lt;|<ept i='4'>&lt;/c4&gt;</ept> &gt;&gt;を強制挿入のために使う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d')<ept i='0'>&lt;/c0&gt;</ept> method to do an implicit <bpt i='1' x='1'>&lt;c1&gt;</bpt>sprintf<ept i='1'>&lt;/c1&gt;</ept> on the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スカラー値のフォーマットされた表現を得るには、値に暗黙の<bpt i='1' x='1'>&lt;c1&gt;</bpt>sprintf<ept i='1'>&lt;/c1&gt;</ept>を行う<bpt i='0' x='0'>&lt;c0&gt;</bpt>.fmt('%03d')<ept i='0'>&lt;/c0&gt;</ept>メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は一貫して左にあるどんなものにでも作られたコンテナをデリファレンスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数名と添字の間の空白は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、構造を視覚的に引き延ばす2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since a subscript is a kind of postfix operator, there is a corresponding <bpt i='0' x='0'>&lt;s0&gt;</bpt>dot<ept i='0'>&lt;/s0&gt;</ept> form of each subscript (<bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.[1]<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>%bar.{'a'}<ept i='2'>&lt;/c2&gt;</ept>) that makes the dereference a little more explicit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は後置演算子の一種なので、それぞれの添字に対応する<bpt i='0' x='0'>&lt;s0&gt;</bpt>dot<ept i='0'>&lt;/s0&gt;</ept>形式があります(<bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.[1]<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>%bar.{'a'}<ept i='2'>&lt;/c2&gt;</ept>)。それはデリファレンスをより少し明示的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant string subscripts may be placed in angles, so <bpt i='3' x='3'>&lt;c3&gt;</bpt>%bar.{'a'}<ept i='3'>&lt;/c3&gt;</ept> may also be written as <bpt i='4' x='4'>&lt;c4&gt;</bpt>%bar&lt;a&gt;<ept i='4'>&lt;/c4&gt;</ept> or <bpt i='5' x='5'>&lt;c5&gt;</bpt>%bar.&lt;a&gt;<ept i='5'>&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数文字列の添字はangles内に置かれます。つまり<bpt i='3' x='3'>&lt;c3&gt;</bpt>%bar.{'a'}<ept i='3'>&lt;/c3&gt;</ept>は<bpt i='4' x='4'>&lt;c4&gt;</bpt>%bar&lt;a&gt;<ept i='4'>&lt;/c4&gt;</ept>か<bpt i='5' x='5'>&lt;c5&gt;</bpt>%bar.&lt;a&gt;<ept i='5'>&lt;/c5&gt;</ept>とも書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、unspaceを使って追加の空白を挿入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライシングは添字の性質で指定され、sigilによってではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添字は常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(More specifically, they are evaluated in a variant of list context known as <bpt i='0' x='0'>&lt;i0&gt;</bpt>slice<ept i='0'>&lt;/i0&gt;</ept> context, which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(より正確には、それらは<bpt i='0' x='0'>&lt;i0&gt;</bpt>slice<ept i='0'>&lt;/i0&gt;</ept>コンテキストというリストコンテキストの変化形で評価され、それは次元的情報を保存し、あなたはmulti-dimensionalスライスをセミコロンを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a slice context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、それぞれの次元のスライスは普通のリストコンテキストなので添字の一部で呼ばれた関数はsliceコンテキストを認識しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし内部のコンテキストをアイテム(スカラー)コンテキストに強制したいなら+を数値コンテキスト、~を文字列コンテキストに指定するなどの便利な単一文字のspecifiersがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sigils used either as functions or as list prefix operators also force context, so these also work:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sigilsを関数として、またはリストの前置演算子として使うかどちらかによってもコンテキストを強制できます。なのでこれらはこのようにも動きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしこれらは同じではないので注意して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストバインディングからリストの割り当てを識別する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストの割り当てはPerl 5のように、値をコピーして動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's a new <bpt i='0' x='0'>&lt;c0&gt;</bpt>:=<ept i='0'>&lt;/c0&gt;</ept> binding operator that lets you bind names to <bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept> and <bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept> objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i='0' x='0'>&lt;c0&gt;</bpt>:=<ept i='0'>&lt;/c0&gt;</ept>バインディング演算子があり、それはコピー無しに<bpt i='1' x='1'>&lt;c1&gt;</bpt>Array<ept i='1'>&lt;/c1&gt;</ept>と<bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept>オブジェクトを名前にバインディングし、サブルーチンの引数の同じ方法ではパラメータに正式にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バインディングについて詳しくはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An argument list may be captured into an object with backslashed parens:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数リストはバックスラッシュ括弧でオブジェクトに取り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values in a <bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept> object are parsed as ordinary expressions, then marked as positional or named.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>Capture<ept i='0'>&lt;/c0&gt;</ept>オブジェクト内の値は普通の式としてパースされ、順番か名前でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように解決されるかは最終的に何にバインドされるかに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他がそうでない場合に、いくつかのバインディングは複数の次元に敏感です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When cast into an array, you can access all the positional arguments; into a hash, all named arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列にキャストすると全てのポジショナル引数にアクセスできます。ハッシュなら全ての名前付き引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての前置sigil演算子は一つのポジショナル引数を許容します。それは右辺値としてアイテムコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらはもし括弧で呼ばれたら文字列に差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of them as &quot;fat&quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは&quot;fat&quot;リファレンスと考えることができます。それは現在のシングルオブジェクトのアイデンティティだけでなく、関連するいくつかのオブジェクトを取り込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signature object (<bpt i='0' x='0'>&lt;c0&gt;</bpt>Signature<ept i='0'>&lt;/c0&gt;</ept>) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャオブジェクト(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Signature<ept i='0'>&lt;/c0&gt;</ept>)はコロン前置の括弧で作成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグネチャ中の式は普通の式ではなくパラメータ宣言として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータの文法の詳細についてはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型変数にバインドされたシグネチャオブジェクト(上記の例のように)は追加の型制約を適用するために他のシグネチャと共に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in Perl 5, the notation <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept> merely stands for the <bpt i='1' x='1'>&lt;c1&gt;</bpt>foo<ept i='1'>&lt;/c1&gt;</ept> function as a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Routine<ept i='2'>&lt;/c2&gt;</ept> object without calling it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5と異なり、<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept>という表記は単に関数<bpt i='1' x='1'>&lt;c1&gt;</bpt>foo<ept i='1'>&lt;/c1&gt;</ept>を<bpt i='2' x='2'>&lt;c2&gt;</bpt>Routine<ept i='2'>&lt;/c2&gt;</ept>オブジェクトとして呼び出し無しに表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧でデリファレンスしてCodeオブジェクトを呼べるでしょう(もちろん引数を含めて):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧の前に空白は許されません。なぜなら括弧は後置として解析されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with any postfix, there is also a corresponding <bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept> operator, and you may use the &quot;unspace&quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのpostfixとも同じように、対応する<bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept>演算子があり、オプショナルな空白やコメントを挿入するために間にバックスラッシュで&quot;unspace&quot;を使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note however that the parentheses around arguments in the &quot;normal&quot; named forms of function and method calls are not postfix operators, so do not allow the <bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept> form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通の形式の名前に付けられた括弧は関数かメソッド呼び出しですが後置演算子ではありません。そのため<bpt i='0' x='0'>&lt;c0&gt;</bpt>.()<ept i='0'>&lt;/c0&gt;</ept>形式は許されません。なぜならドットは実際にはデリファレンス演算子を示すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you <bpt i='0' x='0'>&lt;i0&gt;</bpt>do<ept i='0'>&lt;/i0&gt;</ept> use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの特別な場合にドット形式を使う場合は、引数無しに名前付き形式を呼ぶか、結果をデリファレンスしたいということを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With multiple dispatch, <bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept> may actually be the name of a set of candidate functions (which you can use as if it were an ordinary function).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マルチディスパッチにおいては<bpt i='0' x='0'>&lt;c0&gt;</bpt>&amp;foo<ept i='0'>&lt;/c0&gt;</ept>は実際には候補関数のセットの名前になります(それは普通の関数であるかのように使うことが出来ます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in that case <bpt i='1' x='1'>&lt;c1&gt;</bpt>&amp;foo<ept i='1'>&lt;/c1&gt;</ept> by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしこの場合は<bpt i='1' x='1'>&lt;c1&gt;</bpt>&amp;foo<ept i='1'>&lt;/c1&gt;</ept>自身は特定の関数の関数名となるには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定するために、型は後置演算子のシグネチャリテラルを使ってリファインされるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It still just returns the <bpt i='0' x='0'>&lt;c0&gt;</bpt>Routine<ept i='0'>&lt;/c0&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはまだ<bpt i='0' x='0'>&lt;c0&gt;</bpt>Routine<ept i='0'>&lt;/c0&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A call may also be partially applied by using the <bpt i='1' x='1'>&lt;c1&gt;</bpt>.assuming<ept i='1'>&lt;/c1&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>呼び出しは<bpt i='1' x='1'>&lt;c1&gt;</bpt>.assuming<ept i='1'>&lt;/c1&gt;</ept>を使うことによっても部分的に適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライシング文法はS09でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多次元スライスは個々のスライスサブリストの間のセミコロンで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each such slice sublist is evaluated lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのスライスサブリストは曖昧に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスの添字を値以外の何かを返すようにさせるには、添字に適切な副詞を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの副詞的形式は存在しないエントリーを取り去ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may also perform an existence test, which will return true if all the elements of the slice exist:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのスライスの要素が存在するならtrueを返すテストを実行することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>likewise,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>deletes the entries &quot;en passant&quot; while returning them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>は値を返すついでに削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(もちろん単一のインデックスのスライスでもこれらの形式は動きます。)添字が最も前の演算子であるという事実のおかげでこれらが動くということに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(このようなスライス修飾子はめったには起こりません。なぜならそれらは普通はコンマの優先順位を操作するリストコンテキストで使用されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In numeric context (i.e. when cast into <bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept> or <bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>), a <bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept> object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値コンテキスト(<bpt i='0' x='0'>&lt;c0&gt;</bpt>Int<ept i='0'>&lt;/c0&gt;</ept>か<bpt i='1' x='1'>&lt;c1&gt;</bpt>Num<ept i='1'>&lt;/c1&gt;</ept>にキャストされる場合)、<bpt i='2' x='2'>&lt;c2&gt;</bpt>Hash<ept i='2'>&lt;/c2&gt;</ept>オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値コンテキストではなんらかのペアがハッシュにあればtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, any intrinsic iterator would be reset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらかの場合で、内在のイテレータはリセットされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペアのリストをソートするとデフォルトでキーでソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting a list of lists should sort on the first elements, then the second elements, etc.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストのリストをソートすると最初の要素でソートし、次に2番目の要素で、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on <bpt i='0' x='0'>&lt;c0&gt;</bpt>sort<ept i='0'>&lt;/c0&gt;</ept> see S29.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>sort<ept i='0'>&lt;/c0&gt;</ept>の詳細についてはS29を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Perl 5の特殊変数はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残りの特殊変数はレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes <bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept> and <bpt i='1' x='1'>&lt;c1&gt;</bpt>@_<ept i='1'>&lt;/c1&gt;</ept>, as well as the new <bpt i='2' x='2'>&lt;c2&gt;</bpt>$/<ept i='2'>&lt;/c2&gt;</ept>, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i='0' x='0'>&lt;c0&gt;</bpt>$_<ept i='0'>&lt;/c0&gt;</ept>と<bpt i='1' x='1'>&lt;c1&gt;</bpt>@_<ept i='1'>&lt;/c1&gt;</ept>を含み、同様に新しい<bpt i='2' x='2'>&lt;c2&gt;</bpt>$/<ept i='2'>&lt;/c2&gt;</ept>は最後の正規表現マッチの返値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>$0<ept i='3'>&lt;/c3&gt;</ept>, <bpt i='4' x='4'>&lt;c4&gt;</bpt>$1<ept i='4'>&lt;/c4&gt;</ept>, <bpt i='5' x='5'>&lt;c5&gt;</bpt>$2<ept i='5'>&lt;/c5&gt;</ept>, etc., are aliases into the <bpt i='6' x='6'>&lt;c6&gt;</bpt>$/<ept i='6'>&lt;/c6&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='3' x='3'>&lt;c3&gt;</bpt>$0<ept i='3'>&lt;/c3&gt;</ept>、<bpt i='4' x='4'>&lt;c4&gt;</bpt>$1<ept i='4'>&lt;/c4&gt;</ept>、<bpt i='5' x='5'>&lt;c5&gt;</bpt>$2<ept i='5'>&lt;/c5&gt;</ept>などは<bpt i='6' x='6'>&lt;c6&gt;</bpt>$/<ept i='6'>&lt;/c6&gt;</ept>オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i='0' x='0'>&lt;c0&gt;</bpt>$#foo<ept i='0'>&lt;/c0&gt;</ept> notation is dead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;c0&gt;</bpt>$#foo<ept i='0'>&lt;/c0&gt;</ept>表記法はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.end<ept i='1'>&lt;/c1&gt;</ept> or <bpt i='2' x='2'>&lt;c2&gt;</bpt>@foo[*-1]<ept i='2'>&lt;/c2&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='1' x='1'>&lt;c1&gt;</bpt>@foo.end<ept i='1'>&lt;/c1&gt;</ept>か<bpt i='2' x='2'>&lt;c2&gt;</bpt>@foo[*-1]<ept i='2'>&lt;/c2&gt;</ept>を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Or <bpt i='3' x='3'>&lt;c3&gt;</bpt>@foo.shape[$dimension]<ept i='3'>&lt;/c3&gt;</ept> for multidimensional arrays.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>(または<bpt i='3' x='3'>&lt;c3&gt;</bpt>@foo.shape[$dimension]<ept i='3'>&lt;/c3&gt;</ept>を多次元配列に使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i='0' x='0'>&lt;i0&gt;</bpt>identifier<ept i='0'>&lt;/i0&gt;</ept> is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>識別子<ept i='0'>&lt;/i0&gt;</ept>は英数字が続くアルファベットで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アルファベットと数字の定義は適切なユニコード文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アンダースコアは常にアルファベットと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子は次の文字がアルファベットの孤立したアポストロフィかハイフンを含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i='0' x='0'>&lt;i0&gt;</bpt>name<ept i='0'>&lt;/i0&gt;</ept> is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i='0' x='0'>&lt;i0&gt;</bpt>名前<ept i='0'>&lt;/i0&gt;</ept>は変数名の適正な部分のことです(sigilは数えません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは以下を含みます。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
