<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>と</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document originally summarized Apocalypse 1, which covers the initial design concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 1を要約したもので、初期のデザインコンセプトを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That original summary may be found below under &quot;Random Thoughts&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>原文の概要は &quot;Random Thoughts&quot; 以下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>歴史的資料として凍結されるApocalypsesと違い、SynopsesはPerl 6の設計の更新も反映します 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの更新点は記録されません ― SynopsisがApocalypseと違う場合はSynopsisが正しいと見なして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another assumption has been that if we don't talk about something in these Synopses, it's the same as it is in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つの前提として、これらSynopsesで我々が話題にしないことはPerl5と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Soon we plan to fill in the gaps with the Perl 5 details though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もうすぐ我々はPerl 5の細部とのずれを埋める予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly, we're just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大抵の場合、我々は餌を巣に運ぶアリのような集団に過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主にボランティアによって、多くのグループが適当にこまごまとした仕事を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not attempt to summarize all these subprojects--see the various websites for Parrot and Pugs and Perl 6 for such information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはこれらのサブプロジェクトを全て要約するわけではありません。そのような情報はParrotやPugsやPerl 6のウェブサイトなどを参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が言えることは、Perl 5の場合と違ってこれらのプロジェクトは公式のPerlとは異なるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is anything that passes the official test suite.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公式のテストスイートをパスしたものは全てPerl 6なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This test suite was initially developed under the Pugs project because that project is the furthest along in exploring the high-level semantics of Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>当初、このテストスイートはPugsプロジェクトの元で開発されました。Perl 6の開発に関してPugsプロジェクトが最も先行していたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Other projects are better at other things, such as speed or interoperability.) However, the Pugs project views the test suite as community property, and is working towards platform neutrality, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(他のプロジェクトは速度や相互運用性などの面では優れています。)しかしPugsプロジェクトはテストスイートをコミュニティの所有物と考えており、プラットフォームに対して中立になることを目指しているので、このテストが動作するものをPerl 6とすることにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another aspect of this is the Perl 6 compiler will be self-hosting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の側面は、Perl 6コンパイラをセルフホスティングすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々なコード出力バックエンドが開発されたら、最終的にはコンパイラ自身をコンパイルするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは主にフロントエンドからプラットフォームの依存性を取り除き、バックエンドだけがプラットフォーム固有の問題を気にするようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &quot;apocalypse&quot; historically meant merely &quot;a revealing&quot;, and we're using it in that unexciting sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;apocalypse&quot; という言葉は歴史的には啓示することを意味します。我々はそのありきたりな意味で使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたがRFCを一般人に尋ねたら、興味深いが矛盾した多くのアイデアを得るでしょう。人々の意見は極端に分かれがちで、どのアイデアもお互いに構築することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry's First Law of Language Redesign: Everyone wants the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Larryによる新しい言語設計の最初の秩序：みんながcolonを望む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 2の要約で、小規模の字句項目と類型的問題を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(These Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &quot;historical documents&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Apocalypsesと違い、これらのSynopsesは時間と共に進化するPerl 6のデザインの更新を反映します。 Apocalypsesは歴史的資料としてある時点で凍結されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの更新は記録されません―SynopsisがApocalypseと異なるなら、Synopsisが正しいと見なして下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブ言語のパーサーによる拡張のために、Perlはワンパスの予測的パーサーによって解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, lookahead of more than one &quot;longest token&quot; is discouraged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり、複数の最長トークンの先読みは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これについて現在知られている例外は、パーサーが以下のようにしなければならない場合です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sigilで始まり、ブロックで終わる、または終わらないかもしれない展開式の終了位置を決定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recognize that a reduce operator is not really beginning a &lt;c0&gt;[...]&lt;/c0&gt; composer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>減少演算子が&lt;c0&gt;[...]&lt;/c0&gt;の生成を開始するとは限らないと認識する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>理論上はPerlはユニコードで記述され、基本的なテキスト表現に関係なく一貫したユニコードのセマンティクス(意味)を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default Perl presents Unicode in &quot;NFG&quot; formation, where each grapheme counts as one character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの書記素が1文字として数えられる場所では、PerlはデフォルトでユニコードをNFG形式で表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書記素とは初心者ユーザーが日常生活の中で考えると思われるあらゆる発音記号を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlはユニコードの行とパラグラフのセパレータを行マーカーとして数えることが出来ます。しかし、その振る舞いはあなたのエディタが考えるユニコードの行とPerlの行番号の考え方がマッチするように設定出来るべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコードの水平空白は空白として数えられます。しかし、単独のトークンに見えるような隣接したトークンを生成するような場所ではem幅の空白は使わないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方でPerlはインデントを文法として使わないので、空白が意味をなす場所ではいくらでも自由に空白を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは常に空白として数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの構文上の目的で、Perlは括弧でないものから括弧文字を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧文字は双方向対称かPs/Pe/Pi/Pfプロパティのどちらかのユニコード文字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実用上はPs/Pe/Pi/Pfプロパティの文字を使うのが最も安全ですが、ASCIIの不等号括弧はPs/Pe/Pi/Pfセットではないのに双方向なので注目すべき例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する閉じ文字がない文字は括弧の開始と見なされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはユニコードBidiMirroringデータテーブルの第2セクションを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字が既にPs/Pe/Pi/Pfマッピングで使用されている場合、どのBidiMirroringのエントリも無視されます（前方、後方マッピング両方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any given Ps character, the next Pe codepoint (in numerical order) is assumed to be its matching character even if that is not what you might guess using left-right symmetry.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のPs文字に対して次のPeコードポイント(番号順)は、たとえあなたが左右対称だと思っていなくてもマッチする文字と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore &lt;c0&gt;U+298D&lt;/c0&gt; maps to &lt;c1&gt;U+298E&lt;/c1&gt;, not &lt;c2&gt;U+2990&lt;/c2&gt;, and &lt;c3&gt;U+298F&lt;/c3&gt; maps to &lt;c4&gt;U+2990&lt;/c4&gt;, not &lt;c5&gt;U+298E&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って&lt;c0&gt;U+298D&lt;/c0&gt;は&lt;c2&gt;U+2990&lt;/c2&gt;ではなく&lt;c1&gt;U+298E&lt;/c1&gt;にマップされ、&lt;c3&gt;U+298F&lt;/c3&gt;は&lt;c5&gt;U+298E&lt;/c5&gt;ではなく&lt;c4&gt;U+2990&lt;/c4&gt;にマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither &lt;c6&gt;U+298E&lt;/c6&gt; nor &lt;c7&gt;U+2990&lt;/c7&gt; are valid bracket openers, despite having reverse mappings in the BidiMirroring table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;U+298E&lt;/c6&gt;と&lt;c7&gt;U+2990&lt;/c7&gt;はどちらも括弧の開始ではありません。にもかかわらずBidiMirroringテーブルに逆のマッピングを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;U+301D&lt;/c0&gt; codepoint has two closing alternatives, &lt;c1&gt;U+301E&lt;/c1&gt; and &lt;c2&gt;U+301F&lt;/c2&gt;; Perl 6 only recognizes the one with lower code point number, &lt;c3&gt;U+301E&lt;/c3&gt;, as the closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;U+301D&lt;/c0&gt;コードポイントは2つの代替の終了文字を持っています。&lt;c1&gt;U+301E&lt;/c1&gt;と&lt;c2&gt;U+301F&lt;/c2&gt;です。Perl 6は低いコードポイント数の&lt;c3&gt;U+301E&lt;/c3&gt;だけを閉じブレースとして認識します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This policy also applies to new one-to-many mappings introduced in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このポリシーは未来に登場する新しい1対多のマッピングにも適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, many-to-one mappings are fine; multiple opening characters may map to the same closing character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、多対1は構いません。複数の開始文字は同じ終了文字にマップするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, U+2018, U+201A, and U+201B may all be used as the opener for the U+2019 closer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばU+2018、U+201A、U+201Bは全てU+2019クローザーに対するオープナーとして使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs that count openers and closers assume that only the given opener is special.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オープナーとクローザーを考慮する構造は、与えられたオープナーだけが特別と見なします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if you open with one of the alternatives, all other alternatives are treated as non-bracketing characters within that construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり代替文字の1つで開く場合、他の代替文字はその構造では非括弧文字として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POD sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6ではPODセクションは複数行コメントとして確実に使用されるようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, POD syntax now lets you use &lt;c0&gt;=begin comment&lt;/c0&gt; and &lt;c1&gt;=end comment&lt;/c1&gt; delimit a POD block correctly without the need for &lt;c2&gt;=cut&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、現在のPOD構文は&lt;c0&gt;=begin comment&lt;/c0&gt;と&lt;c1&gt;=end comment&lt;/c1&gt;を&lt;c2&gt;=cut&lt;/c2&gt;無しでPODブロックを正しく区切って使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In fact, &lt;c3&gt;=cut&lt;/c3&gt; is now gone.) The format name does not have to be &lt;c4&gt;comment&lt;/c4&gt; -- any unrecognized format name will do to make it a comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(現に、&lt;c3&gt;=cut&lt;/c3&gt;は無くなりました。)フォーマット名は &lt;c4&gt;comment&lt;/c4&gt;である必要はありません。識別されないフォーマット名はコメントになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, bare &lt;c5&gt;=begin&lt;/c5&gt; and &lt;c6&gt;=end&lt;/c6&gt; probably aren't good enough, because all comments in them will show up in the formatted output.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(しかし、裸の&lt;c5&gt;=begin&lt;/c5&gt;と&lt;c6&gt;=end&lt;/c6&gt;ではおそらく不十分です。その中の全てのコメントがフォーマットされて表示されてしまうからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have single paragraph comments with &lt;c0&gt;=for comment&lt;/c0&gt; as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、単独のパラグラフコメント&lt;c0&gt;=for comment&lt;/c0&gt;があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That lets &lt;c1&gt;=for&lt;/c1&gt; keep its meaning as the equivalent of a &lt;c2&gt;=begin&lt;/c2&gt; and &lt;c3&gt;=end&lt;/c3&gt; combined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c1&gt;=for&lt;/c1&gt;を&lt;c2&gt;=begin&lt;/c2&gt;と&lt;c3&gt;=end&lt;/c3&gt;が結合したものと同等の意味を持つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with &lt;c4&gt;=begin&lt;/c4&gt; and &lt;c5&gt;=end&lt;/c5&gt;, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;=begin&lt;/c4&gt;と&lt;c5&gt;=end&lt;/c5&gt;のように、コメントはコードの前から後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is a newline before the first &lt;c0&gt;=&lt;/c0&gt;, the POD form of comment counts as whitespace equivalent to a newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の&lt;c0&gt;=&lt;/c0&gt;の前に改行が現れるまで、POD形式のコメントは改行と同様に空白としてカウントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みドキュメントの詳細はS26を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except within a string literal, a &lt;c0&gt;#&lt;/c0&gt; character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6では文字列リテラルを除いて、&lt;c0&gt;#&lt;/c0&gt;は常にコメントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two forms of comment based on &lt;c1&gt;#&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;#&lt;/c1&gt;を元にしたコメントは2つの形式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments require the &lt;c2&gt;#&lt;/c2&gt; to be followed by one or more opening bracketing characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントは1つかそれ以上の括弧の開始文字が続く&lt;c2&gt;#&lt;/c2&gt;を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other uses of &lt;c0&gt;#&lt;/c0&gt; are interpreted as single-line comments that work just as in Perl 5, starting with a &lt;c1&gt;#&lt;/c1&gt; character and ending at the subsequent newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その他の&lt;c0&gt;#&lt;/c0&gt;の使用はPerl 5のように1行コメントとして解釈され、&lt;c1&gt;#&lt;/c1&gt;で始まって次の改行で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは分割を目的とした改行と同じく空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, &lt;c2&gt;#&lt;/c2&gt; may &lt;i3&gt;not&lt;/i3&gt; be used as the delimiter in quoting constructs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、&lt;c2&gt;#&lt;/c2&gt;はクォートを構築する区切り文字としては使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded comments are supported as a variant on quoting syntax, introduced by &lt;c0&gt;#&lt;/c0&gt; plus any user-selected bracket characters (as defined in &lt;a1&gt;Lexical Conventions&lt;/a1&gt; above):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントはクォーティング構文の変化形としてサポートされ、&lt;c0&gt;#&lt;/c0&gt;とユーザーが選んだ括弧文字(&lt;a1&gt;Lexical Conventions&lt;/a1&gt;で定義されているもの)で導入されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧は普通の引用括弧と同じポリシーに沿ってネストするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There must be no space between the &lt;c0&gt;#&lt;/c0&gt; and the opening bracket character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の開始文字と&lt;c0&gt;#&lt;/c0&gt;の間に空白を置くことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There may be the &lt;i1&gt;visual appearance&lt;/i1&gt; of space for some double-wide characters, however, such as the corner quotes above.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(上記のかぎ括弧のように見栄えのあるダブルワイド文字がいくつかあります。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded comment is not allowed as the first thing on the line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行頭に埋め込みコメントを置くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to have a comment there, you must disambiguate it to either an embedded comment or a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそこにコメントを置きたいなら、埋め込みコメントか行コメントの曖昧さをなくす必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put a space in front of it to make it an embedded comment:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントにするために、前に空白を置くことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can put something other than a single &lt;c0&gt;#&lt;/c0&gt; to make it a line-end comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または行コメントにするために単一の&lt;c0&gt;#&lt;/c0&gt;以外のものを置くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if you are commenting out a block of code using the line-comment form, we recommend that you use &lt;c1&gt;##&lt;/c1&gt;, or &lt;c2&gt;#&lt;/c2&gt; followed by some whitespace, preferably a tab to keep any tab formatting consistent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って、もしコードブロックを行コメントを使ってコメントアウトするなら、空白(タブによるフォーマッティングを一貫するならタブが好ましい)が続く&lt;c1&gt;##&lt;/c1&gt;か&lt;c2&gt;#&lt;/c2&gt;を使うことをお勧めします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's often better to use pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、PODコメントは暗黙の行指向なのでそちらの方が良い場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if you have an intelligent syntax highlighter that will mark pod comments in a different color, there's less visual need for a &lt;c0&gt;#&lt;/c0&gt; on every line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに、もしあなたがPODコメントを色分けする賢いシンタックスハイライターを持っているなら、それぞれの&lt;c0&gt;#&lt;/c0&gt;の行に必要なビジュアルが少なくなってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザーが選んだ括弧のクォート構文で、複数の一致する括弧文字を使うことが出来ます。閉じ括弧は同じ数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧のネストは開き括弧と同じ数でなければ適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that bare circumfix or postcircumfix &lt;c0&gt;&lt;&lt;...&gt;&gt;&lt;/c0&gt; is not a user-selected bracket, but the ASCII variant of the &lt;c1&gt;«...»&lt;/c1&gt; interpolating word list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし注意として、裸の接周辞または後置接周辞&lt;c0&gt;&lt;&lt;...&gt;&gt;&lt;/c0&gt;はユーザー選択の括弧ではなく、&lt;c1&gt;«...»&lt;/c1&gt;のワードリストを展開したASCII形式の別記法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only &lt;c2&gt;#&lt;/c2&gt; and the &lt;c3&gt;q&lt;/c3&gt;-style quoters (including &lt;c4&gt;m&lt;/c4&gt;, &lt;c5&gt;s&lt;/c5&gt;, &lt;c6&gt;tr&lt;/c6&gt;, and &lt;c7&gt;rx&lt;/c7&gt;) enable subsequent user-selected brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;#&lt;/c2&gt;と&lt;c3&gt;q&lt;/c3&gt;スタイルのクォート(&lt;c4&gt;m&lt;/c4&gt;、&lt;c5&gt;s&lt;/c5&gt;、 &lt;c6&gt;tr&lt;/c6&gt;、&lt;c7&gt;rx&lt;/c7&gt;を含む)だけが後に続くユーザー選択の括弧を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C言語のようないくつかの言語は、行を結合するために改行をエスケープすることを認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の言語(正規表現など)は空白文字のバックスラッシュを様々な理由で認めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はこの概念をあらゆる種類の空白に一般化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with &lt;c0&gt;\&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる連続する空白(コメント含む)は&lt;c0&gt;\&lt;/c0&gt;を前置することによってパーサーから隠蔽されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as the &quot;unspace&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはunspaceとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはPerlの様々な空白のいずれかの依存関係を隠することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばPerlは名詞と後置演算子の間に空白が無いことを要求するので、unspaceを使うことで後置演算子を繋げることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の使い方をサポートするための特別な場合として、後置演算子が期待される場所でのバックスラッシュはunspaceの変質した形式と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意として、それの前に空白は置けません。そのため</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は構文エラーです(行に2つの項)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will be parsed as a list operator with a &lt;c0&gt;Capture&lt;/c0&gt; argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は&lt;c0&gt;Capture&lt;/c0&gt;引数を伴うリスト演算子と解析されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、他の形式のunspaceは空白の前にきて役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それ故に単項のバックスラッシュの使われ方は空白が続かないこと、または空白をunspaceと受け取ることです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の後置演算子もunspaceを活用できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つ見えない空白の使い方は、典型的にはドット後置演算子を次の行に置くことです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But unspace is mainly about language extensibility: it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしunspaceは主に言語の拡張性に関するものです。あなたが現在インストールしているパーサーに関わらず、改行がパーサーを混乱させるかもしれないあらゆる場面で行を継続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, you override the unspace rule itself...)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろん、あなたがunspaceのルール自体を上書きすれば別ですが・・・)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、unspaceはパーサーから空白を隠しますが、レクサーからは隠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果として、unspaceはトークンとして認められません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceが1つ以上の改行を含むなら依然として行番号がカウントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;#&lt;/c0&gt; following such a newline is always an end-of-line comment, as described above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような改行に続く&lt;c0&gt;#&lt;/c0&gt;は上に述べたように常に行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Podチャンク(かたまり)は言語にとって空白として数えられるので、それもunspaceによって取り込むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントの境界は隠蔽されます。けれども、あなたは過度に長いヒアドキュメントの出だしの行をこのように分割できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヒアドキュメントのパーサーは単にこのように見ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is one of those cases in which it is fine to have whitespace before the unspace, since we're only trying to suppress the newline transition, not all whitespace as in the case of postfix parsing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意として、これはunspaceの前に空白を置いても構わないケースの1つです。なので接尾辞の解析については我々は全ての空白ではなく改行の変わり目を隠そうと試みているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that the example above is not meant to spec how the test suite works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(さらに注意として、上記の例はテストスイートの動作仕様を意図していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはコメントを含むかもしれませんが、コメントはunspaceを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、行コメントはバックスラッシュを意味のあるものとして扱いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is an end-of-line comment, not an embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みコメントではなく行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のように書くと:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に、単独のトークンか他の構文上の単位と間違って解釈される構成を分離する必要がある場所を除いて、Perl 6での空白は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, Perl 6 follows the standard &lt;i0&gt;longest-token&lt;/i0&gt; principle, or in the cases of large constructs, a &lt;i1&gt;prefer shifting to reducing&lt;/i1&gt; principle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、Perl 6は標準の&lt;i0&gt;最長トークン&lt;/i0&gt;の原則、または大きな構文の場合は&lt;i1&gt;prefer shifting to reducing&lt;/i1&gt;の原則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a2&gt;Grammatical Categories&lt;/a2&gt; below for more on how a Perl program is analyzed into tokens.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlプログラムがどのようにトークンに解析されるか、詳細については&lt;a2&gt;Grammatical Categories&lt;/a2&gt;を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは不変の深いルールです。しかしPerl 6は可変の言語となるように設計されているので、様々な演算子や言語にマクロを追加したり削除することで表面上の悪影響を変えるということが起こるのを我々は期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、項の後で後置演算子と2項演算子の間の自然な競合がどちらかで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし与えられたトークンが後置演算子か2項演算子と解釈されそうなら、2項演算子の前に空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置演算子は間に入る空白を持ちませんが、間に入るドットを持つことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上で分離が望まれるなら、空白がunspaceか埋め込みコメントの外側に発生しない限り前述のunspaceか埋め込みコメントが使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you were to add your own &lt;c0&gt;infix:&lt;++&gt;&lt;/c0&gt; operator, then it must have space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えばあなたの&lt;c0&gt;infix:&lt;++&gt;&lt;/c0&gt;という2項演算子を追加するとしたら、その前に必ず空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal autoincrementing &lt;c1&gt;postfix:&lt;++&gt;&lt;/c1&gt; operator may never have space before it, but may be written in any of these forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準の自動インクリメント&lt;c1&gt;postfix:&lt;++&gt;&lt;/c1&gt;演算子はその前に空白を持ちませんが、これらの形式のどれかで書かれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on &lt;c0&gt;$_&lt;/c0&gt; where a term is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(クォートを区切るかunspaceを終了することは除いて)項が期待される場所で前に空白があるドットは常に&lt;c0&gt;$_&lt;/c0&gt;のメソッド呼び出しとみなされます。 それが接尾辞のルールの結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その箇所で項が期待されていないなら、それは構文エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろんドットで始まる名前の2項演算子があるなら別ですが。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could, for instance, define a Fortranly &lt;c1&gt;infix:&lt;.EQ.&gt;&lt;/c1&gt; if the fit took you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、その気になればFortran風の&lt;c1&gt;infix:&lt;.EQ.&gt;&lt;/c1&gt;を定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしあなたはそれの前に常に空白を置くか、代わりに後置メソッド呼び出しと解釈されるようにして気をつけなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に次のように解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のいくつかの変化形を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし後置のメソッド呼び出しを意味するなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of all this is that you may no longer write a Num as &lt;c0&gt;42.&lt;/c0&gt; with just a trailing dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これら全ての内の1つの結果として、ただの終端ドットを伴うNumを &lt;c0&gt;42.&lt;/c0&gt;として書くことはもはやできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must instead say either &lt;c1&gt;42&lt;/c1&gt; or &lt;c2&gt;42.0&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりにあなたは&lt;c1&gt;42&lt;/c1&gt;か&lt;c2&gt;42.0&lt;/c2&gt;のどちらかにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば、もし直後の文字が数字なら、数の直後のドットは小数点にしかなり得ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、後置のドットはいくつかの種類のメソッド呼び出し構文の開始と取られるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c3&gt;.123&lt;/c3&gt; form with a leading dot is still allowed however when a term is expected, and is equivalent to &lt;c4&gt;0.123&lt;/c4&gt; rather than &lt;c5&gt;$_.123&lt;/c5&gt;.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(項が期待される場合でも、直前のドットを伴う&lt;c3&gt;.123&lt;/c3&gt;形式がまだ認められています。そしてそれは&lt;c5&gt;$_.123&lt;/c5&gt;ではなく&lt;c4&gt;0.123&lt;/c4&gt;と同じです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In support of OO encapsulation, there is a new fundamental datatype: &lt;s0&gt;P6opaque&lt;/s0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト指向カプセル化のサポートの中で、新しい基本データ型があります: &lt;s0&gt;P6opaque&lt;/s0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>opaqueオブジェクトへの外部からのアクセスは常にメソッド呼び出しを通して行われます。属性でさえそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はより安全でより良く動作するコードを書くことを助ける選択自由な型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがあなたの提供可能な型情報を推測するのは自由です。しかしあなたが尋ねない限り、欠落した型情報について文句を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は構造的な等価性よりも名前の等価性で正式に比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、我々は名前を考えることに寛大であることを好みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &quot;anonymous&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、名前は型を定義するモジュールに関連付けられたバージョンと権限を含みます(たとえ型自体が無名でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &quot;long name&quot; of the resulting type, so one &lt;c0&gt;Array of Int&lt;/c0&gt; is equivalent to another &lt;c1&gt;Array of Int&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上でパラメータを伴う型をインスタンス化する場合、引数は結果となる型の長い名前の一部と考えられるので、ある&lt;c0&gt;Array of Int&lt;/c0&gt;は他の&lt;c1&gt;Array of Int&lt;/c1&gt;と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Another way to look at it is that the type instantiation &quot;factory&quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それを調べるもう一つの方法は、型をインスタンス化するファクトリーがメモ化されることです。)型名の別名は元の型と同等とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the &lt;c2&gt;Array of Int&lt;/c2&gt; syntax is just sugar for &lt;c3&gt;Array:of(Int)&lt;/c3&gt;, which is the canonical form of an instantiated generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に&lt;c2&gt;Array of Int&lt;/c2&gt;という構文はインスタンス化されたジェネリックタイプの正規形である&lt;c3&gt;Array:of(Int)&lt;/c3&gt;の単なるシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このパラメータを伴う型の名前の等価性は不変(または少なくとも不変のスナップショットを撮ることが出来る)とみなせるパラメータだけを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別個の2つのクラスはたとえ同じ属性を持っていても決して同等とは見なされません。なぜならクラスは不変とみなされないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of &lt;s0&gt;properties&lt;/s0&gt; on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は様々な種類のオブジェクトで&lt;s0&gt;プロパティ&lt;/s0&gt;の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのクラスではなく個々のオブジェクトに管理されている場合を除いて、プロパティはオブジェクトの属性に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S12に従って、プロパティは実際にはミックスインメカニズムのようなもので実装され、そのようなミックスインはオブジェクトに対する個々の無名クラスの生成によって完成します(同じ無名クラスがまだ存在せず、安全に共有できるのであれば)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called &lt;s0&gt;traits&lt;/s0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティはコンパイル時に構成される変数やクラスなどに適用され、&lt;s0&gt;トレイト&lt;/s0&gt;とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トレイトを実行時に変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時のプロパティの変更は代わりにミックスインによって行われます。これによってコンパイラーは宣言されたトレイトを元に最適化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンですが、都合が悪いならオブジェクト指向で考える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ファイルハンドルのようないくつかのビルトインの概念はPerl 5以上にユーザーに見える形でオブジェクト指向的になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数の型とは、変数がどのような値を含む可能性があるかを示す制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &quot;role&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より正確には、オブジェクトまたは変数に格納されたオブジェクトがroleで示されたメソッドに応答できることの保証です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数自体はどの種類のものを含むか指定せず、どのように動作するかを指定するコンテナ型にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制約とコンテナ型は一緒に使用することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;$x&lt;/c0&gt; is also initialized to the &lt;c1&gt;Int&lt;/c1&gt; type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;$x&lt;/c0&gt;が&lt;c1&gt;Int&lt;/c1&gt;型オブジェクトで初期化されることにも注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これについて詳しくは以下を見て下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt; by itself does not automatically call a &lt;c1&gt;Dog&lt;/c1&gt; constructor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt;自体は&lt;c1&gt;Dog&lt;/c1&gt;のコンストラクターを自動で呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined &lt;c2&gt;Dog&lt;/c2&gt; prototype object to &lt;c3&gt;$spot&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは単に未定義の&lt;c2&gt;Dog&lt;/c2&gt;プロトタイプオブジェクトを&lt;c3&gt;$spot&lt;/c3&gt;に割り当てます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is an undefined instance of that type's prototype object, or &lt;i0&gt;type object&lt;/i0&gt; for short.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値として使われる任意の型名はその型の未定義のプロトタイプオブジェクト、短くはタイプオブジェクトのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの詳細についてはS12を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>右辺コンテキストでの型名は単独の型の値としてパースされ、それに続く引数がないことを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしタイプオブジェクトは関数呼び出しインターフェースに応答するので、あなたは型の名前を括弧と一緒に関数であるかのように使用するでしょう。そして呼び出しに供給されるどんな引数もタイプオブジェクトの示す型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしも括弧に引数が無いなら、タイプオブジェクト自身を返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a real &lt;c0&gt;Dog&lt;/c0&gt; object, call a constructor method such as &lt;c1&gt;new&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当の&lt;c0&gt;Dog&lt;/c0&gt;オブジェクトを得るために、&lt;c1&gt;new&lt;/c1&gt;のようなコンストラクタメソッドを呼んで下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様にコンストラクタに引数を渡すことも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが次のようにするなら:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you are declaring that the elements of &lt;c0&gt;@array&lt;/c0&gt; are native integers, but that the array itself is implemented by the &lt;c1&gt;MyArray&lt;/c1&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;@array&lt;/c0&gt;の要素をネイティブ整数と宣言しますが、配列自身は&lt;c1&gt;MyArray&lt;/c1&gt;クラスで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型指定されていない配列とハッシュはいまだに何でも受け入れますが、Perl 5と同じパフォーマンスの問題を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the &lt;c0&gt;.elems&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の要素数を得るには&lt;c0&gt;.elems&lt;/c0&gt;メソッドを使用して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also ask for the total string length of an array's elements, in bytes, codepoints or graphemes, using these methods &lt;c1&gt;.bytes&lt;/c1&gt;, &lt;c2&gt;.codes&lt;/c2&gt; or &lt;c3&gt;.graphs&lt;/c3&gt; respectively on the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;c1&gt;.bytes&lt;/c1&gt;、&lt;c2&gt;.codes&lt;/c2&gt;、&lt;c3&gt;.graphs&lt;/c3&gt;メソッドを使用してバイト、コードポイント、書記素でそれぞれの配列要素の文字列の長さの合計を求めることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に文字列にも同じメソッドを適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that &lt;c4&gt;.bytes&lt;/c4&gt; is not guaranteed to be well-defined when the encoding is unknown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c4&gt;.bytes&lt;/c4&gt;はエンコーディングが不明な場合は明確には保証されないので注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c5&gt;.codes&lt;/c5&gt; is not well-defined unless you know which canonicalization is in effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、&lt;c5&gt;.codes&lt;/c5&gt;はどの正規化が有効なのか不明な場合は明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, both methods allow an optional argument to specify the meaning exactly if it cannot be known from context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのため、両方のメソッドはコンテキストから知ることができない場合に正確な意味を指定するための任意の引数を受け入れます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no &lt;c0&gt;.length&lt;/c0&gt; method for either arrays or strings, because &lt;c1&gt;length&lt;/c1&gt; does not specify a unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;.length&lt;/c0&gt;メソッドは配列と文字列のどちらにもありません。なぜなら&lt;c1&gt;length&lt;/c1&gt;は単位を指定しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルトインオブジェクト型は大文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes immutable types (e.g. &lt;c0&gt;Int&lt;/c0&gt;, &lt;c1&gt;Num&lt;/c1&gt;, &lt;c2&gt;Complex&lt;/c2&gt;, &lt;c3&gt;Rat&lt;/c3&gt;, &lt;c4&gt;Str&lt;/c4&gt;, &lt;c5&gt;Bit&lt;/c5&gt;, &lt;c6&gt;Regex&lt;/c6&gt;, &lt;c7&gt;Set&lt;/c7&gt;, &lt;c8&gt;Block&lt;/c8&gt;, &lt;c9&gt;List&lt;/c9&gt;, &lt;c10&gt;Seq&lt;/c10&gt;), as well as mutable (container) types, such as &lt;c11&gt;Scalar&lt;/c11&gt;, &lt;c12&gt;Array&lt;/c12&gt;, &lt;c13&gt;Hash&lt;/c13&gt;, &lt;c14&gt;Buf&lt;/c14&gt;, &lt;c15&gt;Routine&lt;/c15&gt;, &lt;c16&gt;Module&lt;/c16&gt;, and non-instantiable Roles such as &lt;c17&gt;Callable&lt;/c17&gt;, &lt;c18&gt;Failure&lt;/c18&gt;, and &lt;c19&gt;Integral&lt;/c19&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変更不可の型を含みます(&lt;c0&gt;Int&lt;/c0&gt;、&lt;c1&gt;Num&lt;/c1&gt;、&lt;c2&gt;Complex&lt;/c2&gt;、&lt;c3&gt;Rat&lt;/c3&gt;、&lt;c4&gt;Str&lt;/c4&gt;、&lt;c5&gt;Bit&lt;/c5&gt;、&lt;c6&gt;Regex&lt;/c6&gt;、&lt;c7&gt;Set&lt;/c7&gt;、&lt;c8&gt;Block&lt;/c8&gt;、&lt;c9&gt;List&lt;/c9&gt;、&lt;c10&gt;Seq&lt;/c10&gt;など)。変更可能な(コンテナ)型も同様です。&lt;c11&gt;Scalar&lt;/c11&gt;、&lt;c12&gt;Array&lt;/c12&gt;、&lt;c13&gt;Hash&lt;/c13&gt;、&lt;c14&gt;Buf&lt;/c14&gt;、&lt;c15&gt;Routine&lt;/c15&gt;、&lt;c16&gt;Module&lt;/c16&gt;など。そしてインスタンス化できない&lt;c17&gt;Callable&lt;/c17&gt;、&lt;c18&gt;Failure&lt;/c18&gt;、&lt;c19&gt;Integral&lt;/c19&gt;なども同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-object (native) types are lowercase: &lt;c0&gt;int&lt;/c0&gt;, &lt;c1&gt;num&lt;/c1&gt;, &lt;c2&gt;complex&lt;/c2&gt;, &lt;c3&gt;rat&lt;/c3&gt;, &lt;c4&gt;buf&lt;/c4&gt;, &lt;c5&gt;bit&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトでない(ネイティブ)型は小文字です: &lt;c0&gt;int&lt;/c0&gt;、&lt;c1&gt;num&lt;/c1&gt;、&lt;c2&gt;complex&lt;/c2&gt;、&lt;c3&gt;rat&lt;/c3&gt;、&lt;c4&gt;buf&lt;/c4&gt;、&lt;c5&gt;bit&lt;/c5&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型は主にコンパクトな配列ストレージを宣言するためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、Perlはそれらを対応する大文字の型のように扱えるようにしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it does autoboxing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(言い換えれば、自動ボックス化を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that sometimes repeated autoboxing can slow your program more than the native type can speed it up.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、自動ボックス化の繰り返しがネイティブ型のスピードアップ以上にプログラムを遅くすることもあるので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;junction&lt;/c0&gt; type is considered a native type because its internal representation is fixed, and you may not usefully derive from it because the intent of junctions is to autothread any method calls on them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内部表現が固定されているので、&lt;c0&gt;junction&lt;/c0&gt;型はネイティブ型と見なされます。そしてjunctionの意図はあらゆるメソッド呼び出しを自動スレッド化することなので、それから有益に派生させることはできないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのオブジェクトは値型として振る舞うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a &quot;WHICH&quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトはハッシュと値ベースの比較のために一意に識別するためのWHICH値を出力できます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal objects just use their address in memory, but if a class wishes to behave as a value type, it can define a &lt;c0&gt;.WHICH&lt;/c0&gt; method that makes different objects look like the same object if they happen to have the same contents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常のオブジェクトはそれらのメモリアドレス使うだけですが、クラスが値型として振る舞いたい場合に、異なるオブジェクトが同じ内容を持つ場合が発生するなら同じオブジェクトのように見せる&lt;c0&gt;.WHICH&lt;/c0&gt;メソッドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with non-native types can always contain &lt;i0&gt;undefined&lt;/i0&gt; values, such as &lt;c1&gt;Object&lt;/c1&gt;, &lt;c2&gt;Whatever&lt;/c2&gt; and &lt;c3&gt;Failure&lt;/c3&gt; objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型を伴う変数は常に&lt;c1&gt;Object&lt;/c1&gt;、&lt;c2&gt;Whatever&lt;/c2&gt;、&lt;c3&gt;Failure&lt;/c3&gt;オブジェクトなどの&lt;i0&gt;undefined&lt;/i0&gt;値を含むことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S04 for more about failures (i.e. unthrown exceptions):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>failures(例えばunthrown exceptionsなど)の詳細についてはS04を参照して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型を伴う変数は未定義をサポートしません: 未定義値をそれらに割り当てるとエラーになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測: numはundefからNaNへの自動変換をサポートするかもしれないので、浮動小数点形式はこの概念を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ロケットの設計者が自己破壊を即座に行うかその後間もなく行うか決めることが出来るように、その変換を任意に出来るなら良いかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables of non-native types start out containing an undefined value unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ネイティブ型は明示的に定義された値で初期化されなければ未定義値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object supports a &lt;c0&gt;HOW&lt;/c0&gt; function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのオブジェクトは、オブジェクトが定義されているかどうかに関わらずそれを管理するメタクラスのインスタンスを返す&lt;c0&gt;HOW&lt;/c0&gt;関数/メソッドをサポートします: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(プロトタイプシステム(クラスベースでないオブジェクトシステム)のために、全てのオブジェクトは単に同じメタオブジェクトによって管理されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は型宣言のシステムを通してbig integersとbig rationalsを本質的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int&lt;/c0&gt; automatically supports promotion to arbitrary precision, as well as holding &lt;c1&gt;Inf&lt;/c1&gt; and &lt;c2&gt;NaN&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Int&lt;/c0&gt;は&lt;c1&gt;Inf&lt;/c1&gt;値と&lt;c2&gt;NaN&lt;/c2&gt;値を保持するのと同様に任意の精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c3&gt;Int&lt;/c3&gt; assumes 2's complement arithmetic, so &lt;c4&gt;+^1 == -2&lt;/c4&gt; is guaranteed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;Int&lt;/c3&gt;は2の補数演算を想定することに注意して下さい。なので&lt;c4&gt;+^1 == -2&lt;/c4&gt;が保証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Native &lt;c5&gt;int&lt;/c5&gt; operations need not support this on machines that are not natively 2's complement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ネイティブの&lt;c5&gt;int&lt;/c5&gt;演算は2の補数をネイティブにサポートしていないマシンではサポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must convert to and from &lt;c6&gt;Int&lt;/c6&gt; to do portable bitops on such ancient hardware.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c6&gt;Int&lt;/c6&gt;への変換や逆のことをそのような古いハードウェアで移植性のあるビット演算に出来るようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;c0&gt;Num&lt;/c0&gt; may support arbitrary-precision floating-point arithmetic, but is not required to unless we can do so portably and efficiently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c0&gt;Num&lt;/c0&gt;は任意の精度の浮動小数点演算をサポートします。しかし移植性があり効率的に行うことが出来ないのであれば必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;Num&lt;/c1&gt; must support the largest native floating point format that runs at full speed.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;Num&lt;/c1&gt;は最も大きいネイティブ浮動小数点フォーマットをフルスピードで実行できるようにサポートしなければなりません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt; supports arbitrary precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;は任意の精度の有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, dividing two &lt;c1&gt;Int&lt;/c1&gt; objects using &lt;c2&gt;infix:&lt;/&gt;&lt;/c2&gt; produces a fraction of &lt;c3&gt;Num&lt;/c3&gt; type, not a ratio.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、2つの&lt;c1&gt;Int&lt;/c1&gt;オブジェクトを&lt;c2&gt;infix:&lt;/&gt;&lt;/c2&gt;で除算するとレシオではなく&lt;c3&gt;Num&lt;/c3&gt;型の端数を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can produce a ratio by using &lt;c4&gt;infix:&lt;div&gt;&lt;/c4&gt; on two integers instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに&lt;c4&gt;infix:&lt;div&gt;&lt;/c4&gt;を使ってレシオを生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lower-case types like &lt;c0&gt;int&lt;/c0&gt; and &lt;c1&gt;num&lt;/c1&gt; imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;int&lt;/c0&gt;、&lt;c1&gt;num&lt;/c1&gt;のような小文字型はマシンネイティブの整数と浮動小数点表現を意味します。それぞれは任意の精度へ昇格しませんが、テンポラリ値についてはより大きい表現が常に許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless qualified with a number of bits, &lt;c2&gt;int&lt;/c2&gt; and &lt;c3&gt;num&lt;/c3&gt; types represent the largest native integer and floating-point types that run at full speed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット数で制限されなければ、&lt;c2&gt;int&lt;/c2&gt;と&lt;c3&gt;num&lt;/c3&gt;型はフルスピードで実行される最も大きな整数と浮動小数点を表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric values in untyped variables use &lt;c0&gt;Int&lt;/c0&gt; and &lt;c1&gt;Num&lt;/c1&gt; semantics rather than &lt;c2&gt;int&lt;/c2&gt; and &lt;c3&gt;num&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型のない変数での数値は&lt;c0&gt;Int&lt;/c0&gt;と&lt;c1&gt;Num&lt;/c1&gt;を&lt;c2&gt;int&lt;/c2&gt;と&lt;c3&gt;num&lt;/c3&gt;より優先して使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 should by default make standard IEEE floating point concepts visible, such as &lt;c0&gt;Inf&lt;/c0&gt; (infinity) and &lt;c1&gt;NaN&lt;/c1&gt; (not a number).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はデフォルトで&lt;c0&gt;Inf&lt;/c0&gt;(無限)と&lt;c1&gt;NaN&lt;/c1&gt;(数でない)のような標準のIEEE小数点概念を見えるようにするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープ内でプラグマはテンポラリ値の性質、そして様々な環境下で浮動小数点がどの様に振る舞うか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>うまく機能しないプラットフォームを回避するために壮大な努力を必要とする場合を除いて、全てのIEEEモードがプラグマによってレキシカルに使用可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルトの浮動小数点モードは例外をスローするのではなくInfとNaNを伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ボックス化されたオブジェクト型はオーバーフローかアンダーフローが発生したところでより詳細な情報を伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlでの計算法はどこでも同じ答えを与えるように設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are designed to give the typical programmer the tools to achieve a good enough answer most of the time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは一般的なプログラマーにほとんどの場合十分な答えを果たすツールを与えるように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(本当によいプログラマーは時折もっと良く行います。)大抵、これは重要でないアルゴリズムの愚かさに十分なビットの使用を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Str&lt;/c0&gt; is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native &lt;c1&gt;str&lt;/c1&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応するネイティブ&lt;c1&gt;str&lt;/c1&gt;型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since a &lt;c2&gt;Str&lt;/c2&gt; object may fill multiple roles, we say that a &lt;c3&gt;Str&lt;/c3&gt; keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし&lt;c2&gt;Str&lt;/c2&gt;オブジェクトは複数のロールを果たすので、&lt;c3&gt;Str&lt;/c3&gt;はユニコードの抽象レベルで最小と最大のトラックを保持し、現在のレキシカルスコープの考える理想的な文字に沿ってうまく演じます。バイト、コードポイント、 書記素またはいくつかの言語の文字であるかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all &lt;c4&gt;Str&lt;/c4&gt; positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての組み込み操作について、全ての&lt;c4&gt;Str&lt;/c4&gt;の位置はポジションオブジェクトとして報告され、整数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;c5&gt;StrPos&lt;/c5&gt; objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;StrPos&lt;/c5&gt;オブジェクトは特定の文字列の特定の場所を抽象化レベルに依存せずポイントします。文字列と位置を直接に追跡するか、あらゆるコンテキストで同じ文字列に適用される同じ結果を与える文字列の始まりのオフセットを抽象化に依存しない表現で出力するかどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is assuming the string isn't modified in the meanwhile; a &lt;c6&gt;StrPos&lt;/c6&gt; is not a &quot;marker&quot; and is not required to follow changes to a mutable string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはその間に文字列が変更されないと仮定します;&lt;c6&gt;StrPos&lt;/c6&gt;は&quot;マーカー&quot;ではなく、変更される文字列を追跡する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、置換された文字列の位置を求めるとしたら、その答えは元の文字列のものです(今はアクセスできないでしょう！)。 変更された文字列のものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポジションオブジェクトが期待されるところで整数を使用すると、現在のレキシカルスコープのユニコード抽象化レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(デフォルトはgraphemesです。)それ以外は適切な単位を強要する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろんそのような次元数は文字列が適切な抽象化レベルを提供しないなら失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような次元的でない数を間違った単位で解釈するルーチンに渡すのは間違っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Buf&lt;/c0&gt; is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of &lt;c1&gt;Str&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Buf&lt;/c0&gt;は文字列的な整数の配列です。明示的にいくつかの種類の&lt;c1&gt;Str&lt;/c1&gt;に変換されるのでなければユニコードか文字のプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A &lt;c2&gt;buf&lt;/c2&gt; is the native counterpart.) Typically it's an array of bytes serving as a buffer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c2&gt;buf&lt;/c2&gt;はネイティブ対応です。)通常はバッファを受け取るためのバイト列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a &lt;c3&gt;Buf&lt;/c3&gt; treat the entire buffer as a single large integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;Buf&lt;/c3&gt;のビット演算は一つの巨大な整数として扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operations on a &lt;c4&gt;Str&lt;/c4&gt; generally fail unless the &lt;c5&gt;Str&lt;/c5&gt; in question can provide an abstract &lt;c6&gt;Buf&lt;/c6&gt; interface somehow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;Str&lt;/c4&gt;のビット演算は普通は失敗します。&lt;c5&gt;Str&lt;/c5&gt;が &lt;c6&gt;Buf&lt;/c6&gt;の抽象インターフェースを何とか提供しなければ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercion to &lt;c7&gt;Buf&lt;/c7&gt; should generally invalidate the &lt;c8&gt;Str&lt;/c8&gt; interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;Buf&lt;/c7&gt;への強制は一般的には&lt;c8&gt;Str&lt;/c8&gt;のインターフェースを無効にするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a generic type &lt;c9&gt;Buf&lt;/c9&gt; may be instantiated as (or bound to) any of &lt;c10&gt;buf8&lt;/c10&gt;, &lt;c11&gt;buf16&lt;/c11&gt;, or &lt;c12&gt;buf32&lt;/c12&gt; (or to any type that provides the appropriate &lt;c13&gt;Buf&lt;/c13&gt; interface), but when used to create a buffer &lt;c14&gt;Buf&lt;/c14&gt; defaults to &lt;c15&gt;buf8&lt;/c15&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ジェネリック型としての&lt;c9&gt;Buf&lt;/c9&gt;は&lt;c10&gt;buf8&lt;/c10&gt;、&lt;c11&gt;buf16&lt;/c11&gt;、&lt;c12&gt;buf32&lt;/c12&gt;のどれか(または&lt;c13&gt;Buf&lt;/c13&gt;の適切なインターフェースを提供する何かの型)によってインスタンス化（またはバインド）されます。バッファとして使われる時の&lt;c14&gt;Buf&lt;/c14&gt;のデフォルトは&lt;c15&gt;buf8&lt;/c15&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは必ずしもバイト位置ではありません ― 整数位置は単に基礎的な位置の数を数えるだけです。それはあるセルを意味するある位置の基礎的な整数型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;utf8&lt;/c0&gt; type is derived from &lt;c1&gt;buf8&lt;/c1&gt;, with the additional constraint that it may only contain validly encoded UTF-8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;utf8&lt;/c0&gt;型は&lt;c1&gt;buf8&lt;/c1&gt;型から派生し、正当にエンコードされたUTF-8だけであるという追加の制約があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, &lt;c2&gt;utf16&lt;/c2&gt; is derived from &lt;c3&gt;buf16&lt;/c3&gt;, and &lt;c4&gt;utf32&lt;/c4&gt; from &lt;c5&gt;buf32&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に&lt;c2&gt;utf16&lt;/c2&gt;は&lt;c3&gt;buf16&lt;/c3&gt;から派生し、&lt;c4&gt;utf32&lt;/c4&gt;は&lt;c5&gt;buf32&lt;/c5&gt;から派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは型名なので、リスト演算形式は制約には許可されないので、それらを制約として呼び出すために必ず括弧が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は常に次のようにパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして以下のようにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;*&lt;/c0&gt; character as a standalone term captures the notion of &quot;Whatever&quot;, which is applied lazily by whatever operator it is an argument to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項の文字&lt;c0&gt;*&lt;/c0&gt;は&quot;何でも&quot;という概念をとらえます。それはwhatever演算子が引数にいい加減に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally it can just be thought of as a &quot;glob&quot; that gives you everything it can in that argument position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的にはそれは引数の位置に何でも与える&quot;glob&quot;と考えることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Whatever&lt;/c0&gt; is an undefined prototype object derived from &lt;c1&gt;Any&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Whatever&lt;/c0&gt;は&lt;c1&gt;Any&lt;/c1&gt;を継承した未定義のプロトタイプオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としては抽象型で、定義されたオブジェクトとしてインスタンス化されないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例外が理にかなっていると考えないなら、理にかなった答えが与えられると期待しない方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the &lt;c0&gt;Whatever&lt;/c0&gt; object is effectively immutable, the optimizer is free to recognize &lt;c1&gt;*&lt;/c1&gt; and optimize in the context of what operator it is being passed to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Whatever&lt;/c0&gt;オブジェクトは不変なので、オプティマイザは &lt;c1&gt;*&lt;/c1&gt;を自由に認識することができ、どの演算子に渡されるのかコンテキストの中で最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces a function of a single argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数1つの関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the single dispatcher recognizes &lt;c0&gt;*.meth&lt;/c0&gt; and returns &lt;c1&gt;{ $_.meth }&lt;/c1&gt;, so it can be used where patterns are expected:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に単一のディスパッチャーは&lt;c0&gt;*.meth&lt;/c0&gt;を認識して&lt;c1&gt;{ $_.meth }&lt;/c1&gt;を返すので、そのパターンが期待される場所で使用することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These closures are of type &lt;c0&gt;Code:($)&lt;/c0&gt;, not &lt;c1&gt;Whatever&lt;/c1&gt;, so that constructs can distinguish via multiple dispatch:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Code:($)&lt;/c0&gt;はクロージャー型で&lt;c1&gt;Whatever&lt;/c1&gt;ではないので、構造はマルチディスパッチによって区別できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bare &lt;c0&gt;*&lt;/c0&gt; form may also be called as a function, and represents the identify function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸の&lt;c0&gt;*&lt;/c0&gt;形式は関数としても呼ぶことができ、関数の識別を表します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that this is &lt;i0&gt;not&lt;/i0&gt; what is happening above, or</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこれは上で起こっていることではありません。または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would end up meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は以下を意味することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;...&lt;/c0&gt; operator is instead dispatching bare &lt;c1&gt;*&lt;/c1&gt; to a routine that does dwimmery, and in this case decides to supply a function { * + 1 }.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;...&lt;/c0&gt;演算子は代わりに&lt;c1&gt;*&lt;/c1&gt;を期待通りに動作するルーチンにディスパッチしています。そしてこの場合は関数{ * + 1 }を供給すると決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore &lt;c0&gt;@array[^**]&lt;/c0&gt; represents &lt;c1&gt;@array[{ map { ^* }, @_ }]&lt;/c1&gt;, that is to say, every element of the array, no matter how many dimensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って&lt;c0&gt;@array[^**]&lt;/c0&gt;は&lt;c1&gt;@array[{ map { ^* }, @_ }]&lt;/c1&gt;を表し、配列の次元数を問わない配列の全要素ということになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, &lt;c2&gt;@array[**]&lt;/c2&gt; means the same thing because (as with &lt;c3&gt;...&lt;/c3&gt; above), the subscript operator will interpret bare &lt;c4&gt;**&lt;/c4&gt; as meaning all the subscripts, not the list of dimension sizes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ただし&lt;c2&gt;@array[**]&lt;/c2&gt;は同じことを意味します。なぜなら (&lt;c3&gt;...&lt;/c3&gt;で述べたように)添字演算子は裸の&lt;c4&gt;**&lt;/c4&gt;を全ての添字と解釈し、次元のサイズのリストとは解釈しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがそうでなければ、これらはMMDシステムによって意味を与えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型の値は、それらの対になる大文字の型のオブジェクトとして扱われる時はautobox化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including &lt;c0&gt;bit&lt;/c0&gt;) default to 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型はPerlの概念の未定義値を表現できないので、明確な初期化がなければネイティブ浮動小数点はデフォルトでNaN、整数（&lt;c0&gt;bit&lt;/c0&gt;含む)はデフォルトで0になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>complex型のデフォルトはNaN + NaN\iです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既知のサイズのbuf型は0の値のシーケンスがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any native type is explicitly initialized to &lt;c1&gt;*&lt;/c1&gt; (the &lt;c2&gt;Whatever&lt;/c2&gt; type), no initialization is attempted and you'll get whatever was already there when the memory was allocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしネイティブ型が&lt;c1&gt;*&lt;/c1&gt;(&lt;c2&gt;Whatever&lt;/c2&gt;型)に明示的に初期化されたら、メモリに既に割り当てられた値が割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしbuf型がユニコード文字列の値で初期化されたら、文字列はユニコードのコードポイントに分解され、それぞれのコードポイントは整数の要素に押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>buf型のサイズが指定されない場合は、初期化する文字列の長さから持ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サイズが指定された場合は文字列は必要に応じて切り詰められるか0で埋められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time; otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either &lt;c0&gt;U+FFFD&lt;/c0&gt; (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or &lt;c1&gt;U+007f&lt;/c1&gt; (DELETE) if the larger value would not fit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしコードポイントがbufの整数型にフィットしない場合は、コンパイル時に検出できるならパースエラーが発生します。そうでなければ実行時に警告され、オーバーフローしたバッファの要素は適切な代替文字&lt;c0&gt;U+FFFD&lt;/c0&gt; (置き換え文字、整数型が少なくとも16ビットの場合)か&lt;c1&gt;U+007f&lt;/c1&gt; (削除文字、より大きい値にフィットしない場合)に置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の変換を望む場合は、明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, no conversion to UTF-8 or UTF-16 is attempted; that must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にUTF-8かUTF-16への変換は試みられません。明示的に指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(それが起こったら、32ビット整数ベースのbufへの変換はネイティブエンディアンの有効なUTF-32を生成します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can behave as values or objects of any class, except that &lt;c0&gt;defined&lt;/c0&gt; always returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;defined&lt;/c0&gt;が常にfalseを返す場合を除き、未定義型は値または何かのクラスのオブジェクトとして振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can create them with the built-in &lt;c1&gt;undef&lt;/c1&gt; and &lt;c2&gt;fail&lt;/c2&gt; functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは組み込みの&lt;c1&gt;undef&lt;/c1&gt;か&lt;c2&gt;fail&lt;/c2&gt;関数で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(failuresがどの様に処理されるかはS04を参照して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの種類のtype、class、moduleまたはpackageを定義した場合でも、自動的に同じ名前の未定義プロトタイプ値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a &lt;c0&gt;Failure&lt;/c0&gt; value is put into a typed container, it takes on the type specified by the container but continues to carry the &lt;c1&gt;Failure&lt;/c1&gt; role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Failure&lt;/c0&gt;値が型付けされたコンテナに設置された時はいつでもコンテナによって指定された型を引き受けますが、&lt;c1&gt;Failure&lt;/c1&gt;のroleをもたらし続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c2&gt;undef&lt;/c2&gt; function merely returns the most generic &lt;c3&gt;Failure&lt;/c3&gt; object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c2&gt;undef&lt;/c2&gt;関数は最も一般的な&lt;c3&gt;Failure&lt;/c3&gt;オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c4&gt;fail&lt;/c4&gt; to return more specific failures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より特定のfailuresを返すには&lt;c4&gt;fail&lt;/c4&gt;を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c5&gt;Object&lt;/c5&gt; for the most generic non-failure undefined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最も一般的なnon-failureの未定義値には&lt;c5&gt;Object&lt;/c5&gt;を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;Any&lt;/c6&gt; type is also undefined, but excludes &lt;c7&gt;junctions&lt;/c7&gt; so that autothreading may be dispatched using normal multiple dispatch rules.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;Any&lt;/c6&gt;型も未定義ですが、autothreadingは普通のマルチディスパッチの規則でディスパッチされるので&lt;c7&gt;junctions&lt;/c7&gt;は除外します。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Nil&lt;/c0&gt; type is officially undefined as an item but interpolates as a null list into list context, and an empty capture into slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;型は項目として公式に未定義ですが、リストコンテキストではnullリストに、スライスコンテキストでは空キャプチャに補間されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c1&gt;Nil&lt;/c1&gt; object may also carry failure information, but if so, the object behaves as a failure only in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;Nil&lt;/c1&gt;オブジェクトはfailureの情報ももたらしますが、もしそうなら、オブジェクトはitemコンテキストでのみfailureとして振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c2&gt;Failure&lt;/c2&gt;/&lt;c3&gt;undef&lt;/c3&gt; when you want to return a hard failure that will not evaporate in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストコンテキストで消滅しないhard failureを返したい時は &lt;c2&gt;Failure&lt;/c2&gt;/&lt;c3&gt;undef&lt;/c3&gt;を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types behave like values, i.e. &lt;c0&gt;$x === $y&lt;/c0&gt; is true if and only if their types and contents are identical (that is, if &lt;c1&gt;$x.WHICH&lt;/c1&gt; eqv &lt;c2&gt;$y.WHICH&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は値のように振る舞います。すなわち、&lt;c0&gt;$x === $y&lt;/c0&gt;はそれらの型と内容が同一の場合のみtrueです。(つまり&lt;c1&gt;$x.WHICH&lt;/c1&gt; eqv &lt;c2&gt;$y.WHICH&lt;/c2&gt;なら)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Insofar as Lists are lazy, they're really only partially immutable, in the sense that the past is fixed but the future is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Listsがlazyである限りにおいて、過去が固定され、未来がないという意味では、それらは本当に部分的にだけ不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The portion of a List yet to be determined by iterators may depend on mutable values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まだイテレータによって決定されていないListの部分は変更可能な値に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an iterator is called upon to iterate and extend the known part of the list, some number of immutable values (which includes immutable references to mutable objects) are decided and locked in at that point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータがリストの既知の部分の反復と拡張の上で呼ばれた時、いくつかの数の不変の値(変更可能なオブジェクトへの不変なリファレンスを含む)が決定され、その点でロックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterators may have several different ways of iterating depending on the degree of laziness/eagerness desired in context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテキストで望まれるlaziness/eagernessの度合いに応じてイテレータはいくつかの異なる方法を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator API is described in S07.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イテレータのAPIはS07で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Instant&lt;/c0&gt;s and &lt;c1&gt;Duration&lt;/c1&gt;s are measured in atomic seconds with fractions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Instant&lt;/c0&gt;と&lt;c1&gt;Duration&lt;/c1&gt;は有理数で微少時間に測定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notionally they are real numbers which may be implemented in either &lt;c2&gt;Num&lt;/c2&gt; or &lt;c3&gt;Rat&lt;/c3&gt; types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>理論上、それらは&lt;c2&gt;Num&lt;/c2&gt;か&lt;c3&gt;Rat&lt;/c3&gt;型で実装される実数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Fixed-point implementations are strongly discouraged.) Interfaces that take &lt;c4&gt;Duration&lt;/c4&gt; arguments, such as sleep(), may also take &lt;c5&gt;Num&lt;/c5&gt; arguments, but &lt;c6&gt;Instant&lt;/c6&gt; arguments must be explicitly created via any of various culturally aware time specification APIs that, by and large, are outside the &lt;c7&gt;CORE&lt;/c7&gt; of Perl 6, with the possible exception of a constructor taking a native TAI value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(固定小数点の実装は強く推奨されません。)sleep()のような&lt;c4&gt;Duration&lt;/c4&gt;の引数を受け取るインターフェースは&lt;c5&gt;Num&lt;/c5&gt;引数も受け取りますが、&lt;c6&gt;Instant&lt;/c6&gt;引数はさまざまな文化を理解した時間仕様のAPI(概してPerl 6の&lt;c7&gt;CORE&lt;/c7&gt;の外側で、ネイティブTAI値を受け取るコンストラクタの可能な例外を伴う)によって明示的に作成されたものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context a &lt;c8&gt;Duration&lt;/c8&gt; happily returns a &lt;c9&gt;Num&lt;/c9&gt; representing seconds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストでは&lt;c8&gt;Duration&lt;/c8&gt;は喜んで秒を表す&lt;c9&gt;Num&lt;/c9&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If pressed for a number, an &lt;c10&gt;Instant&lt;/c10&gt; will return the length of time in atomic seconds from the TAI epoch, but it will be unhappy about it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値が求められる場面では&lt;c10&gt;Instant&lt;/c10&gt;はTAIエポック値の微少時間の長さを返すでしょう。しかしそれに関しては適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems which cannot provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>POSIXのような安定したタイムベースを返すことができないシステムでは、正しい微少時間を最大限に推測できるようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects with these types have distinct &lt;c0&gt;.WHICH&lt;/c0&gt; values that do not change even if the object's contents change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型のオブジェクトはそれぞれがオブジェクトの内容が変わっても変わらない&lt;c0&gt;.WHICH&lt;/c0&gt;値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Routinesは変更可能と見なされます。なぜならそれらは適所にラップされることができるからです。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;KeyHash&lt;/c0&gt; differs from a normal &lt;c1&gt;Hash&lt;/c1&gt; in how it handles default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;KeyHash&lt;/c0&gt;は通常の&lt;c1&gt;Hash&lt;/c1&gt;とデフォルト値の扱いが異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of a &lt;c2&gt;KeyHash&lt;/c2&gt; element is set to the default value for the &lt;c3&gt;KeyHash&lt;/c3&gt;, the element is deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;KeyHash&lt;/c2&gt;の要素の値が&lt;c3&gt;KeyHash&lt;/c3&gt;のデフォルト値にセットされていた場合、その要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If undeclared, the default default for a &lt;c4&gt;KeyHash&lt;/c4&gt; is 0 for numeric types, &lt;c5&gt;False&lt;/c5&gt; for boolean types, and the null string for string and buffer types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言されていない場合、&lt;c4&gt;KeyHash&lt;/c4&gt;のデフォルトのデフォルトは数値型では0、ブール型では&lt;c5&gt;False&lt;/c5&gt;、文字列とバッファ型ではnull文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c6&gt;KeyHash&lt;/c6&gt; of a &lt;c7&gt;Object&lt;/c7&gt; type defaults to the undefined prototype for that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;Object&lt;/c7&gt;型の&lt;c6&gt;KeyHash&lt;/c6&gt;はその型の未定義プロトタイプがデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, the default default is whatever defined value an &lt;c8&gt;undef&lt;/c8&gt; would convert to for that value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より一般的には、デフォルトのデフォルトは定義された値のなんでもの型に変換されるであろう&lt;c8&gt;undef&lt;/c8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c9&gt;KeyHash&lt;/c9&gt; of &lt;c10&gt;Scalar&lt;/c10&gt; deletes elements that go to either 0 or the null string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;Scalar&lt;/c10&gt;の&lt;c9&gt;KeyHash&lt;/c9&gt;は0かnull文字列の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c11&gt;KeyHash&lt;/c11&gt; also autodeletes keys for normal undef values (that is, those undefined values that do not contain an unthrown exception).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c11&gt;KeyHash&lt;/c11&gt;は通常のundef値のキーも削除します(つまりそれらの未定義値はスローされない例外を含みません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;KeySet&lt;/c0&gt; is a &lt;c1&gt;KeyHash&lt;/c1&gt; of booleans with a default of &lt;c2&gt;False&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;KeySet&lt;/c0&gt;は&lt;c2&gt;False&lt;/c2&gt;をデフォルトにしたブール値の&lt;c1&gt;KeyHash&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the &lt;c3&gt;Hash&lt;/c3&gt; interface and increment an element of a &lt;c4&gt;KeySet&lt;/c4&gt; its value becomes true (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし&lt;c3&gt;Hash&lt;/c3&gt;インターフェースを使い、&lt;c4&gt;KeySet&lt;/c4&gt;の要素を増やした場合はその値はtrueになります(要素が存在しない場合は作成する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし要素を減らした場合はその要素はfalseになり、自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decrementing a non-existing value results in a &lt;c5&gt;False&lt;/c5&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値を減らすと&lt;c5&gt;False&lt;/c5&gt;値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incrementing an existing value results in &lt;c6&gt;True&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在する値を増やすと&lt;c6&gt;True&lt;/c6&gt;を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a &lt;c7&gt;Hash&lt;/c7&gt; (that is, when used as an &lt;c8&gt;Array&lt;/c8&gt; or list or &lt;c9&gt;Set&lt;/c9&gt; object) a &lt;c10&gt;KeySet&lt;/c10&gt; behaves as a &lt;c11&gt;Set&lt;/c11&gt; of its keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし&lt;c7&gt;Hash&lt;/c7&gt;として使わない場合(つまり&lt;c8&gt;Array&lt;/c8&gt;かリストか&lt;c9&gt;Set&lt;/c9&gt;オブジェクトとして使った場合)&lt;c10&gt;KeySet&lt;/c10&gt;はそのキーの&lt;c11&gt;Set&lt;/c11&gt;として振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Since the only possible value of a &lt;c12&gt;KeySet&lt;/c12&gt; is the &lt;c13&gt;True&lt;/c13&gt; value, it need not be represented in the actual implementation with any bits at all.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c12&gt;KeySet&lt;/c12&gt;の可能な値が&lt;c13&gt;True&lt;/c13&gt;値だけなので、少しのことでも実際の実装では表現する必要はありません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;KeyBag&lt;/c0&gt; is a &lt;c1&gt;KeyHash&lt;/c1&gt; of &lt;c2&gt;UInt&lt;/c2&gt; with default of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;KeyBag&lt;/c0&gt;は0をデフォルトにした&lt;c2&gt;UInt&lt;/c2&gt;の&lt;c1&gt;KeyHash&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the &lt;c3&gt;Hash&lt;/c3&gt; interface and increment an element of a &lt;c4&gt;KeyBag&lt;/c4&gt; its value is increased by one (creating the element if it doesn't exist already).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたが&lt;c3&gt;Hash&lt;/c3&gt;インターフェースを使い、&lt;c4&gt;KeyBag&lt;/c4&gt;の要素をインクリメントするとその値が1増加します(存在しない要素は作成されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element the value is decreased by one; if the value goes to 0 the element is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素をデクリメントすると値が1減少します。値が0になると要素が自動的に削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attempt to decrement a non-existing value results in a &lt;c5&gt;Failure&lt;/c5&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しない値をデクリメントしようとすると&lt;c5&gt;Failure&lt;/c5&gt;値を生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not used as a &lt;c6&gt;Hash&lt;/c6&gt; (that is, when used as an &lt;c7&gt;Array&lt;/c7&gt; or list or &lt;c8&gt;Bag&lt;/c8&gt; object) a &lt;c9&gt;KeyBag&lt;/c9&gt; behaves as a &lt;c10&gt;Bag&lt;/c10&gt; of its keys, with each key replicated the number of times specified by its corresponding value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;Hash&lt;/c6&gt;として使われない場合(つまり&lt;c7&gt;Array&lt;/c7&gt;かリスト化&lt;c8&gt;Bag&lt;/c8&gt;オブジェクトとして使われた場合)、&lt;c9&gt;KeyBag&lt;/c9&gt;はそのキーの&lt;c10&gt;Bag&lt;/c10&gt;として振る舞い、それぞれのキーは対応する値によって指定された回数複製されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use &lt;c11&gt;.kv&lt;/c11&gt; or &lt;c12&gt;.pairs&lt;/c12&gt; to suppress this behavior in list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(リストコンテキストでこの振る舞いを抑制するには&lt;c11&gt;.kv&lt;/c11&gt; か&lt;c12&gt;.pairs&lt;/c12&gt;を使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with &lt;c0&gt;Hash&lt;/c0&gt; types, &lt;c1&gt;Pair&lt;/c1&gt; and &lt;c2&gt;Mapping&lt;/c2&gt; are mutable in their values but not in their keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Hash&lt;/c0&gt;型のように&lt;c1&gt;Pair&lt;/c1&gt;と&lt;c2&gt;Mapping&lt;/c2&gt;はそれらの値を変更できますがキーはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A key can be a reference to a mutable object, but cannot change its &lt;c3&gt;.WHICH&lt;/c3&gt; identity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(キーは変更可能なオブジェクトへの参照になれますが、&lt;c3&gt;.WHICH&lt;/c3&gt;の固有性は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、ハッシュの要素と同様に値は異なるオブジェクトに再バインドされるでしょう。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的な型はオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their &quot;value type&quot; and their &quot;implementation type&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlの変数は2つの関連する型を持ちます: それらの&quot;値型&quot;と&quot;実装型&quot;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its &lt;c0&gt;of&lt;/c0&gt; property, while the implementation type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より一般的には、どの種類のコンテナもサブルーチンとモジュールを含む実装型を持ちます。)値型はその&lt;c0&gt;of&lt;/c0&gt;プロパティとして格納され、コンテナの実装型は単にコンテナ自身のオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &lt;c1&gt;returns&lt;/c1&gt; is allowed as an alias for &lt;c2&gt;of&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単語&lt;c1&gt;returns&lt;/c1&gt;は&lt;c2&gt;of&lt;/c2&gt;の別名として許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型はどの種類の値が変数に格納されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type is given as a prefix or with the &lt;c0&gt;of&lt;/c0&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は前置か&lt;c0&gt;of&lt;/c0&gt;キーワードで与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the &lt;c0&gt;of&lt;/c0&gt; property of the container to &lt;c1&gt;Dog&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合でもコンテナの&lt;c0&gt;of&lt;/c0&gt;プロパティを&lt;c1&gt;Dog&lt;/c1&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines have a variant of the &lt;c0&gt;of&lt;/c0&gt; property, &lt;c1&gt;as&lt;/c1&gt;, that sets the &lt;c2&gt;as&lt;/c2&gt; property instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンは&lt;c0&gt;of&lt;/c0&gt;プロパティの変化形&lt;c1&gt;as&lt;/c1&gt;を持ち、代わりに&lt;c2&gt;as&lt;/c2&gt;プロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;as&lt;/c3&gt; property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to &lt;c4&gt;return&lt;/c4&gt; or by implicit fall-off-the-end return).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;as&lt;/c3&gt;プロパティは返値に強制される制約(もしかしたら抑制) を指定します(&lt;c4&gt;return&lt;/c4&gt;によって明示的に呼ばれるか最後の暗黙の返値のいずれかによって)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint, unlike the &lt;c5&gt;of&lt;/c5&gt; property, is not advertised as the type of the routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;of&lt;/c5&gt;プロパティのようでないこの制約はルーチンの型としては表に出ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of it as the implicit type signature of the (possibly implicit) return statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは(もしかしたら暗黙の)return文の暗黙の型シグネチャと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's therefore available for type inferencing within the routine but not outside it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従ってルーチン内で型推論が利用できますが外側ではできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no &lt;c6&gt;as&lt;/c6&gt; type is declared, it is assumed to be the same as the &lt;c7&gt;of&lt;/c7&gt; type, if declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;as&lt;/c6&gt;型が宣言されていない場合、&lt;c7&gt;of&lt;/c7&gt;型が宣言されている場合と同じと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列かハッシュでの値型はそれぞれの格納された要素の型を指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュのキーの型はshape traitで指定されます―S09を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型は変数自身がどの様に実装されているかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変数のtraitとして与えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装型を定義することはPerl 6ではPerl 5の変数のtieに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time &lt;c0&gt;tie&lt;/c0&gt; statement unless the variable is explicitly declared with an implementation type that does the &lt;c1&gt;Tieable&lt;/c1&gt; role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしPerl 6の変数は宣言時に直接tieされ、&lt;c1&gt;Tieable&lt;/c1&gt; roleを行う実装型で明示的に宣言された変数でなければパフォーマンス上の理由で実行時に&lt;c0&gt;tie&lt;/c0&gt;文でtieされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, package variables are always considered &lt;c0&gt;Tieable&lt;/c0&gt; by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながらパッケージ変数は常にデフォルトで&lt;c0&gt;Tieable&lt;/c0&gt;とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, all named packages are also &lt;c1&gt;Tieable&lt;/c1&gt; by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、全ての名前付きパッケージもデフォルトで&lt;c1&gt;Tieable&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスとモジュールはtieされたパッケージとは異なると見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the &lt;c2&gt;Package&lt;/c2&gt; role.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の方向から見れば、グローバルパッケージにバインドされることを希望するクラスとモジュールは&lt;c2&gt;Package&lt;/c2&gt; roleが可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの型の値がそれぞれの要素に格納されているか指定するため、非スカラー型は修飾されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each successive &lt;c0&gt;of&lt;/c0&gt; makes the type on its right a parameter of the type on its left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの連続する&lt;c0&gt;of&lt;/c0&gt;はその右のパラメータの型を、その左の型にさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ付きの型は角括弧を使って名前を付けられます。だから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は実際には以下のような意味になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑な型が指定された場合は実際の変数を理解するのが大変なので、同様の後置形式があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;as&lt;/c0&gt; form may be used in subroutines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンでは&lt;c0&gt;as&lt;/c0&gt;形式が使われるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに返値の型はシグネチャ内で指定されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a slight difference, insofar as the type inferencer will ignore a &lt;c0&gt;as&lt;/c0&gt; but pay attention to &lt;c1&gt;--&gt;&lt;/c1&gt; or prefix type declarations, also known as the &lt;c2&gt;of&lt;/c2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の推測者が&lt;c0&gt;as&lt;/c0&gt;を無視する限りにおいて、そこには微妙な違いがあります。しかし&lt;c2&gt;of&lt;/c2&gt;型としても知られる&lt;c1&gt;--&gt;&lt;/c1&gt;または後置の型宣言に注意を払って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the inside of the subroutine pays attention to &lt;c3&gt;as&lt;/c3&gt;, and essentially coerces the return value to the indicated type, just as if you'd coerced each return expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブルーチンの内側だけが&lt;c3&gt;as&lt;/c3&gt;に注意を払っており、本質的に返値はそれぞれのreturn式を強制したかのように指定された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also specify the &lt;c0&gt;of&lt;/c0&gt; type as the &lt;c1&gt;of&lt;/c1&gt; trait (with &lt;c2&gt;returns&lt;/c2&gt; allowed as a synonym):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;of&lt;/c0&gt;型を&lt;c1&gt;of&lt;/c1&gt; trait(&lt;c2&gt;returns&lt;/c2&gt;が同義語として許可される)として指定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &quot;or&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;or&quot;かjunctionであるかのように、単一の型をセットで使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fancier type constraints may be expressed through a subtype:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>手の込んだ型制約はsubtypeを通して表現されるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &quot;anded&quot; together (the variable itself supplies type constraints, and &lt;c0&gt;where&lt;/c0&gt; clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &quot;and&quot; junction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの項は暗黙に一緒に&quot;anded&quot;された制約のセットと見ることができるので(変数自身は型制約を供給し、&lt;c0&gt;where&lt;/c0&gt;条項かツリーマッチングはさらに制約を加えるだけです)、我々は&quot;and&quot; junctionのように型の並びを許可するためにこれを緩和します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは他のどの様な変数と同じように型を与えられるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の中で、クラス変数(それ自身か既存の型名の後のどちらか)は新しい型名を宣言し、実際のパラメータの型と関連づけられているパラメータ付きの値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It declares the new type name in the same scope as the associated declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは関連付けられた宣言として同じスコープ内で新しい型名を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい型名は直ちに取り込まれ、同じシグネチャ内の2つのそのような型は同じ名前の場合は互換性を統一する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a scoped subroutine, a return type can be specified before or after the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スコープ付きサブルーチンでは、返値の型は名前の前か後で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call all return types &quot;return types&quot;, but distinguish two kinds of return types, the &lt;c0&gt;as&lt;/c0&gt; type and the &lt;c1&gt;of&lt;/c1&gt; type, because the &lt;c2&gt;of&lt;/c2&gt; type is normally an &quot;official&quot; named type and declares the official interface to the routine, while the &lt;c3&gt;as&lt;/c3&gt; type is merely a constraint on what may be returned by the routine from the routine's point of view.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々は返値の型を&quot;return types&quot;と呼びますが、&lt;c0&gt;as&lt;/c0&gt;型と&lt;c1&gt;of&lt;/c1&gt;型の2種類の返値の型は区別します。なぜなら&lt;c2&gt;of&lt;/c2&gt;型は通常は&quot;official&quot;な名前を付けられた型名で、ルーチンに対するオフィシャルなインターフェースを宣言します。&lt;c3&gt;as&lt;/c3&gt;は単にルーチン視点でルーチンによって何が返されるかの制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it's scoped with the &lt;c0&gt;our&lt;/c0&gt; scope modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしサブルーチンが明示的にスコープ化されていないなら、それは&lt;c0&gt;our&lt;/c0&gt;スコープ修飾子でスコープ化されるかのように現在の名前空間(モジュール、クラス、grammarまたはパッケージ)に属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any return type must go after the name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はどれでも名前の後に移動する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On an anonymous subroutine, any return type can only go after the &lt;c0&gt;sub&lt;/c0&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名サブルーチンでは、どの返値の型も&lt;c0&gt;sub&lt;/c0&gt;キーワードの後にしか移動できません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but you can use a scope modifier to introduce an &lt;c0&gt;of&lt;/c0&gt; prefix type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;of&lt;/c0&gt;後置型を導入するためにスコープ修飾子を使うことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are anonymous, you can change the &lt;c0&gt;my&lt;/c0&gt; modifier to &lt;c1&gt;our&lt;/c1&gt; without affecting the meaning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは無名なので、&lt;c0&gt;my&lt;/c0&gt;修飾子は意味に影響を与えずに &lt;c1&gt;our&lt;/c1&gt;に変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type may also be specified after a &lt;c0&gt;--&gt;&lt;/c0&gt; token within the signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返値の型はシグネチャの中で&lt;c0&gt;--&gt;&lt;/c0&gt;トークンの後で指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This doesn't mean exactly the same thing as &lt;c1&gt;as&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c1&gt;as&lt;/c1&gt;と正確に同じ意味があるものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;of&lt;/c2&gt; type is the &quot;official&quot; return type, and may therefore be used to do type inferencing outside the sub.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;of&lt;/c2&gt;型は&quot;official&quot;な返値の型で、サブルーチンの外側で型推論を行うために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;as&lt;/c3&gt; type only makes the return type available to the internals of the sub so that the &lt;c4&gt;return&lt;/c4&gt; statement can know its context, but outside the sub we don't know anything about the return value, as if no return type had been declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;as&lt;/c3&gt;型はサブルーチンの内部で利用できる返値の型を作るだけで、&lt;c4&gt;return&lt;/c4&gt;文がそのコンテキストを知ることができますが、サブルーチンの外側では返値の型が宣言されていないかのように返値の型に関して何も知ることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prefix form specifies the &lt;c5&gt;of&lt;/c5&gt; type rather than the &lt;c6&gt;as&lt;/c6&gt; type, so the return type of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置形式は&lt;c6&gt;as&lt;/c6&gt;型よりも&lt;c5&gt;of&lt;/c5&gt;型を指定するので、返値の型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is known to return an object of type Fish, as if you'd said:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はあなたが次のようにしたかのようにFish型のオブジェクトを返すと知ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;i0&gt;not&lt;/i0&gt; as if you'd said</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のようにではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible for the &lt;c0&gt;of&lt;/c0&gt; type to disagree with the &lt;c1&gt;as&lt;/c1&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;of&lt;/c0&gt;型と&lt;c1&gt;as&lt;/c1&gt;型を区別することが可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または同じに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of &lt;s0&gt;sigils&lt;/s0&gt; to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は変数の基本的な構造をマークするための&lt;s0&gt;sigils&lt;/s0&gt;システムを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, the &lt;c0&gt;&amp;&lt;/c0&gt; sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言内で&lt;c0&gt;&amp;&lt;/c0&gt; sigilはスコープ宣言内のsigil無しにサブルーチン名の可視性も宣言します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a signature or other declaration, the &lt;c0&gt;::&lt;/c0&gt; sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャか他の宣言内で、識別子が続く&lt;c0&gt;::&lt;/c0&gt; sigilはpackage/type名の可視性をスコープ宣言のsigil無しに宣言する型変数をマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初はそのようなスコープ付きの宣言はバインドされない型とみなされ、その関連付けられた引数の実際の型を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後に続く同じスコープの宣言内のsigilは任意なので、裸の型名も宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内側をネストする宣言は同じ型を参照したい場合はsigilを使うことは出来ません。内側の宣言は型を再バインドするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(pointy blockのシグネチャは外側のブロックではなく内側のブロックとして数えられルので注意して下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsはバインドされたオブジェクトの正確な型ではなく、全体的なインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるsigilsはわずかな異なる能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなスカラー変数はオブジェクトが本質的に複合型か単一型かどうかに関わらず常にどのようなリストコンテキストでも単数形アイテムとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの種類のデリファレンスコンテキストに置かれなければ、その内容は自動的にデリファレンスされないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly though it just means that you want to give some abstraction an official name that you can then use later in the compilation without any sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはコンパイル中になんらかのsigil無しに抽象化に後で使えるように公式な名前を与えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのような場合でも、sigilによって意味づけされた最小のコンテナroleは最新のバインディング時にチェックされ、文法エラーがすぐに検出できるなら（コンパイル時のような）早期に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなリストの添字は元のオブジェクトの添字を意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、もはやsigilとそれに続く名前または構造の間に空白を置けないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通のsigilsは通常のスコープ変数、レキシカルかパッケージスコープを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oddly scoped variables include a secondary sigil (a &lt;s0&gt;twigil&lt;/s0&gt;) that indicates what kind of strange scoping the variable is subject to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変なスコープ変数は変数がどの種類の奇妙なスコープに従属するかを示す2つ目のsigil(&lt;s0&gt;twigil&lt;/s0&gt;)を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &quot;my&quot; or &quot;our&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのtwigils変数は暗黙に他のスコープに宣言されるか宣言されていると見なされ、&quot;my&quot;か&quot;our&quot;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attribute variables are declared with &lt;c0&gt;has&lt;/c0&gt;, though.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性変数は&lt;c0&gt;has&lt;/c0&gt;で宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsは今は変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$&lt;/c0&gt; always means a scalar variable, &lt;c1&gt;@&lt;/c1&gt; an array variable, and &lt;c2&gt;%&lt;/c2&gt; a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;$&lt;/c0&gt;は常にスカラー変数を意味し、添字がある場合でも&lt;c1&gt;@&lt;/c1&gt;は配列、&lt;c2&gt;%&lt;/c2&gt;はハッシュ変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as &lt;c3&gt;@array&lt;/c3&gt; and &lt;c4&gt;%hash&lt;/c4&gt; simply return themselves as &lt;c5&gt;Array&lt;/c5&gt; and &lt;c6&gt;Hash&lt;/c6&gt; objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アイテムコンテキストでは&lt;c3&gt;@array&lt;/c3&gt;や&lt;c4&gt;%hash&lt;/c4&gt;のような変数は単純にそれら自身を&lt;c5&gt;Array&lt;/c5&gt;や&lt;c6&gt;Hash&lt;/c6&gt;オブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Item context was formerly known as scalar context, but we now reserve the &quot;scalar&quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(アイテムコンテキストは以前はスカラーコンテキストとして知られていましたが、われわれは&quot;scalar&quot;の概念をコンテキスト（リストコンテキストからの配列の解除）よりも変数のことに関しての話と予約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列コンテキストではコンテナオブジェクトは自動的に適切な文字列値に文字列化(空白で区切られた)されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールコンテキストでは、コンテナに要素がある場合だけtrue値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a Perlish representation of any object, use the &lt;c0&gt;.perl&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトのPerlっぽい表現を得るには&lt;c0&gt;.perl&lt;/c0&gt;メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the &lt;c1&gt;Data::Dumper&lt;/c1&gt; module in Perl 5, the &lt;c2&gt;.perl&lt;/c2&gt; method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5の&lt;c1&gt;Data::Dumper&lt;/c1&gt;モジュールのように、&lt;c2&gt;.perl&lt;/c2&gt;メソッドは文字列にクォートを置き、リスト値に角括弧を置き、ハッシュ値にカーリーを置きます。なのでPerlは結果を評価して同じオブジェクトに戻せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;.perl&lt;/c3&gt; method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;.perl&lt;/c3&gt;メソッドはオブジェクトの想定の表現を返し、もしコードが同じ点で再解析されたら、アイテムコンテキストでオブジェクトをスカラーとして再出力するのに使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use &lt;c4&gt;&lt;prefix:&lt;|&lt;/c4&gt; &gt;&gt; to force interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし再解析されたオブジェクトをリストコンテキストに挿入したいなら、&lt;c4&gt;&lt;prefix:&lt;|&lt;/c4&gt; &gt;&gt;を強制挿入のために使う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the &lt;c0&gt;.fmt('%03d')&lt;/c0&gt; method to do an implicit &lt;c1&gt;sprintf&lt;/c1&gt; on the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スカラー値のフォーマットされた表現を得るには、値に暗黙の&lt;c1&gt;sprintf&lt;/c1&gt;を行う&lt;c0&gt;.fmt('%03d')&lt;/c0&gt;メソッドを使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は一貫して左にあるどんなものにでも作られたコンテナをデリファレンスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数名と添字の間の空白は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、構造を視覚的に引き延ばす2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a subscript is a kind of postfix operator, there is a corresponding &lt;s0&gt;dot&lt;/s0&gt; form of each subscript (&lt;c1&gt;@foo.[1]&lt;/c1&gt; and &lt;c2&gt;%bar.{'a'}&lt;/c2&gt;) that makes the dereference a little more explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は後置演算子の一種なので、それぞれの添字に対応する&lt;s0&gt;dot&lt;/s0&gt;形式があります(&lt;c1&gt;@foo.[1]&lt;/c1&gt;と&lt;c2&gt;%bar.{'a'}&lt;/c2&gt;)。それはデリファレンスをより少し明示的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant string subscripts may be placed in angles, so &lt;c3&gt;%bar.{'a'}&lt;/c3&gt; may also be written as &lt;c4&gt;%bar&lt;a&gt;&lt;/c4&gt; or &lt;c5&gt;%bar.&lt;a&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数文字列の添字はangles内に置かれます。つまり&lt;c3&gt;%bar.{'a'}&lt;/c3&gt;は&lt;c4&gt;%bar&lt;a&gt;&lt;/c4&gt;か&lt;c5&gt;%bar.&lt;a&gt;&lt;/c5&gt;とも書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、unspaceを使って追加の空白を挿入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシングは添字の性質で指定され、sigilによってではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添字は常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More specifically, they are evaluated in a variant of list context known as &lt;i0&gt;slice&lt;/i0&gt; context, which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(より正確には、それらは&lt;i0&gt;slice&lt;/i0&gt;コンテキストというリストコンテキストの変化形で評価され、それは次元的情報を保存し、あなたはmulti-dimensionalスライスをセミコロンを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a slice context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それぞれの次元のスライスは普通のリストコンテキストなので添字の一部で呼ばれた関数はsliceコンテキストを認識しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし内部のコンテキストをアイテム(スカラー)コンテキストに強制したいなら+を数値コンテキスト、~を文字列コンテキストに指定するなどの便利な単一文字のspecifiersがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils used either as functions or as list prefix operators also force context, so these also work:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sigilsを関数として、またはリストの前置演算子として使うかどちらかによってもコンテキストを強制できます。なのでこれらはこのようにも動きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこれらは同じではないので注意して下さい:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストバインディングからリストの割り当てを識別する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストの割り当てはPerl 5のように、値をコピーして動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a new &lt;c0&gt;:=&lt;/c0&gt; binding operator that lets you bind names to &lt;c1&gt;Array&lt;/c1&gt; and &lt;c2&gt;Hash&lt;/c2&gt; objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;:=&lt;/c0&gt;バインディング演算子があり、それはコピー無しに&lt;c1&gt;Array&lt;/c1&gt;と&lt;c2&gt;Hash&lt;/c2&gt;オブジェクトを名前にバインディングし、サブルーチンの引数の同じ方法ではパラメータに正式にバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バインディングについて詳しくはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An argument list may be captured into an object with backslashed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数リストはバックスラッシュ括弧でオブジェクトに取り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in a &lt;c0&gt;Capture&lt;/c0&gt; object are parsed as ordinary expressions, then marked as positional or named.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;Capture&lt;/c0&gt;オブジェクト内の値は普通の式としてパースされ、順番か名前でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように解決されるかは最終的に何にバインドされるかに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他がそうでない場合に、いくつかのバインディングは複数の次元に敏感です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When cast into an array, you can access all the positional arguments; into a hash, all named arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列にキャストすると全てのポジショナル引数にアクセスできます。ハッシュなら全ての名前付き引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての前置sigil演算子は一つのポジショナル引数を許容します。それは右辺値としてアイテムコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはもし括弧で呼ばれたら文字列に差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of them as &quot;fat&quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは&quot;fat&quot;リファレンスと考えることができます。それは現在のシングルオブジェクトのアイデンティティだけでなく、関連するいくつかのオブジェクトを取り込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (&lt;c0&gt;Signature&lt;/c0&gt;) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャオブジェクト(&lt;c0&gt;Signature&lt;/c0&gt;)はコロン前置の括弧で作成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャ中の式は普通の式ではなくパラメータ宣言として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの文法の詳細についてはS06を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数にバインドされたシグネチャオブジェクト(上記の例のように)は追加の型制約を適用するために他のシグネチャと共に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &lt;c0&gt;&amp;foo&lt;/c0&gt; merely stands for the &lt;c1&gt;foo&lt;/c1&gt; function as a &lt;c2&gt;Routine&lt;/c2&gt; object without calling it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と異なり、&lt;c0&gt;&amp;foo&lt;/c0&gt;という表記は単に関数&lt;c1&gt;foo&lt;/c1&gt;を&lt;c2&gt;Routine&lt;/c2&gt;オブジェクトとして呼び出し無しに表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧でデリファレンスしてCodeオブジェクトを呼べるでしょう(もちろん引数を含めて):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の前に空白は許されません。なぜなら括弧は後置として解析されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any postfix, there is also a corresponding &lt;c0&gt;.()&lt;/c0&gt; operator, and you may use the &quot;unspace&quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのpostfixとも同じように、対応する&lt;c0&gt;.()&lt;/c0&gt;演算子があり、オプショナルな空白やコメントを挿入するために間にバックスラッシュで&quot;unspace&quot;を使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the parentheses around arguments in the &quot;normal&quot; named forms of function and method calls are not postfix operators, so do not allow the &lt;c0&gt;.()&lt;/c0&gt; form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通の形式の名前に付けられた括弧は関数かメソッド呼び出しですが後置演算子ではありません。そのため&lt;c0&gt;.()&lt;/c0&gt;形式は許されません。なぜならドットは実際にはデリファレンス演算子を示すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you &lt;i0&gt;do&lt;/i0&gt; use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの特別な場合にドット形式を使う場合は、引数無しに名前付き形式を呼ぶか、結果をデリファレンスしたいということを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With multiple dispatch, &lt;c0&gt;&amp;foo&lt;/c0&gt; may actually be the name of a set of candidate functions (which you can use as if it were an ordinary function).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マルチディスパッチにおいては&lt;c0&gt;&amp;foo&lt;/c0&gt;は実際には候補関数のセットの名前になります(それは普通の関数であるかのように使うことが出来ます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &lt;c1&gt;&amp;foo&lt;/c1&gt; by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしこの場合は&lt;c1&gt;&amp;foo&lt;/c1&gt;自身は特定の関数の関数名となるには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定するために、型は後置演算子のシグネチャリテラルを使ってリファインされるでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It still just returns the &lt;c0&gt;Routine&lt;/c0&gt; object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはまだ&lt;c0&gt;Routine&lt;/c0&gt;オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied by using the &lt;c1&gt;.assuming&lt;/c1&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>呼び出しは&lt;c1&gt;.assuming&lt;/c1&gt;を使うことによっても部分的に適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライシング文法はS09でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元スライスは個々のスライスサブリストの間のセミコロンで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such slice sublist is evaluated lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのスライスサブリストは曖昧に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライスの添字を値以外の何かを返すようにさせるには、添字に適切な副詞を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの副詞的形式は存在しないエントリーを取り去ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, which will return true if all the elements of the slice exist:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのスライスの要素が存在するならtrueを返すテストを実行することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>likewise,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &quot;en passant&quot; while returning them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>は値を返すついでに削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろん単一のインデックスのスライスでもこれらの形式は動きます。)添字が最も前の演算子であるという事実のおかげでこれらが動くということに注意して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(このようなスライス修飾子はめったには起こりません。なぜならそれらは普通はコンマの優先順位を操作するリストコンテキストで使用されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into &lt;c0&gt;Int&lt;/c0&gt; or &lt;c1&gt;Num&lt;/c1&gt;), a &lt;c2&gt;Hash&lt;/c2&gt; object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値コンテキスト(&lt;c0&gt;Int&lt;/c0&gt;か&lt;c1&gt;Num&lt;/c1&gt;にキャストされる場合)、&lt;c2&gt;Hash&lt;/c2&gt;オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール値コンテキストではなんらかのペアがハッシュにあればtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, any intrinsic iterator would be reset.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの場合で、内在のイテレータはリセットされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ペアのリストをソートするとデフォルトでキーでソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of lists should sort on the first elements, then the second elements, etc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストのリストをソートすると最初の要素でソートし、次に2番目の要素で、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on &lt;c0&gt;sort&lt;/c0&gt; see S29.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;sort&lt;/c0&gt;の詳細についてはS29を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5の特殊変数はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りの特殊変数はレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c0&gt;$_&lt;/c0&gt; and &lt;c1&gt;@_&lt;/c1&gt;, as well as the new &lt;c2&gt;$/&lt;/c2&gt;, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c0&gt;$_&lt;/c0&gt;と&lt;c1&gt;@_&lt;/c1&gt;を含み、同様に新しい&lt;c2&gt;$/&lt;/c2&gt;は最後の正規表現マッチの返値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;, &lt;c4&gt;$1&lt;/c4&gt;, &lt;c5&gt;$2&lt;/c5&gt;, etc., are aliases into the &lt;c6&gt;$/&lt;/c6&gt; object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;、&lt;c4&gt;$1&lt;/c4&gt;、&lt;c5&gt;$2&lt;/c5&gt;などは&lt;c6&gt;$/&lt;/c6&gt;オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;$#foo&lt;/c0&gt; notation is dead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;$#foo&lt;/c0&gt;表記法はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c1&gt;@foo.end&lt;/c1&gt; or &lt;c2&gt;@foo[*-1]&lt;/c2&gt; instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;@foo.end&lt;/c1&gt;か&lt;c2&gt;@foo[*-1]&lt;/c2&gt;を使って下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or &lt;c3&gt;@foo.shape[$dimension]&lt;/c3&gt; for multidimensional arrays.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(または&lt;c3&gt;@foo.shape[$dimension]&lt;/c3&gt;を多次元配列に使って下さい。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;i0&gt;identifier&lt;/i0&gt; is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;i0&gt;識別子&lt;/i0&gt;は英数字が続くアルファベットで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルファベットと数字の定義は適切なユニコード文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコアは常にアルファベットと見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は次の文字がアルファベットの孤立したアポストロフィかハイフンを含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i0&gt;name&lt;/i0&gt; is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;i0&gt;名前&lt;/i0&gt;は変数名の適正な部分のことです(sigilは数えません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは以下を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, bare &lt;c5&gt;=begin&lt;/c5&gt; and &lt;c6&gt;=end&lt;/c6&gt; probably aren't good enough, because all comments in them will show up in the formatted output.) &lt;br7/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(しかしながら、裸の&lt;c5&gt;=begin&lt;/c5&gt;と&lt;c6&gt;=end&lt;/c6&gt;はたぶん十分ではないでしょう。それらの中のコメントがフォーマットされて出力されてしまうからです。)&lt;br7/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have single paragraph comments with &lt;c9&gt;=for comment&lt;/c9&gt; as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、単一のパラグラフコメント&lt;c9&gt;=for comment&lt;/c9&gt;があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That lets &lt;c10&gt;=for&lt;/c10&gt; keep its meaning as the equivalent of a &lt;c11&gt;=begin&lt;/c11&gt; and &lt;c12&gt;=end&lt;/c12&gt; combined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c10&gt;=for&lt;/c10&gt;を&lt;c11&gt;=begin&lt;/c11&gt;と&lt;c12&gt;=end&lt;/c12&gt;を結合した状態と同じにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with &lt;c13&gt;=begin&lt;/c13&gt; and &lt;c14&gt;=end&lt;/c14&gt;, a comment started in code reverts to code afterwards.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c13&gt;=begin&lt;/c13&gt;と&lt;c14&gt;=end&lt;/c14&gt;のように、コメントはコードの前から始まってコードの後まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is a newline before the first &lt;c17&gt;=&lt;/c17&gt;, the POD form of comment counts as whitespace equivalent to a newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の&lt;c17&gt;=&lt;/c17&gt;の前に改行が現れるまで、POD形式のコメントは改行と同じく空白としてカウントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other uses of &lt;c5&gt;#&lt;/c5&gt; are interpreted as single-line comments that work just as in Perl 5, starting with a &lt;c6&gt;#&lt;/c6&gt; character and ending at the subsequent newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の&lt;c5&gt;#&lt;/c5&gt;の使用法はPerl 5のように1行コメントとして働き、&lt;c6&gt;#&lt;/c6&gt;で始まって次の改行で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, &lt;c7&gt;#&lt;/c7&gt; may &lt;i8&gt;not&lt;/i8&gt; be used as the delimiter in quoting constructs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5と違い、&lt;c7&gt;#&lt;/c7&gt;はクォートを構築する区切り文字として使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There must be no space between the &lt;c2&gt;#&lt;/c2&gt; and the opening bracket character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の開始と&lt;c2&gt;#&lt;/c2&gt;の間に空白があることは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.) &lt;br0/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(単項のバックスラッシュの使用は空白が続かないかもしれないし、unspaceとして持って行かれるかもしれません。)&lt;br0/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, you override the unspace rule itself...) &lt;br0/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(もちろんunspaceのルール自身を上書きしないなら)&lt;br0/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c2&gt;#&lt;/c2&gt; following such a newline is always an end-of-line comment, as described above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような改行に続く&lt;c2&gt;#&lt;/c2&gt;は上記のように常に行コメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you were to add your own &lt;c7&gt;infix:&lt;++&gt;&lt;/c7&gt; operator, then it must have space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば&lt;c7&gt;infix:&lt;++&gt;&lt;/c7&gt;という2項演算子を追加したいなら、その前に必ず空白が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal autoincrementing &lt;c8&gt;postfix:&lt;++&gt;&lt;/c8&gt; operator may never have space before it, but may be written in any of these forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常の&lt;c8&gt;postfix:&lt;++&gt;&lt;/c8&gt;演算子はその前に空白を持ちませんが、これらのどの形式でも書くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.) &lt;br2/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし常に前に空白を置かなければならないか、代わりに後置のメソッド呼び出しと解釈されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of all this is that you may no longer write a Num as &lt;c2&gt;42.&lt;/c2&gt; with just a trailing dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの結果の一つとして、ただの終端ドットを伴うNumとしての&lt;c2&gt;42.&lt;/c2&gt;はもはや書けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must instead say either &lt;c3&gt;42&lt;/c3&gt; or &lt;c4&gt;42.0&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;42&lt;/c3&gt;か&lt;c4&gt;42.0&lt;/c4&gt;としなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c5&gt;.123&lt;/c5&gt; form with a leading dot is still allowed however when a term is expected, and is equivalent to &lt;c6&gt;0.123&lt;/c6&gt; rather than &lt;c7&gt;$_.123&lt;/c7&gt;.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(項が期待される時はドットが先行する&lt;c5&gt;.123&lt;/c5&gt;という形式がまだ許可されます。これは&lt;c7&gt;$_.123&lt;/c7&gt;ではなく&lt;c6&gt;0.123&lt;/c6&gt;になります。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, both methods allow an optional argument to specify the meaning exactly if it cannot be known from context.) &lt;br6/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>従って、コンテキストから分からない場合は両方のメソッドは意味を正確に指定する任意の引数を受け取ります。)&lt;br6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no &lt;c8&gt;.length&lt;/c8&gt; method for either arrays or strings, because &lt;c9&gt;length&lt;/c9&gt; does not specify a unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;.length&lt;/c8&gt;は配列か文字列のどちらにもありません。なぜなら&lt;c9&gt;length&lt;/c9&gt;は単位を指定していないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-object (native) types are lowercase: &lt;c22&gt;int&lt;/c22&gt;, &lt;c23&gt;num&lt;/c23&gt;, &lt;c24&gt;complex&lt;/c24&gt;, &lt;c25&gt;rat&lt;/c25&gt;, &lt;c26&gt;buf&lt;/c26&gt;, &lt;c27&gt;bit&lt;/c27&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトでない(ネイティブ)型は小文字です: &lt;c22&gt;int&lt;/c22&gt;、&lt;c23&gt;num&lt;/c23&gt;、&lt;c24&gt;complex&lt;/c24&gt;、&lt;c25&gt;rat&lt;/c25&gt;、&lt;c26&gt;buf&lt;/c26&gt;、&lt;c27&gt;bit&lt;/c27&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that sometimes repeated autoboxing can slow your program more than the native type can speed it up.) &lt;br28/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、autoboxingの繰り返しがネイティブ型のスピードアップ以上にプログラムを遅くすることも時々あります。)&lt;br28/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c30&gt;junction&lt;/c30&gt; type is considered a native type because its internal representation is fixed, and you may not usefully derive from it because the intent of junctions is to autothread any method calls on them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c30&gt;junction&lt;/c30&gt;型はネイティブ型とみなされます。なぜならそれの内部表現は固定されており、junctionはメソッド呼び出しを自動スレッド化することを意図しているので、あなたはそれを有効に継承することは出来ないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal objects just use their address in memory, but if a class wishes to behave as a value type, it can define a &lt;c33&gt;.WHICH&lt;/c33&gt; method that makes different objects look like the same object if they happen to have the same contents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常のオブジェクトは単にそれらのメモリアドレス使いますが、クラスが値型として振る舞いたいと望むなら、異なるオブジェクトが偶然に同じ内容を持っている場合に同じオブジェクトのように見せる&lt;c33&gt;.WHICH&lt;/c33&gt;メソッドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must convert to and from &lt;c6&gt;Int&lt;/c6&gt; to do portable bitops on such ancient hardware.) &lt;br7/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c6&gt;Int&lt;/c6&gt;への変換や逆のことをそのような古いハードウェアの移植性のあるビット演算に出来るようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;c9&gt;Num&lt;/c9&gt; may support arbitrary-precision floating-point arithmetic, but is not required to unless we can do so portably and efficiently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c9&gt;Num&lt;/c9&gt;は任意の精度の浮動小数点演算をサポートするでしょう。しかし移植性が高く効率的に行うことが出来ないのであれば必要有りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c10&gt;Num&lt;/c10&gt; must support the largest native floating point format that runs at full speed.) &lt;br11/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;Num&lt;/c10&gt;は最も大きいネイティブ浮動小数点フォーマットをフルスピードで実行できるようにしなければなりません。)&lt;br11/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c13&gt;Rat&lt;/c13&gt; supports arbitrary precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c13&gt;Rat&lt;/c13&gt;は任意の精度の有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, dividing two &lt;c14&gt;Int&lt;/c14&gt; objects using &lt;c15&gt;infix:&lt;/&gt;&lt;/c15&gt; produces a fraction of &lt;c16&gt;Num&lt;/c16&gt; type, not a ratio.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、2つの&lt;c14&gt;Int&lt;/c14&gt;オブジェクトを&lt;c15&gt;infix:&lt;/&gt;&lt;/c15&gt;で除算すると&lt;c16&gt;Num&lt;/c16&gt;型の端数を生成し、ratioではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can produce a ratio by using &lt;c17&gt;infix:&lt;div&gt;&lt;/c17&gt; on two integers instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに&lt;c17&gt;infix:&lt;div&gt;&lt;/c17&gt;を使ってratioを生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lower-case types like &lt;c20&gt;int&lt;/c20&gt; and &lt;c21&gt;num&lt;/c21&gt; imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c20&gt;int&lt;/c20&gt;、&lt;c21&gt;num&lt;/c21&gt;のような小文字型はマシンネイティブの整数と浮動小数点表現を暗示します。それぞれは任意の精度を促進しませんが、テンポラリな値についてはより大きな表現が常に許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless qualified with a number of bits, &lt;c22&gt;int&lt;/c22&gt; and &lt;c23&gt;num&lt;/c23&gt; types represent the largest native integer and floating-point types that run at full speed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビットの数で修飾されない&lt;c22&gt;int&lt;/c22&gt;と&lt;c23&gt;num&lt;/c23&gt;型は最大速度で実行される最も大きな整数と浮動小数点を表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric values in untyped variables use &lt;c26&gt;Int&lt;/c26&gt; and &lt;c27&gt;Num&lt;/c27&gt; semantics rather than &lt;c28&gt;int&lt;/c28&gt; and &lt;c29&gt;num&lt;/c29&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型指定されない数値では&lt;c26&gt;Int&lt;/c26&gt;と&lt;c27&gt;Num&lt;/c27&gt;が&lt;c28&gt;int&lt;/c28&gt;と&lt;c29&gt;num&lt;/c29&gt;に優先されて使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subtraction of two &lt;c9&gt;StrPos&lt;/c9&gt; objects gives a &lt;c10&gt;StrLen&lt;/c10&gt; object, which is also not an integer, because the string between two positions also has multiple integer interpretations depending on the units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの&lt;c9&gt;StrPos&lt;/c9&gt;オブジェクトの減算は&lt;c10&gt;StrLen&lt;/c10&gt;オブジェクトを与えます。それは整数ではありません。なぜなら2つの位置の間の文字列は単位によって複数の整数の解釈を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A given &lt;c11&gt;StrLen&lt;/c11&gt; may know that it represents 18 bytes, 7 codepoints, 3 graphemes, and 1 letter in Malayalam, but it might only know this lazily because it actually just hangs onto the two &lt;c12&gt;StrPos&lt;/c12&gt; endpoints within the string that in turn may or may not just lazily point into the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられた&lt;c11&gt;StrLen&lt;/c11&gt;は18 bytes、7 codepoints、3 graphemes、1 letter in Malayalamという表現を知っているでしょう。but it might only know this lazily because it actually just hangs onto the two &lt;c12&gt;StrPos&lt;/c12&gt; endpoints within the string that in turn may or may not just lazily point into the string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The lazy implementation of &lt;c13&gt;StrLen&lt;/c13&gt; is much like a &lt;c14&gt;Range&lt;/c14&gt; object in that respect.) &lt;br15/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(&lt;c13&gt;StrLen&lt;/c13&gt;のいいかげんな実装は&lt;c14&gt;Range&lt;/c14&gt;オブジェクトの関連です。)&lt;br15/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c2&gt;StrPos&lt;/c2&gt; or &lt;c3&gt;StrLen&lt;/c3&gt; is forced into a numeric context, it will assume the units of the current Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;StrPos&lt;/c2&gt;か&lt;c3&gt;StrLen&lt;/c3&gt;が数値コンテキストで強制されると、現在のユニコード抽象化レベルの単位と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c18&gt;Str&lt;/c18&gt; types, &lt;c19&gt;Buf&lt;/c19&gt; types prefer to deal with integer string positions, and map these directly to the underlying compact array as indices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c18&gt;Str&lt;/c18&gt;型と異なり、&lt;c19&gt;Buf&lt;/c19&gt;型は整数の文字列位置で対処することを好みます。そしてそれらを直接に基礎的でコンパクトな配列にインデックスとしてマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin string operations on &lt;c20&gt;Buf&lt;/c20&gt; types return integers and expect integers when dealing with positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c20&gt;Buf&lt;/c20&gt;型の組み込みの文字列操作は整数を返し、位置を処理する時には整数を期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a limiting case, &lt;c21&gt;buf8&lt;/c21&gt; is just an old-school byte string, and the positions are byte positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>限られた場合で、&lt;c21&gt;buf8&lt;/c21&gt;はただの古いバイト文字列で、位置はバイト位置です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, though, that if you remap a section of &lt;c22&gt;buf32&lt;/c22&gt; memory to be &lt;c23&gt;buf8&lt;/c23&gt;, you'll have to multiply all your positions by 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただし、&lt;c22&gt;buf32&lt;/c22&gt;のメモリを&lt;c23&gt;buf8&lt;/c23&gt;にリマップするなら全てのポジションを4倍する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the built-in numeric operators treat an argument of &lt;c4&gt;*&lt;/c4&gt; as indicating the desire to create a function of a single unknown, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの組み込み数値演算子は&lt;c4&gt;*&lt;/c4&gt;の引数を単一の未知の関数を作成することを満たすと認識します。つまり以下の式は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final element of an array is subscripted as &lt;c4&gt;@a[*-1]&lt;/c4&gt;, which means that when the subscripting operation discovers a &lt;c5&gt;Code&lt;/c5&gt; object for a subscript, it calls it and supplies an argument indicating the number of elements in (that dimension of) the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最後の要素の添字は&lt;c4&gt;@a[*-1]&lt;/c4&gt;で表され、添字操作が &lt;c5&gt;Code&lt;/c5&gt;オブジェクトを添字に見つけると、それが呼ばれて配列の要素数を供給します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variant of &lt;c8&gt;*&lt;/c8&gt; is the &lt;c9&gt;**&lt;/c9&gt; term, which is of type &lt;c10&gt;HyperWhatever&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;*&lt;/c8&gt;の変化形は&lt;c9&gt;**&lt;/c9&gt;で、&lt;c10&gt;HyperWhatever&lt;/c10&gt;型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally understood to be a multidimension form of &lt;c11&gt;*&lt;/c11&gt; when that makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは一般的には多次元形式の&lt;c11&gt;*&lt;/c11&gt;と理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When modified by an operator that would turn &lt;c12&gt;*&lt;/c12&gt; into a function of one argument, &lt;c13&gt;**&lt;/c13&gt; instead turns into a function with a slurpy argument, of type &lt;c14&gt;Code:(*@)&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子によって&lt;c12&gt;*&lt;/c12&gt;が1つの引数の関数に変換される時、 &lt;c13&gt;**&lt;/c13&gt;は代わりにslurpyな引数の関数、&lt;c14&gt;Code:(*@)&lt;/c14&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of &lt;c5&gt;Whatever&lt;/c5&gt; is always controlled by its immediate context.) &lt;br6/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;Whatever&lt;/c5&gt;の意味は常にその場のコンテキストによってコントロールされます。)&lt;br6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other uses for &lt;c8&gt;*&lt;/c8&gt; and &lt;c9&gt;**&lt;/c9&gt; will doubtless suggest themselves over time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;*&lt;/c8&gt;と&lt;c9&gt;**&lt;/c9&gt;の他の用途はそのうちにそれら自身で示されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general a &lt;c10&gt;Whatever&lt;/c10&gt; should be interpreted as maximizing the degrees of freedom in a dwimmy way, not as a nihilistic &quot;don't care anymore--just shoot me&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的に&lt;c10&gt;Whatever&lt;/c10&gt;は期待通りに動作するように自由度を最大限にするものとして解釈されるべきです。虚無的な「何も気にするな―ただ私を打て」ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;$x&lt;/c2&gt; may be bound to any object, including any object that can be bound to any other sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;$x&lt;/c2&gt;はどのような他のsigilにもバインドされることができるどのようなオブジェクトも含む、どの様なオブジェクトにもバインドされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, when interpolating into list context, &lt;c3&gt;$x&lt;/c3&gt; never expands its object to anything other than the object itself as a single item, even if the object is a container object containing multiple items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特にリストコンテキストに差し込む時に、オブジェクトが複数のアイテムを含むコンテナでさえ&lt;c3&gt;$x&lt;/c3&gt;は他の何にも展開されず、単一アイテムのオブジェクト自身になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;@x&lt;/c6&gt; may be bound to an object of the &lt;c7&gt;Array&lt;/c7&gt; class, but it may also be bound to any object that does the &lt;c8&gt;Positional&lt;/c8&gt; role, such as a &lt;c9&gt;List&lt;/c9&gt;, &lt;c10&gt;Seq&lt;/c10&gt;, &lt;c11&gt;Range&lt;/c11&gt;, &lt;c12&gt;Buf&lt;/c12&gt;, or &lt;c13&gt;Capture&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;@x&lt;/c6&gt;は&lt;c7&gt;Array&lt;/c7&gt;クラスのオブジェクトにバインドされるでしょう。しかし&lt;c9&gt;List&lt;/c9&gt;、&lt;c10&gt;Seq&lt;/c10&gt;、&lt;c11&gt;Range&lt;/c11&gt;、&lt;c12&gt;Buf&lt;/c12&gt;または&lt;c13&gt;Capture&lt;/c13&gt;のような&lt;c8&gt;Positional&lt;/c8&gt; roleを行うオブジェクトにもバインドされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c14&gt;Positional&lt;/c14&gt; role implies the ability to support &lt;c15&gt;postcircumfix:&lt;[ ]&gt;&lt;/c15&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c14&gt;Positional&lt;/c14&gt; roleは&lt;c15&gt;postcircumfix:&lt;[ ]&gt;&lt;/c15&gt;をサポートする能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, &lt;c18&gt;%x&lt;/c18&gt; may be bound to any object that does the &lt;c19&gt;Associative&lt;/c19&gt; role, such as &lt;c20&gt;Pair&lt;/c20&gt;, &lt;c21&gt;Mapping&lt;/c21&gt;, &lt;c22&gt;Set&lt;/c22&gt;, &lt;c23&gt;Bag&lt;/c23&gt;, &lt;c24&gt;KeyHash&lt;/c24&gt;, or &lt;c25&gt;Capture&lt;/c25&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に&lt;c18&gt;%x&lt;/c18&gt;は&lt;c20&gt;Pair&lt;/c20&gt;、&lt;c21&gt;Mapping&lt;/c21&gt;、&lt;c22&gt;Set&lt;/c22&gt;、&lt;c23&gt;Bag&lt;/c23&gt;、&lt;c24&gt;KeyHash&lt;/c24&gt;または&lt;c25&gt;Capture&lt;/c25&gt;のような&lt;c19&gt;Associative&lt;/c19&gt; roleを行うどのようなオブジェクトにもバインドされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c26&gt;Associative&lt;/c26&gt; role implies the ability to support &lt;c27&gt;postcircumfix:&lt;{ }&gt;&lt;/c27&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c26&gt;Associative&lt;/c26&gt; roleは&lt;c27&gt;postcircumfix:&lt;{ }&gt;&lt;/c27&gt;をサポートする能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c30&gt;&amp;x&lt;/c30&gt; may be bound to any object that does the &lt;c31&gt;Callable&lt;/c31&gt; role, such as any &lt;c32&gt;Block&lt;/c32&gt; or &lt;c33&gt;Routine&lt;/c33&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c30&gt;&amp;x&lt;/c30&gt;は&lt;c32&gt;Block&lt;/c32&gt;や&lt;c33&gt;Routine&lt;/c33&gt;のような&lt;c31&gt;Callable&lt;/c31&gt; roleを行うどのようなオブジェクトにもバインドされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c34&gt;Callable&lt;/c34&gt; role implies the ability to support &lt;c35&gt;postcircumfix:&lt;( )&gt;&lt;/c35&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c34&gt;Callable&lt;/c34&gt; roleは&lt;c35&gt;postcircumfix:&lt;( )&gt;&lt;/c35&gt;をサポートする能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c38&gt;::x&lt;/c38&gt; may be bound to any object that does the &lt;c39&gt;Abstraction&lt;/c39&gt; role, such as a package, module, class, role, grammar, or any other type object, or any immutable value object that can be used as a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c38&gt;::x&lt;/c38&gt;はパッケージ、モジュール、クラス、他のタイプオブジェクト、タイプとして使用できる変更可能な値型オブジェクトのような &lt;c39&gt;Abstraction&lt;/c39&gt; roleを行うどのようなオブジェクトにもバインドされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;c40&gt;Abstraction&lt;/c40&gt; role implies the ability to do various symbol table and/or typological manipulations which may or may not be supported by any given abstraction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c40&gt;Abstraction&lt;/c40&gt; roleは様々なシンボルテーブルと/または類型的な操作（与えられた抽象化によってサポートされていてもいなくてもよい）を行う能力を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to bind an object that doesn't yet do the appropriate role, you must either stick with the generic &lt;c43&gt;$&lt;/c43&gt; sigil, or mix in the appropriate role before binding to a more specific sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしまだ適切なroleを行わないオブジェクトをバインドしたい場合、ジェネリックな&lt;c43&gt;$&lt;/c43&gt; sigilを押しつけるか、より特定したsigilにバインドする前に適切なroleを混合するかどちらかにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object is allowed to support both &lt;c46&gt;Positional&lt;/c46&gt; and &lt;c47&gt;Associative&lt;/c47&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトは&lt;c46&gt;Positional&lt;/c46&gt;と&lt;c47&gt;Associative&lt;/c47&gt;の両方をサポートすることが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that does not support &lt;c48&gt;Positional&lt;/c48&gt; may not be bound directly to &lt;c49&gt;@x&lt;/c49&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c48&gt;Positional&lt;/c48&gt;をサポートしないオブジェクトは直接に&lt;c49&gt;@x&lt;/c49&gt;にバインドされることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, any construct such as &lt;c50&gt;%x&lt;/c50&gt; that can interpolate the contents of such an object into list context can automatically construct a list value that may then be bound to an array variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、リストコンテキストでそのようなオブジェクトの内容を挿入できる&lt;c50&gt;%x&lt;/c50&gt;のような構造は配列変数にバインドできるようなリスト値を自動的に構築できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: &lt;c4&gt;.fmt('%03d', ', ')&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列をコンマで区切った値にフォーマットするには2つ目の引数を与えて下さい: &lt;c4&gt;.fmt('%03d', ', ')&lt;/c4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: &lt;c5&gt;.fmt('%s: %s', &quot;\n&quot;)&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュかpairsのリストをフォーマットするには最初の文字列にキーとハッシュ両方をフォーマットに含めて下さい: &lt;c5&gt;.fmt('%s: %s', &quot;\n&quot;)&lt;/c5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09 for more on slice context.) &lt;br1/&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sliceコンテキストの詳細はS09を参照して下さい。) &lt;br1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c3&gt;List&lt;/c3&gt; objects, &lt;c4&gt;Capture&lt;/c4&gt; objects are immutable in the abstract, but evaluate their arguments lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;List&lt;/c3&gt;オブジェクトのように&lt;c4&gt;Capture&lt;/c4&gt;オブジェクトは抽象的には不変ですが、引数の評価はいいかげんです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before everything inside a &lt;c5&gt;Capture&lt;/c5&gt; is fully evaluated (which happens at compile time when all the arguments are constants), the eventual value may well be unknown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;Capture&lt;/c5&gt;内の全てのものが完全に評価される前(全ての引数が定数の場合はコンパイル時に起こる)、結果として生ずる値は未知かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c8&gt;Capture&lt;/c8&gt; objects may contain multiple unresolved iterators such as feeds or slices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;Capture&lt;/c8&gt;オブジェクトはフィードやスライスのような複数の未解決のイテレータを含むでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may retrieve parts from a &lt;c11&gt;Capture&lt;/c11&gt; object with a prefix sigil operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前置のsigil演算子で&lt;c11&gt;Capture&lt;/c11&gt;オブジェクトからパーツを取得するでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special syntax form &lt;c2&gt;$()&lt;/c2&gt; translates into &lt;c3&gt;$( $.ast // Str($/) )&lt;/c3&gt; to operate on the current match object; similarly &lt;c4&gt;@()&lt;/c4&gt; and &lt;c5&gt;%()&lt;/c5&gt; can extract positional and named submatches.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な文法形式&lt;c2&gt;$()&lt;/c2&gt;は&lt;c3&gt;$( $.ast // Str($/) )&lt;/c3&gt;に変換され、それは現在のマッチオブジェクトを操作するためのものです。似たように&lt;c4&gt;@()&lt;/c4&gt;と&lt;c5&gt;%()&lt;/c5&gt;はポジショナルと名前付きサブマッチを抽出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, you can think of Perl 5 references as a degenerate form of &lt;c9&gt;Capture&lt;/c9&gt; when you want to refer only to a single item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に、Perl 5のリファレンスはシングルアイテムを参照したい時の&lt;c9&gt;Capture&lt;/c9&gt;の縮小した形式と考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applied to a &lt;c2&gt;Capture&lt;/c2&gt; argument, the signature allows you to take the types of the capture's arguments from &lt;c3&gt;MySig&lt;/c3&gt;, but declare the (untyped) variable names yourself via an additional signature in parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;Capture&lt;/c2&gt;引数に適用された時、シグネチャは&lt;c3&gt;MySig&lt;/c3&gt;からcaptureの引数の型を受け取ることができます。しかし(型の指定が無い)変数名を括弧内の追加のシグネチャによってあなた自身が宣言すると:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i3&gt;name&lt;/i3&gt; is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;i3&gt;名前&lt;/i3&gt;はsigilを数えない変数名の適正な部分です。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
