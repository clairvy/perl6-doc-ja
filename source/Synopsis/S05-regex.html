<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>Synopsis 5: Regexes and Rules</title>
</head>
<div class="pod">
<h1 id="TITLE">TITLE</h1>
<div id="TITLE_CONTENT">
<p>Synopsis 5: Regexes and Rules</p>
</div>
<h1 id="AUTHORS">AUTHORS</h1>
<div id="AUTHORS_CONTENT">
<pre>Damian Conway &lt;damian@conway.org&gt;
Allison Randal &lt;al@shadowed.net&gt;
Patrick Michaud &lt;pmichaud@pobox.com&gt;
Larry Wall &lt;larry@wall.org&gt;
</pre>
</div>
<h1 id="VERSION">VERSION</h1>
<div id="VERSION_CONTENT">
<pre>Created: 24 Jun 2002

Last Modified: 30 May 2009
Version: 99
</pre>
<p>This document summarizes Apocalypse 5, which is about the new regex
syntax.  We now try to call them <i>regex</i> rather than &quot;regular
expressions&quot; because they haven't been regular expressions for a
long time, and we think the popular term &quot;regex&quot; is in the process of
becoming a technical term with a precise meaning of: &quot;something you do
pattern matching with, kinda like a regular expression&quot;.  On the other
hand, one of the purposes of the redesign is to make portions of
our patterns more amenable to analysis under traditional regular
expression and parser semantics, and that involves making careful
distinctions between which parts of our patterns and grammars are
to be treated as declarative, and which parts as procedural.</p>
<p>In any case, when referring to recursive patterns within a grammar,
the terms <i>rule</i> and <i>token</i> are generally preferred over <i>regex</i>.</p>
</div>
<h1 id="New_match_result_and_capture_variabl">New match result and capture variables</h1>
<div id="New_match_result_and_capture_variabl-2">
<p>The underlying match object is now available via the <code>$/</code>
variable, which is implicitly lexically scoped.  All user access to the
most recent match is through this variable, even when
it doesn't look like it.  The individual capture variables (such as <code>$0</code>,
<code>$1</code>, etc.) are just elements of <code>$/</code>.</p>
<p>By the way, unlike in Perl 5, the numbered capture variables now
start at <code>$0</code> instead of <code>$1</code>.  See below.</p>
</div>
<h1 id="Unchanged_syntactic_features">Unchanged syntactic features</h1>
<div id="Unchanged_syntactic_features_CONTENT">
<p>The following regex features use the same syntax as in Perl 5:</p>
<ul>
		<li><p>Capturing: (...)	</p></li>
		<li><p>Repetition quantifiers: *, +, and ?	</p></li>
		<li><p>Alternatives:  |	</p></li>
		<li><p>Backslash escape:  \	</p></li>
		<li><p>Minimal matching suffix:   ??,  *?,  +?</p></li>
</ul>

<p>While the syntax of <code>|</code> does not change, the default semantics do
change slightly.  We are attempting to concoct a pleasing mixture
of declarative and procedural matching so that we can have the
best of both.  In short, you need not write your own tokener for
a grammar because Perl will write one for you.  See the section
below on &quot;Longest-token matching&quot;.</p>
</div>
<h1 id="Simplified_lexical_parsing_of_patter">Simplified lexical parsing of patterns</h1>
<div id="Simplified_lexical_parsing_of_patter-2">
<p>Unlike traditional regular expressions, Perl 6 does not require
you to memorize an arbitrary list of metacharacters.  Instead it
classifies characters by a simple rule.  All glyphs (graphemes)
whose base characters are either the underscore (<code>_</code>) or have
a Unicode classification beginning with 'L' (i.e. letters) or 'N'
(i.e. numbers) are always literal (i.e. self-matching) in regexes. They
must be escaped with a <code>\</code> to make them metasyntactic (in which
case that single alphanumeric character is itself metasyntactic,
but any immediately following alphanumeric character is not).</p>
<p>All other glyphs--including whitespace--are exactly the opposite:
they are always considered metasyntactic (i.e. non-self-matching) and
must be escaped or quoted to make them literal.  As is traditional,
they may be individually escaped with <code>\</code>, but in Perl 6 they may
be also quoted as follows.</p>
<p>Sequences of one or more glyphs of either type (i.e. any glyphs at all)
may be made literal by placing them inside single quotes.  (Double
quotes are also allowed, with the same interpolative semantics as
the current language in which the regex is lexically embedded.)
Quotes create a quantifiable atom, so while</p>
<pre>moose*
</pre>
<p>quantifies only the 'e' and matches &quot;mooseee&quot;, saying</p>
<pre>'moose'*
</pre>
<p>quantifies the whole string and would match &quot;moosemoose&quot;.</p>
<p>Here is a table that summarizes the distinctions:</p>
<pre>             Alphanumerics        Non-alphanumerics         Mixed

 Literal glyphs   a    1    _        \*  \$  \.   \\   \'       K\-9\!
 Metasyntax      \a   \1   \_         *   $   .    \    '      \K-\9!
 Quoted glyphs   'a'  '1'  '_'       '*' '$' '.' '\\' '\''     'K-9!'
</pre>
<p>In other words, identifier glyphs are literal (or metasyntactic when
escaped), non-identifier glyphs are metasyntactic (or literal when
escaped), and single quotes make everything inside them literal.</p>
<p>Note, however, that not all non-identifier glyphs are currently
meaningful as metasyntax in Perl 6 regexes (e.g. <code>\1</code> <code>\_</code> <code>-</code>
<code>!</code>). It is more accurate to say that all unescaped non-identifier
glyphs are <i>potential</i> metasyntax, and reserved for future use.
If you use such a sequence, a helpful compile-time error is issued
indicating that you either need to quote the sequence or define a new
operator to recognize it.</p>
</div>
<h1 id="Modifiers">Modifiers</h1>
<div id="Modifiers_CONTENT">
<ul>
		<li><p>The extended syntax (<code>/x</code>) is no longer required...it's the default.
(In fact, it's pretty much mandatory--the only way to get back to
the old syntax is with the <code>:Perl5</code>/<code>:P5</code> modifier.)	</p></li>
		<li><p>There are no <code>/s</code> or <code>/m</code> modifiers (changes to the meta-characters
replace them - see below).	</p></li>
		<li><p>There is no <code>/e</code> evaluation modifier on substitutions; instead use:</p>
<pre> s/pattern/{ doit() }/
</pre>
<p>or:</p>
<pre> s[pattern] = doit()
</pre>
<p>Instead of <code>/ee</code> say:</p>
<pre> s/pattern/{ eval doit() }/
</pre>
<p>or:</p>
<pre> s[pattern] = eval doit()
</pre>	</p></li>
		<li><p>Modifiers are now placed as adverbs at the <i>start</i> of a match/substitution:</p>
<pre> m:g:i/\s* (\w*) \s* ,?/;
</pre>
<p>Every modifier must start with its own colon.  The delimiter must be
separated from the final modifier by whitespace if it would otherwise be taken
as an argument to the preceding modifier (which is true if and only if
the next character is a left parenthesis.)	</p></li>
		<li><p>The single-character modifiers also have longer versions:</p>
<pre>     :i        :ignorecase
     :a        :ignoreaccent
     :g        :global
</pre>	</p></li>
		<li><p>The <code>:i</code> (or <code>:ignorecase</code>) modifier causes case distinctions to be
ignored in its lexical scope, but not in its dynamic scope.  That is,
subrules always use their own case settings.</p>
<p>The <code>:ii</code> (or <code>:samecase</code>) variant may be used on a substitution to change the
substituted string to the same case pattern as the matched string.</p>
<p>If the pattern is matched without the <code>:sigspace</code> modifier, case
info is carried across on a character by character basis.  If the
right string is longer than the left one, the case of the final
character is replicated.  Titlecase is carried across if possible
regardless of whether the resulting letter is at the beginning of
a word or not; if there is no titlecase character available, the
corresponding uppercase character is used.  (This policy can be
modified within a lexical scope by a language-dependent Unicode
declaration to substitute titlecase according to the orthographic
rules of the specified language.)  Characters that carry no case
information leave their corresponding replacement character unchanged.</p>
<p>If the pattern is matched with <code>:sigspace</code>, then a slightly smarter
algorithm is used which attempts to determine if there is a uniform
capitalization policy over each matched word, and applies the same
policy to each replacement word.  If there doesn't seem to be a uniform
policy on the left, the policy for each word is carried over word by
word, with the last pattern word replicated if necessary.  If a word
does not appear to have a recognizable policy, the replacement word
is translated character for character as in the non-sigspace case.
Recognized policies include:</p>
<pre>lc()
uc()
ucfirst(lc())
lcfirst(uc())
capitalize()
</pre>
<p>In any case, only the officially matched string part of the pattern
match counts, so any sort of lookahead or contextual matching is not
included in the analysis.	</p></li>
		<li><p>The <code>:a</code> (or <code>:ignoreaccent</code>) modifier scopes exactly like <code>:ignorecase</code>
except that it ignores accents instead of case.  It is equivalent
to taking each grapheme (in both target and pattern), converting
both to NFD (maximally decomposed) and then comparing the two base
characters (Unicode non-mark characters) while ignoring any trailing
mark characters.  The mark characters are ignored only for the purpose
of determining the truth of the assertion; the actual text matched
includes all ignored characters, including any that follow the final
base character.</p>
<p>The <code>:aa</code> (or <code>:sameaccent</code>) variant may be used on a substitution to change the
substituted string to the same accent pattern as the matched string.
Accent info is carried across on a character by character basis.  If
the right string is longer than the left one, the remaining characters
are substituted without any modification.  (Note that NFD/NFC distinctions
are usually immaterial, since Perl encapsulates that in grapheme mode.)
Under <code>:sigspace</code> the preceding rules are applied word by word.	</p></li>
		<li><p>The <code>:c</code> (or <code>:continue</code>) modifier causes the pattern to continue
scanning from the specified position (defaulting to <code>$/.to</code>):</p>
<pre> m:c($p)/ pattern /     # start scanning at position $p
</pre>
<p>Note that this does not automatically anchor the pattern to the starting
location.  (Use <code>:p</code> for that.)  The pattern you supply to <code>split</code>
has an implicit <code>:c</code> modifier.</p>
<p>String positions are of type <code>StrPos</code> and should generally be treated
as opaque.	</p></li>
		<li><p>The <code>:p</code> (or <code>:pos</code>) modifier causes the pattern to try to match only at
the specified string position:</p>
<pre> m:pos($p)/ pattern /  # match at position $p
</pre>
<p>If the argument is omitted, it defaults to <code>$/.to</code>.  (Unlike in
Perl 5, the string itself has no clue where its last match ended.)
All subrule matches are implicitly passed their starting position.
Likewise, the pattern you supply to a Perl macro's <code>is parsed</code>
trait has an implicit <code>:p</code> modifier.</p>
<p>Note that</p>
<pre> m:c($p)/pattern/
</pre>
<p>is roughly equivalent to</p>
<pre> m:p($p)/.*? &lt;( pattern )&gt; /
</pre>	</p></li>
		<li><p>The new <code>:s</code> (<code>:sigspace</code>) modifier causes whitespace sequences
to be considered &quot;significant&quot;; they are replaced by a whitespace
matching rule, <code>&lt;.ws&gt;</code>.  That is,</p>
<pre> m:s/ next cmd '='   &lt;condition&gt;/
</pre>
<p>is the same as:</p>
<pre> m/ &lt;.ws&gt; next &lt;.ws&gt; cmd &lt;.ws&gt; '=' &lt;.ws&gt; &lt;condition&gt;/
</pre>
<p>which is effectively the same as:</p>
<pre> m/ \s* next \s+ cmd \s* '=' \s* &lt;condition&gt;/
</pre>
<p>But in the case of</p>
<pre> m:s{(a|\*) (b|\+)}
</pre>
<p>or equivalently,</p>
<pre> m { (a|\*) &lt;.ws&gt; (b|\+) }
</pre>
<p><code>&lt;.ws&gt;</code> can't decide what to do until it sees the data.
It still does the right thing.  If not, define your own <code>ws</code>
and <code>:sigspace</code> will use that.</p>
<p>In general you don't need to use <code>:sigspace</code> within grammars because
the parser rules automatically handle whitespace policy for you.
In this context, whitespace often includes comments, depending on
how the grammar chooses to define its whitespace rule.  Although the
default <code>&lt;.ws&gt;</code> subrule recognizes no comment construct, any
grammar is free to override the rule.  The <code>&lt;.ws&gt;</code> rule is not
intended to mean the same thing everywhere.</p>
<p>It's also possible to pass an argument to <code>:sigspace</code> specifying
a completely different subrule to apply.  This can be any rule, it
doesn't have to match whitespace.  When discussing this modifier, it is
important to distinguish the significant whitespace in the pattern from
the &quot;whitespace&quot; being matched, so we'll call the pattern's whitespace
<i>sigspace</i>, and generally reserve <i>whitespace</i> to indicate whatever
<code>&lt;.ws&gt;</code> matches in the current grammar. The correspondence
between sigspace and whitespace is primarily metaphorical, which is
why the correspondence is both useful and (potentially) confusing.</p>
<p>The <code>:ss</code> (or <code>:samespace</code>) variant may be used on substitutions to
do smart space mapping.  For each sigspace-induced call to <code>&lt;ws&gt;</code>
on the left, the matched whitespace is copied over to the corresponding
slot on the right, as represented by a single whitespace character
in the replacement string wherever space replacement is desired.
If there are more whitespace slots on the right than the left, those
righthand characters remain themselves.  If there are not enough
whitespace slots on the right to map all the available whitespace
slots from the match, the algorithm tries to minimize information
loss by randomly splicing &quot;common&quot; whitespace characters out of the
list of whitespace.  From least valuable to most, the pecking order is:</p>
<pre>spaces
tabs
all other horizontal whitespace, including Unicode
newlines (including crlf as a unit)
all other vertical whitespace, including Unicode
</pre>
<p>The primary intent of these rules is to minimize format disruption
when substitution happens across line boundaries and such.  There is,
of course, no guarantee that the result will be exactly what a human would
do.</p>
<p>The <code>:s</code> modifier is considered sufficiently important that
match variants are defined for them:</p>
<pre>mm/match some words/                        # same as m:sigspace
ss/match some words/replace those words/    # same as s:samespace
</pre>
<p>Note that <code>ss///</code> is defined in terms of <code>:ss</code>, so:</p>
<pre>$_ = &quot;a b\nc\td&quot;;
ss/b c d/x y z/;
</pre>
<p>ends up with a value of &quot;<code>a x\ny\tz</code>&quot;.	</p></li>
		<li><p>New modifiers specify Unicode level:</p>
<pre> m:bytes  / .**2 /       # match two bytes
 m:codes  / .**2 /       # match two codepoints
 m:graphs / .**2 /       # match two language-independent graphemes
 m:chars  / .**2 /       # match two characters at current max level
</pre>
<p>There are corresponding pragmas to default to these levels.  Note that
the <code>:chars</code> modifier is always redundant because dot always matches
characters at the highest level allowed in scope.  This highest level
may be identical to one of the other three levels, or it may be more
specific than <code>:graphs</code> when a particular language's character rules
are in use.  Note that you may not specify language-dependent character
processing without specifying <i>which</i> language you're depending on.
[Conjecture: the <code>:chars</code> modifier could take an argument specifying
which language's rules to use for this match.]	</p></li>
		<li><p>The new <code>:Perl5</code>/<code>:P5</code> modifier allows Perl 5 regex syntax to be
used instead.  (It does not go so far as to allow you to put your
modifiers at the end.)  For instance,</p>
<pre> m:P5/(?mi)^(?:[a-z]|\d){1,2}(?=\s)/
</pre>
<p>is equivalent to the Perl 6 syntax:</p>
<pre>m/ :i ^^ [ &lt;[a..z]&gt; || \d ] ** 1..2 &lt;?before \s&gt; /
</pre>	</p></li>
		<li><p>Any integer modifier specifies a count. What kind of count is
determined by the character that follows.	</p></li>
		<li><p>If followed by an <code>x</code>, it means repetition.  Use <code>:x(4)</code> for the
general form.  So</p>
<pre> s:4x [ (&lt;.ident&gt;) '=' (\N+) $$] = &quot;$0 =&gt; $1&quot;;
</pre>
<p>is the same as:</p>
<pre> s:x(4) [ (&lt;.ident&gt;) '=' (\N+) $$] = &quot;$0 =&gt; $1&quot;;
</pre>
<p>which is almost the same as:</p>
<pre> s:c[ (&lt;.ident&gt;) '=' (\N+) $$] = &quot;$0 =&gt; $1&quot; for 1..4;
</pre>
<p>except that the string is unchanged unless all four matches are found.
However, ranges are allowed, so you can say <code>:x(1..4)</code> to change anywhere
from one to four matches.	</p></li>
		<li><p>If the number is followed by an <code>st</code>, <code>nd</code>, <code>rd</code>, or <code>th</code>, it means
find the <i>N</i>th occurrence.  Use <code>:nth(3)</code> for the general form.  So</p>
<pre> s:3rd/(\d+)/@data[$0]/;
</pre>
<p>is the same as</p>
<pre> s:nth(3)/(\d+)/@data[$0]/;
</pre>
<p>which is the same as:</p>
<pre> m/(\d+)/ &amp;&amp; m:c/(\d+)/ &amp;&amp; s:c/(\d+)/@data[$0]/;
</pre>
<p>Lists and junctions are allowed: <code>:nth(1|2|3|5|8|13|21|34|55|89)</code>.</p>
<p>So are closures: <code>:nth({.is_fibonacci})</code>	</p></li>
		<li><p>With the new <code>:ov</code> (<code>:overlap</code>) modifier, the current regex will
match at all possible character positions (including overlapping)
and return all matches in list context, or a disjunction of matches
in item context.  The first match at any position is returned.
The matches are guaranteed to be returned in left-to-right order with
respect to the starting positions.</p>
<pre> $str = &quot;abracadabra&quot;;

 if $str ~~ m:overlap/ a (.*) a / {
     @substrings = @@();    # bracadabr cadabr dabr br
 }
</pre>	</p></li>
		<li><p>With the new <code>:ex</code> (<code>:exhaustive</code>) modifier, the current regex will
match every possible way (including overlapping) and return all matches
in a list context, or a disjunction of matches in item context.
The matches are guaranteed to be returned in left-to-right order with
respect to the starting positions.  The order within each starting
position is not guaranteed and may depend on the nature of both the
pattern and the matching engine.  (Conjecture: or we could enforce
backtracking engine semantics.  Or we could guarantee no order at all
unless the pattern starts with &quot;::&quot; or some such to suppress DFAish
solutions.)</p>
<pre> $str = &quot;abracadabra&quot;;

 if $str ~~ m:exhaustive/ a (.*?) a / {
     say &quot;@()&quot;;    # br brac bracad bracadabr c cad cadabr d dabr br
 }
</pre>
<p>Note that the <code>~~</code> above can return as soon as the first match is found,
and the rest of the matches may be performed lazily by <code>@()</code>.	</p></li>
		<li><p>The new <code>:rw</code> modifier causes this regex to <i>claim</i> the current
string for modification rather than assuming copy-on-write semantics.
All the captures in <code>$/</code> become lvalues into the string, such
that if you modify, say, <code>$1</code>, the original string is modified in
that location, and the positions of all the other fields modified
accordingly (whatever that means).  In the absence of this modifier
(especially if it isn't implemented yet, or is never implemented),
all pieces of <code>$/</code> are considered copy-on-write, if not read-only.</p>
<p>[Conjecture: this should really associate a pattern with a string variable,
not a (presumably immutable) string value.]	</p></li>
		<li><p>The new <code>:keepall</code> modifier causes this regex and all invoked subrules
to remember everything, even if the rules themselves don't ask for
their subrules to be remembered.  This is for forcing a grammar that
throws away whitespace and comments to keep them instead.	</p></li>
		<li><p>The new <code>:ratchet</code> modifier causes this regex to not backtrack by default.
(Generally you do not use this modifier directly, since it's implied by
<code>token</code> and <code>rule</code> declarations.)  The effect of this modifier is
to imply a <code>:</code> after every construct that could backtrack, including
bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers, as well as alternations.
(Note: for portions of patterns subject to longest-token analysis, a <code>:</code>
is ignored in any case, since there will be no backtracking necessary.)	</p></li>
		<li><p>The new <code>:panic</code> modifier causes this regex and all invoked subrules
to try to backtrack on any rules that would otherwise default to
not backtracking because they have <code>:ratchet</code> set.  Never panic
unless you're desperate and want the pattern matcher to do a lot of
unnecessary work.  If you have an error in your grammar, it's almost
certainly a bad idea to fix it by backtracking.	</p></li>
		<li><p>The <code>:i</code>, <code>:s</code>, <code>:Perl5</code>, and Unicode-level modifiers can be
placed inside the regex (and are lexically scoped):</p>
<pre> m/:s alignment '=' [:i left|right|cent[er|re]] /
</pre>
<p>As with modifiers outside, only parentheses are recognized as valid
brackets for args to the adverb.  In particular:</p>
<pre>m/:foo[xxx]/        Parses as :foo [xxx]
m/:foo{xxx}/        Parses as :foo {xxx}
m/:foo&lt;xxx&gt;/        Parses as :foo &lt;xxx&gt;
</pre>	</p></li>
		<li><p>User-defined modifiers will be possible:</p>
<pre>     m:fuzzy/pattern/;
</pre>	</p></li>
		<li><p>User-defined modifiers can also take arguments, but only in parentheses:</p>
<pre>     m:fuzzy('bare')/pattern/;
</pre>	</p></li>
		<li><p>To use parens for your delimiters you have to separate:</p>
<pre>     m:fuzzy (pattern);
</pre>
<p>or you'll end up with:</p>
<pre>     m:fuzzy(fuzzyargs); pattern ;
</pre></p></li>
</ul>
</div>
<h1 id="Changed_metacharacters">Changed metacharacters</h1>
<div id="Changed_metacharacters_CONTENT">
<ul>
		<li><p>A dot <code>.</code> now matches <i>any</i> character including newline. (The <code>/s</code>
modifier is gone.)	</p></li>
		<li><p><code>^</code> and <code>$</code> now always match the start/end of a string, like the old
<code>\A</code> and <code>\z</code>. (The <code>/m</code> modifier is gone.)  On the right side of
an embedded <code>~~</code> or <code>!~~</code> operator they always match the start/end
of the indicated submatch because that submatch is logically being
treated as a separate string.	</p></li>
		<li><p>A <code>$</code> no longer matches an optional preceding <code>\n</code> so it's necessary
to say <code>\n?$</code> if that's what you mean.	</p></li>
		<li><p><code>\n</code> now matches a logical (platform independent) newline not just <code>\x0a</code>.	</p></li>
		<li><p>The <code>\A</code>, <code>\Z</code>, and <code>\z</code> metacharacters are gone.</p></li>
</ul>
</div>
<h1 id="New_metacharacters">New metacharacters</h1>
<div id="New_metacharacters_CONTENT">
<ul>
		<li><p>Because <code>/x</code> is default:		<li><p>
			<ul>
					<li><p>An unescaped <code>#</code> now always introduces a comment.  If followed
by an opening bracket character (and if not in the first column),
it introduces an embedded comment that terminates with the closing
bracket.  Otherwise the comment terminates at the newline.				</p></li>
					<li><p>Whitespace is now always metasyntactic, i.e. used only for layout
and not matched literally (but see the <code>:sigspace</code> modifier described above).</p></li>
</ul>

		</p></li>
	</p></li>
		<li><p><code>^^</code> and <code>$$</code> match line beginnings and endings. (The <code>/m</code>
modifier is gone.)  They are both zero-width assertions.  <code>$$</code>
matches before any <code>\n</code> (logical newline), and also at the end of
the string if the final character was <i>not</i> a <code>\n</code>.  <code>^^</code> always
matches the beginning of the string and after any <code>\n</code> that is not
the final character in the string.	</p></li>
		<li><p><code>.</code> matches an <i>anything</i>, while <code>\N</code> matches an <i>anything except
newline</i>. (The <code>/s</code> modifier is gone.)  In particular, <code>\N</code> matches
neither carriage return nor line feed.	</p></li>
		<li><p>The new <code>&amp;</code> metacharacter separates conjunctive terms.  The patterns
on either side must match with the same beginning and end point.
Note: if you don't want your two terms to end at the same point,
then you really want to use a lookahead instead.</p>
<p>As with the disjunctions <code>|</code> and <code>||</code>, conjuctions come in both
<code>&amp;</code> and <code>&amp;&amp;</code> forms.  The <code>&amp;</code> form is considered declarative rather than
procedural; it allows the compiler and/or the
run-time system to decide which parts to evaluate first, and it is
erroneous to assume either order happens consistently.  The <code>&amp;&amp;</code>
form guarantees left-to-right order, and backtracking makes the right
argument vary faster than the left.  In other words, <code>&amp;&amp;</code> and <code>||</code> establish
sequence points.  The left side may be backtracked into when backtracking
is allowed into the construct as a whole.</p>
<p>The <code>&amp;</code> operator is list associative like <code>|</code>, but has slightly
tighter precedence.  Likewise <code>&amp;&amp;</code> has slightly tighter precedence
than <code>||</code>.  As with the normal junctional and short-circuit operators,
<code>&amp;</code> and <code>|</code> are both tighter than <code>&amp;&amp;</code> and <code>||</code>.	</p></li>
		<li><p>The <code>~~</code> and <code>!~~</code> operators cause a submatch to be performed on
whatever was matched by the variable or atom on the left.  String
anchors consider that submatch to be the entire string.  So, for
instance, you can ask to match any identifier that does not contain
the word &quot;moose&quot;:</p>
<pre>&lt;ident&gt; !~~ 'moose'
</pre>
<p>In contrast</p>
<pre>&lt;ident&gt; !~~ ^ 'moose' $
</pre>
<p>would allow any identifier (including any identifier containing
&quot;moose&quot; as a substring) as long as the identifier as a whole is not
equal to &quot;moose&quot;. (Note the anchors, which attach the submatch to the
beginning and end of the identifier as if that were the entire match.)
When used as part of a longer match, for clarity it might be good to
use extra brackets:</p>
<pre>[ &lt;ident&gt; !~~ ^ 'moose' $ ]
</pre>
<p>The precedence of <code>~~</code> and <code>!~~</code> fits in between the junctional and
sequential versions of the logical operators just as it does in normal
Perl expressions (see S03).  Hence</p>
<pre>&lt;ident&gt; !~~ 'moose' | 'squirrel'
</pre>
<p>parses as</p>
<pre>&lt;ident&gt; !~~ [ 'moose' | 'squirrel' ]
</pre>
<p>while</p>
<pre>&lt;ident&gt; !~~ 'moose' || 'squirrel'
</pre>
<p>parses as</p>
<pre>[ &lt;ident&gt; !~~ 'moose' ] || 'squirrel'
</pre>	</p></li>
		<li><p>The <code>~</code> operator is a helper for matching nested subrules with a
specific terminator as the goal.  It is designed to be placed between an
opening and closing bracket, like so:</p>
<pre>'(' ~ ')' &lt;expression&gt;
</pre>
<p>However, it mostly ignores the left argument, and operates on the next
two atoms (which may be quantified).  Its operation on those next
two atoms is to &quot;twiddle&quot; them so that they are actually matched in
reverse order.  Hence the expression above, at first blush, is merely
shortand for:</p>
<pre>'(' &lt;expression&gt; ')'
</pre>
<p>But beyond that, when it rewrites the atoms it also inserts the
apparatus that will set up the inner expression to recognize the
terminator, and to produce an appropriate error message if the
inner expression does not terminate on the required closing atom.
So it really does pay attention to the left bracket as well, and it
actually rewrites our example to something more like:</p>
<pre>$&lt;OPEN&gt; = '(' &lt;SETGOAL: ')'&gt; &lt;expression&gt; [ $GOAL || &lt;FAILGOAL&gt; ]
</pre>
<p>Note that you can use this construct to set up expectations for
a closing construct even when there's no opening bracket:</p>
<pre>&lt;?&gt; ~ ')' \d+
</pre>
<p>Here &lt;?&gt; returns true on the first null string.</p>
<p>By default the error message uses the name of the current rule as an
indicator of the abstract goal of the parser at that point.  However,
often this is not terribly informative, especially when rules are named
according to an internal scheme that will not make sense to the user.
The <code>:dba(&quot;doing business as&quot;)</code> adverb may be used to set up a more informative name for
what the following code is trying to  parse:</p>
<pre>token postfix:sym&lt;[ ]&gt; {
    :dba('array subscript')
    '[' ~ ']' &lt;expression&gt;
}
</pre>
<p>Then instead of getting a message like:</p>
<pre>Unable to parse expression in postfix:sym&lt;[ ]&gt;; couldn't find final ']'
</pre>
<p>you'll get a message like:</p>
<pre>Unable to parse expression in array subscript; couldn't find final ']'
</pre>
<p>(The <code>:dba</code> adverb may also be used to give names to alternations
and alternatives, which helps the lexer give better error messages.)</p></li>
</ul>
</div>
<h1 id="Bracket_rationalization">Bracket rationalization</h1>
<div id="Bracket_rationalization_CONTENT">
<ul>
		<li><p><code>(...)</code> still delimits a capturing group. However the ordering of these
groups is hierarchical rather than linear. See <a href="#Nested_subpattern_captures">Nested subpattern captures</a>.	</p></li>
		<li><p><code>[...]</code> is no longer a character class.
It now delimits a non-capturing group.	</p></li>
		<li><p><code>{...}</code> is no longer a repetition quantifier.
It now delimits an embedded closure.  It is always considered
procedural rather than declarative; it establishes a sequence point
between what comes before and what comes after.  (To avoid this
use the <code>&lt;?{...}&gt;</code> assertion syntax instead.)	</p></li>
		<li><p>You can call Perl code as part of a regex match by using a closure.
Embedded code does not usually affect the match--it is only used
for side-effects:</p>
<pre> / (\S+) { print &quot;string not blank\n&quot;; $text = $0; }
    \s+  { print &quot;but does contain whitespace\n&quot; }
 /
</pre>
<p>An <strong>explicit</strong> reduction using the <code>make</code> function generates the
<i>abstract syntax tree</i> object (<i>abstract object</i> or <i>ast</i> for short)
for this match:</p>
<pre>    / (\d) { make $0.sqrt } Remainder /;
</pre>
<p>This has the effect of capturing the square root of the numified
string, instead of the string.  The <code>Remainder</code> part is matched and
returned as part of the <code>Match</code> object but is not returned
as part of the abstract object.  Since the abstract object usually
represents the top node of an abstract syntax tree, the abstract object
may be extracted from the <code>Match</code> object by use of the <code>.ast</code> method.</p>
<p>A second call to <code>make</code> overrides any previous call to <code>make</code>.</p>
<p>These closures are invoked with a topic (<code>$_</code>) of the current match
state (a <code>Cursor</code> object).  Within a closure, the instantaneous
position within the search is denoted by the <code>.pos</code> method on
that object.  As with all string positions, you must not treat it
as a number unless you are very careful about which units you are
dealing with.</p>
<p>The <code>Cursor</code> object can also return the original item that we are
matching against; this is available from the <code>.orig</code> method.</p>
<p>The closure is also guaranteed to start with a <code>$/</code> <code>Match</code> object
representing the match so far.  However, if the closure does its own
internal matching, its <code>$/</code> variable will be rebound to the result
of <i>that</i> match until the end of the embedded closure.  (The match
will actually continue with the current value of the <code>$¢</code> object after
the closure.  <code>$/</code> and <code>$¢</code> just start out the same in your closure.)	</p></li>
		<li><p>It can affect the match if it calls <code>fail</code>:</p>
<pre> / (\d+) { $0 &lt; 256 or fail } /
</pre>
<p>Since closures establish a sequence point, they are guaranteed to be
called at the canonical time even if the optimizer could prove that
something after them can't match.  (Anything before is fair game,
however.  In particular, a closure often serves as the terminator
of a longest-token pattern.)	</p></li>
		<li><p>The general repetition specifier is now <code>**</code> for maximal matching,
with a corresponding <code>**?</code> for minimal matching.  (All such quantifier
modifiers now go directly after the <code>**</code>.)  Space is allowed on either
side of the complete quantifier.  This space is considered significant
under <code>:sigspace</code>, and will be distributed as a call to &lt;.ws&gt; between
all the elements of the match but not on either end.</p>
<p>The next token will determine what kind of repetition is desired:</p>
<p>If the next thing is an integer, then it is parsed as either as an exact
count or a range:</p>
<pre>. ** 42                  # match exactly 42 times
&lt;item&gt; ** 3..*           # match 3 or more times
</pre>
<p>This form is considered declarational.</p>
<p>If you supply a closure, it should return either an <code>Int</code> or a <code>Range</code> object.</p>
<pre>'x' ** {$m}              # exact count returned from closure
&lt;foo&gt; ** {$m..$n}        # range returned from closure

/ value was (\d **? {1..6}) with ([ &lt;alpha&gt;\w* ]**{$m..$n}) /
</pre>
<p>It is illegal to return a list, so this easy mistake fails:</p>
<pre>/ [foo] ** {1,3} /
</pre>
<p>The closure form is always considered procedural, so the item it is
modifying is never considered part of the longest token.</p>
<p>If you supply any other atom (which may be quantified), it is
interpreted as a separator (such as an infix operator), and the
initial item is quantified by the number of times the separator is
seen between items:</p>
<pre>&lt;alt&gt; ** '|'            # repetition controlled by presence of character
&lt;addend&gt; ** &lt;addop&gt;     # repetition controlled by presence of subrule
&lt;item&gt; ** [ \!?'==' ]   # repetition controlled by presence of operator
&lt;file&gt;**\h+             # repetition controlled by presence of whitespace
</pre>
<p>A successful match of such a quantifier always ends &quot;in the middle&quot;,
that is, after the initial item but before the next separator.
Therefore</p>
<pre>/ &lt;ident&gt; ** ',' /
</pre>
<p>can match</p>
<pre>foo
foo,bar
foo,bar,baz
</pre>
<p>but never</p>
<pre>foo,
foo,bar,
</pre>
<p>It is legal for the separator to be zero-width as long as the pattern on
the left progresses on each iteration:</p>
<pre>. ** &lt;?same&gt;   # match sequence of identical characters
</pre>
<p>The separator never matches independently of the next item; if the
separator matches but the next item fails, it backtracks all the way
back through the separator.  Likewise, this matching of the separator
does not count as &quot;progress&quot; under <code>:ratchet</code> semantics unless the
next item succeeds.</p>
<p>When significant space is used under <code>:sigspace</code> with the separator
form, it applies on both sides of the separator, so</p>
<pre>mm/&lt;element&gt; ** ','/
mm/&lt;element&gt;** ','/
mm/&lt;element&gt; **','/
</pre>
<p>all allow whitespace around the separator like this:</p>
<pre>/ &lt;element&gt;[&lt;.ws&gt;','&lt;.ws&gt;&lt;element&gt;]* /
</pre>
<p>while</p>
<pre>mm/&lt;element&gt;**','/
</pre>
<p>excludes all significant whitespace:</p>
<pre>/ &lt;element&gt;[','&lt;element&gt;]* /
</pre>
<p>Of course, you can always match whitespace explicitly if necessary, so to
allow whitespace after the comma but not before, you can say:</p>
<pre>/ &lt;element&gt;**[','\s*] /
</pre>	</p></li>
		<li><p><code>&lt;...&gt;</code> are now extensible metasyntax delimiters or <i>assertions</i>
(i.e. they replace Perl 5's crufty <code>(?...)</code> syntax).</p></li>
</ul>
</div>
<h1 id="Variable_non_interpolation">Variable (non-)interpolation</h1>
<div id="Variable_non_interpolation_CONTENT">
<ul>
		<li><p>In Perl 6 regexes, variables don't interpolate.	</p></li>
		<li><p>Instead they're passed <i>raw</i> to the regex engine, which can then decide
how to handle them (more on that below).	</p></li>
		<li><p>The default way in which the engine handles a string scalar is to match it
as a <code>'...'</code> literal (i.e. it does not treat the interpolated string
as a subpattern).  In other words, a Perl 6:</p>
<pre> / $var /
</pre>
<p>is like a Perl 5:</p>
<pre> / \Q$var\E /
</pre>
<p>However, if <code>$var</code> contains a <code>Regex</code> object, instead of attempting to
convert it to a string, it is called as a subrule, as if you said
<code>&lt;$var&gt;</code>.  (See assertions below.)  This form does not capture,
and it fails if <code>$var</code> is tainted.</p>
<p>However, a variable used as the left side of an alias or submatch
operator is not used for matching.</p>
<pre>$x = &lt;ident&gt;
$0 ~~ &lt;ident&gt;
</pre>
<p>If you do want to match <code>$0</code> again and then use that as the submatch,
you can force the match using double quotes:</p>
<pre>&quot;$0&quot; ~~ &lt;ident&gt;
</pre>
<p>On the other hand, it is non-sensical to alias to something that is
not a variable:</p>
<pre>&quot;$0&quot; = &lt;ident&gt;     # ERROR
$0 = &lt;ident&gt;       # okay
$x = &lt;ident&gt;       # okay, temporary capture
$&lt;x&gt; = &lt;ident&gt;     # okay, persistent capture
&lt;x=ident&gt;          # same thing
</pre>
<p>Variables declared in capture aliases are lexically scoped to the
rest of the regex.  You should not confuse this use of <code>=</code> with
either ordinary assignment or ordinary binding.  You should read
the <code>=</code> more like the pseudoassignment of a declarator than like
normal assignment.  It's more like the ordinary <code>:=</code> operator,
since at the level regexes work, strings are immutable, so captures
are really just precomputed substr values.  Nevertheless, when you
eventually use the values independently, the substr may be copied,
and then it's more like it was an assignment originally.</p>
<p>Capture variables of the form <code>$&lt;ident&gt;</code> may persist beyond
the lexical scope; if the match succeeds they are remembered in the
<code>Match</code> object's hash, with a key corresponding to the variable name's
identifier.  Likewise bound numeric variables persist as <code>$0</code>, etc.</p>
<p>The capture performed by <code>=</code> creates a new lexical variable if it does
not already exist in the current lexical scope.  To capture to an outer
lexical variable you must supply an <code>OUTER::</code> as part of the name,
or perform the assignment from within a closure.</p>
<pre>$x = [...]                       # capture to our own lexical $x
$OUTER::x = [...]                # capture to existing lexical $x
[...] -&gt; $tmp { let $x = $tmp }  # capture to existing lexical $x
</pre>
<p>Note however that <code>let</code> (and <code>temp</code>) are not guaranteed to be thread
safe on shared variables, so don't do that.	</p></li>
		<li><p>An interpolated array:</p>
<pre> / @cmds /
</pre>
<p>is matched as if it were an alternation of its elements.  Ordinarily it
matches using junctive semantics:</p>
<pre> / [ @cmds[0] | @cmds[1] | @cmds[2] | ... ] /
</pre>

<p>However, if it is a direct member of a <code>||</code> list, it uses sequential
matching semantics, even it's the only member of the list.  Conveniently,
you can put <code>||</code> before the first member of an alternation, hence</p>
<pre> / || @cmds /
</pre>
<p>is equivalent to</p>
<pre> / [ @cmds[0] || @cmds[1] || @cmds[2] || ... ] /
</pre>
<p>Or course, you can also</p>
<pre> / | @cmds /
</pre>
<p>to be clear that you mean junctive semantics.</p>
<p>As with a scalar variable, each element is matched as a literal
unless it happens to be a <code>Regex</code> object, in which case it is matched
as a subrule.  As with scalar subrules, a tainted subrule always fails.
All string values pay attention to the current <code>:ignorecase</code>
and <code>:ignoreaccent</code> settings, while <code>Regex</code> values use their own
<code>:ignorecase</code> and <code>:ignoreaccent</code> settings.</p>
<p>When you get tired of writing:</p>
<pre>token sigil { '$' | '@' | '@@' | '%' | '&amp;' | '::' }
</pre>
<p>you can write:</p>
<pre>token sigil { &lt; $ @ @@ % &amp; :: &gt; }
</pre>
<p>as long as you're careful to put a space after the initial angle so that
it won't be interpreted as a subrule.  With the space it is parsed
like angle quotes in ordinary Perl 6 and treated as a literal array value.	</p></li>
		<li><p>Alternatively, if you predeclare a proto regex, you can write multiple
regexes for the same category, differentiated only by the symbol they
match.  The symbol is specified as part of the &quot;long name&quot;.  It may also
be matched within the rule using <code>&lt;sym&gt;</code>, like this:</p>
<pre>proto token sigil { }
multi token sigil:sym&lt;$&gt;  { &lt;sym&gt; }
multi token sigil:sym&lt;@&gt;  { &lt;sym&gt; }
multi token sigil:sym&lt;@@&gt; { &lt;sym&gt; }
multi token sigil:sym&lt;%&gt;  { &lt;sym&gt; }
multi token sigil:sym&lt;&amp;&gt;  { &lt;sym&gt; }
multi token sigil:sym&lt;::&gt; { &lt;sym&gt; }
</pre>
<p>(The <code>multi</code> is optional and generally omitted with a grammar.)</p>
<p>This can be viewed as a form of multiple dispatch, except that it's
based on longest-token matching rather than signature matching.  The
advantage of writing it this way is that it's easy to add additional
rules to the same category in a derived grammar.  All of them will
be matched in parallel when you try to match <code>/&lt;sigil&gt;/</code>.</p>
<p>If there are formal parameters on multi regex methods, matching
still proceeds via longest-token rules first.  If that results in a
tie, a normal multiple dispatch is made using the arguments to the
remaining variants, assuming they can be differentiated by type.	</p></li>
		<li><p>The use of a hash variable in patterns is reserved.	</p></li>
		<li><p>Variable matches are considered provisionally declarative,
on the assumption that the contents of the variable will not change
frequently.  If it does change, it may force recalculation of any
analysis relying on its supposed declarative nature.  (If you know
this is going to happen too often, put some kind of sequence point
before the variable to disable static analysis such as the generation
of longest-token automata.)</p></li>
</ul>
</div>
<h1 id="Extensible_metasyntax_code_lt_gt_cod">Extensible metasyntax (<code>&lt;...&gt;</code>)</h1>
<div id="Extensible_metasyntax_code_lt_gt_cod-2">
<p>Both <code>&lt;</code> and <code>&gt;</code> are metacharacters, and are usually (but not
always) used in matched pairs.  (Some combinations of metacharacters
function as standalone tokens, and these may include angles.  These are
described below.) Most assertions are considered declarative;
procedural assertions will be marked as exceptions.</p>
<p>For matched pairs, the first character after <code>&lt;</code> determines the
nature of the assertion:</p>
<ul>
		<li><p>If the first character is whitespace, the angles are treated as an
ordinary &quot;quote words&quot; array literal.</p>
<pre>&lt; adam &amp; eve &gt;   # equivalent to [ 'adam' | '&amp;' | 'eve' ]
</pre>
<p>Note that the space before the ending &gt; is optional and therefore
&lt; adam &amp; eve&gt; would be acceptable.	</p></li>
		<li><p>A leading alphabetic character means it's a capturing grammatical
assertion (i.e. a subrule or a named character class - see below):</p>
<pre> / &lt;sign&gt;? &lt;mantissa&gt; &lt;exponent&gt;? /
</pre>
<p>The first character after the identifier determines the treatment of
the rest of the text before the closing angle.  The underlying semantics
is that of a function or method call, so if the first character is
a left parenthesis, it really is a call:</p>
<pre>&lt;foo('bar')&gt;
</pre>
<p>If the first character after the identifier is an <code>=</code>, then the identifier
is taken as an alias for what follows.  In particular,</p>
<pre>&lt;foo=bar&gt;
</pre>
<p>is just shorthand for</p>
<pre>$&lt;foo&gt; = &lt;bar&gt;
</pre>
<p>If the first character after the identifier is whitespace, the
subsequent text (following any whitespace) is passed as a regex, so:</p>
<pre>&lt;foo bar&gt;
</pre>
<p>is more or less equivalent to</p>
<pre>&lt;foo(/bar/)&gt;
</pre>
<p>To pass a regex with leading whitespace you must use the parenthesized form.</p>
<p>If the first character is a colon followed by whitespace, the rest
of the text is taken as a list of arguments to the method, just as
in ordinary Perl syntax.  So these mean the same thing:</p>
<pre>&lt;foo('foo', $bar, 42)&gt;
&lt;foo: 'foo', $bar, 42&gt;
</pre>
<p>No other characters are allowed after the initial identifier.</p>
<p>Subrule matches are considered declarative to the extent that
the front of the subrule is itself considered declarative.  If a
subrule contains a sequence point, then so does the subrule match.
Longest-token matching does not proceed past such a subrule, for
instance.	</p></li>
		<li><p>A leading <code>.</code> causes a named assertion not to capture what it matches (see
<a href="#Subrule_captures">Subrule captures</a>. For example:</p>
<pre> / &lt;ident&gt;  &lt;ws&gt;  /      # $/&lt;ident&gt; and $/&lt;ws&gt; both captured
 / &lt;.ident&gt; &lt;ws&gt;  /      # only $/&lt;ws&gt; captured
 / &lt;.ident&gt; &lt;.ws&gt; /      # nothing captured
</pre>
<p>The assertion is otherwise parsed identically to an assertion beginning with
an identifier, provided the next thing after the dot is an identifier.  As with
the identifier form, any extra arguments pertaining to the matching engine
are automatically supplied to the argument list.</p>
<p>If the dot is not followed by an identifier, it
is parsed as a &quot;dotty&quot; postfix of some type, such as an indirect method call:</p>
<pre>&lt;.$indirect($depth, $binding, $fate, @args)&gt;
</pre>
<p>In this case the object passed as the invocant is the current match
state, and the method is expected to return a new match state object.
The extra pattern matching arguments (<code>$depth</code>, <code>$binding</code>, and
<code>$fate</code>) must be supplied explicitly.</p>
<p>The non-capturing behavior may be overridden with a <code>:keepall</code>.	</p></li>
		<li><p>A leading <code>$</code> indicates an indirect subrule.  The variable must contain
either a <code>Regex</code> object, or a string to be compiled as the regex.  The
string is never matched literally.</p>
<p>Such an assertion is not captured.  (No assertion with leading punctuation
is captured by default.)  You may always capture it explicitly, of course.</p>
<p>A subrule is considered declarative to the extent that the front of it
is declarative, and to the extent that the variable doesn't change.
Prefix with a sequence point to defeat repeated static optimizations.	</p></li>
		<li><p>A leading <code>::</code> indicates a symbolic indirect subrule:</p>
<pre> / &lt;::($somename)&gt; /
</pre>
<p>The variable must contain the name of a subrule.  By the rules of
single method dispatch this is first searched for in the current
grammar and its ancestors.  If this search fails an attempt is made
to dispatch via MMD, in which case it can find subrules defined as
multis rather than methods.  This form is not captured by default.
It is always considered procedural, not declarative.	</p></li>
		<li><p>A leading <code>@</code> matches like a bare array except that each element is
treated as a subrule (string or <code>Regex</code> object) rather than as a literal.
That is, a string is forced to be compiled as a subrule instead of being
matched literally.  (There is no difference for a <code>Regex</code> object.)</p>
<p>This assertion is not automatically captured.	</p></li>
		<li><p>The use of a hash as an assertion is reserved.	</p></li>
		<li><p>A leading <code>{</code> indicates code that produces a regex to be interpolated
into the pattern at that point as a subrule:</p>
<pre> / (&lt;.ident&gt;)  &lt;{ %cache{$0} //= get_body_for($0) }&gt; /
</pre>
<p>The closure is guaranteed to be run at the canonical time; it declares
a sequence point, and is considered to be procedural.	</p></li>
		<li><p>A leading <code>&amp;</code> interpolates the return value of a subroutine call as
a regex.  Hence</p>
<pre> &lt;&amp;foo()&gt;
</pre>
<p>is short for</p>
<pre> &lt;{ foo() }&gt;
</pre>
<p>This is considered procedural.	</p></li>
		<li><p>In any case of regex interpolation, if the value already happens to be
a <code>Regex</code> object, it is not recompiled.  If it is a string, the compiled
form is cached with the string so that it is not recompiled next
time you use it unless the string changes.  (Any external lexical
variable names must be rebound each time though.)  Subrules may not be
interpolated with unbalanced bracketing.  An interpolated subrule
keeps its own inner match results as a single item, so its parentheses never count toward the
outer regexes groupings.  (In other words, parenthesis numbering is always
lexically scoped.)	</p></li>
		<li><p>A leading <code>?{</code> or <code>!{</code> indicates a code assertion:</p>
<pre> / (\d**1..3) &lt;?{ $0 &lt; 256 }&gt; /
 / (\d**1..3) &lt;!{ $0 &lt; 256 }&gt; /
</pre>
<p>Similar to:</p>
<pre> / (\d**1..3) { $0 &lt; 256 or fail } /
 / (\d**1..3) { $0 &lt; 256 and fail } /
</pre>
<p>Unlike closures, code assertions are considered declarative; they are
not guaranteed to be run at the canonical time if the optimizer can
prove something later can't match.  So you can sneak in a call to a
non-canonical closure that way:</p>
<pre> token { foo .* &lt;?{ do { say &quot;Got here!&quot; } or 1 }&gt; .* bar }
</pre>
<p>The <code>do</code> block is unlikely to run unless the string ends with &quot;<code>bar</code>&quot;.	</p></li>
		<li><p>A leading <code>[</code> indicates an enumerated character class.  Ranges
in enumerated character classes are indicated with &quot;<code>..</code>&quot; rather than &quot;<code>-</code>&quot;.</p>
<pre> / &lt;[a..z_]&gt;* /
</pre>
<p>Whitespace is ignored within square brackets:</p>
<pre> / &lt;[ a..z _ ]&gt;* /
</pre>	</p></li>
		<li><p>A leading <code>-</code> indicates a complemented character class:</p>
<pre> / &lt;-[a..z_]&gt; &lt;-alpha&gt; /
 / &lt;- [a..z_]&gt; &lt;- alpha&gt; /  # whitespace allowed after -
</pre>
<p>This is essentially the same as using negative lookahead and dot:</p>
<pre>/ &lt;![a..z_]&gt; . &lt;!alpha&gt; . /
</pre>
<p>Whitespace is ignored after the initial <code>-</code>.	</p></li>
		<li><p>A leading <code>+</code> may also be supplied to indicate that the following
character class is to matched in a positive sense.</p>
<pre> / &lt;+[a..z_]&gt;* /
 / &lt;+[ a..z _ ]&gt;* /
 / &lt;+ [ a .. z _ ] &gt;* /      # whitespace allowed after +
</pre>	</p></li>
		<li><p>Character classes can be combined (additively or subtractively) within
a single set of angle brackets.  Whitespace is ignored. For example:</p>
<pre> / &lt;[a..z] - [aeiou] + xdigit&gt; /      # consonant or hex digit
</pre>
<p>A named character class may be used by itself:</p>
<pre>&lt;alpha&gt;
</pre>
<p>However, in order to combine classes you must prefix a named
character class with <code>+</code> or <code>-</code>.  Whitespace is required before
any <code>-</code> that would be misparsed as an identifier extender.	</p></li>
		<li><p>The special assertion <code>&lt;.&gt;</code> matches any logical grapheme
(including a Unicode combining character sequences):</p>
<pre> / seekto = &lt;.&gt; /  # Maybe a combined char
</pre>
<p>Same as:</p>
<pre> / seekto = [:graphs .] /
</pre>	</p></li>
		<li><p>A leading <code>!</code> indicates a negated meaning (always a zero-width assertion):</p>
<pre> / &lt;!before _ &gt; /    # We aren't before an _
</pre>
<p>Note that <code>&lt;!alpha&gt;</code> is different from <code>&lt;-alpha&gt;</code>.
<code>/&lt;-alpha&gt;/</code> is a complemented character class equivalent to
<code>/&lt;!before &lt;alpha&gt;&gt; ./</code>, whereas <code>&lt;!alpha&gt;</code> is a zero-width
assertion equivalent to a <code>/&lt;!before &lt;alpha&gt;&gt;/</code> assertion.</p>
<p>Note also that as a metacharacter <code>!</code> doesn't change the parsing
rules of whatever follows (unlike, say, <code>+</code> or <code>-</code>).	</p></li>
		<li><p>A leading <code>?</code> indicates a positive zero-width assertion, and like <code>!</code>
merely reparses the rest of the assertion recursively as if the <code>?</code>
were not there.  In addition to forcing zero-width, it also suppresses
any named capture:</p>
<pre>&lt;alpha&gt;     # match a letter and capture to $alpha (eventually $&lt;alpha&gt;)
&lt;.alpha&gt;    # match a letter, don't capture
&lt;?alpha&gt;    # match null before a letter, don't capture
</pre>
<p>The special named assertions include:</p>
<pre> / &lt;?before pattern&gt; /    # lookahead
 / &lt;?after pattern&gt; /     # lookbehind

 / &lt;?same&gt; /              # true between two identical characters

 / &lt;.ws&gt; /                # match &quot;whitespace&quot;:
                          #   \s+ if it's between two \w characters,
                          #   \s* otherwise

 / &lt;?at($pos)&gt; /          # match only at a particular StrPos
                          # short for &lt;?{ .pos === $pos }&gt;
                          # (considered declarative until $pos changes)
</pre>
<p>It is legal to use any of these assertions as named captures by omitting the
punctuation at the front.  However, capture entails some overhead in both
memory and computation, so in general you want to suppress that for data
you aren't interested in preserving.</p>
<p>The <code>after</code> assertion implements lookbehind by reversing the syntax
tree and looking for things in the opposite order going to the left.
It is illegal to do lookbehind on a pattern that cannot be reversed.</p>
<p>Note: the effect of a forward-scanning lookbehind at the top level
can be achieved with:</p>
<pre>/ .*? prestuff &lt;( mainpat )&gt; /
</pre>	</p></li>
		<li><p>The <code>&lt;...&gt;</code>, <code>&lt;???&gt;</code>, and <code>&lt;!!!&gt;</code> special tokens
have the same &quot;not-defined-yet&quot; meanings within regexes that the bare
elipses have in ordinary code.  (However, by the recursive rules above,
<code>&lt;!!&gt;</code> is equivalent to <code>&lt;?&gt;</code>, which matches the null string.
Likewise <code>&lt;!!before x&gt;</code> is just like <code>&lt;?before x&gt;</code>, except
that it is ignored by the longest-token matcher.)	</p></li>
		<li><p>A leading <code>*</code> indicates that the following pattern allows a
partial match.  It always succeeds after matching as many characters
as possible.  (It is not zero-width unless 0 characters match.)
For instance, to match a number of abbreviations, you might write
any of:</p>
<pre>s/ ^ G&lt;*n|enesis&gt;     $ /gen/  or
s/ ^ Ex&lt;*odus&gt;        $ /ex/   or
s/ ^ L&lt;*v|eviticus&gt;   $ /lev/  or
s/ ^ N&lt;*m|umbers&gt;     $ /num/  or
s/ ^ D&lt;*t|euteronomy&gt; $ /deut/ or
...

/ (&lt;* &lt;foo bar baz&gt; &gt;) /

/ &lt;short=*@abbrev&gt; / and return %long{$&lt;short&gt;} || $&lt;short&gt;;
</pre>
<p>The pattern is restricted to declarative forms that can be rewritten
as nested optional character matches.  Sequence information
may not be discarded while making all following characters optional.
That is, it is not sufficient to rewrite:</p>
<pre>&lt;*xyz&gt;
</pre>
<p>as:</p>
<pre>x? y? z?            # bad, would allow xz
</pre>
<p>Instead, it must be implemented as:</p>
<pre>[x [y z?]?]?        # allow only x, xy, xyz (and '')
</pre>
<p>Explicit quantifiers are allowed on single characters, so this:</p>
<pre>&lt;* a b+ c | ax*&gt;
</pre>
<p>is rewritten as something like:</p>
<pre>[a [b+ c?]?]? | [a x*]?
</pre>
<p>In the latter example we're assuming the DFA token matcher is going to
give us the longest match regardless.  It's also possible that quantified
multichar sequences can be recursively remapped:</p>
<pre>&lt;* 'ab'+&gt;     # match a, ab, ababa, etc. (but not aab!)
==&gt; [ 'ab'* &lt;*ab&gt; ]
==&gt; [ 'ab'* [a b?]? ]
</pre>
<p>[Conjecture: depending on how fancy we get, we might (or might not)
be able to autodetect ambiguities in <code>&lt;*@abbrev&gt;</code> and refuse to
generate ambiguous abbreviations (although exact match of a shorter
abbrev should always be allowed even if it's the prefix of a longer
abbreviation).  If it is not possible, then the user will have to
check for ambiguities after the match. Note also that the array
form is assuming the array doesn't change often.  If it does, the
longest-token matcher has to be recalculated, which could get
expensive.]	</p></li>
		<li><p>A leading <code>~~</code> indicates a recursive call back into some or all of
the current rule.  An optional argument indicates which subpattern
to re-use, and if provided must resolve to a single subpattern.
If omitted, the entire pattern is called recursively:</p>
<pre>&lt;~~&gt;       # call myself recursively
&lt;~~0&gt;      # match according to $0's pattern
&lt;~~foo&gt;    # match according to $foo's pattern
</pre>
<p>Note that this rematches the pattern associated with the name, not
the string matched.  So</p>
<pre>$_ = &quot;foodbard&quot;

/ ( foo | bar ) d $0 /      # fails; doesn't match &quot;foo&quot; literally
/ ( foo | bar ) d &lt;$0&gt; /    # fails; doesn't match /foo/ as subrule
/ ( foo | bar ) d &lt;~~0&gt; /   # matches using rule associated with $0
</pre>
<p>The last is equivalent to</p>
<pre>/ ( foo | bar ) d ( foo | bar ) /
</pre>
<p>Note that the &quot;self&quot; call of</p>
<pre>/ &lt;term&gt; &lt;operator&gt; &lt;~~&gt; /
</pre>
<p>calls back into this anonymous rule as a subrule, and is implicitly
anchored to the end of the operator as any other subrule would be.
Despite the fact that the outer rule scans the string, the inner
call to it does not.</p>
<p>Note that a consequence of previous section is that you also get</p>
<pre>&lt;!~~&gt;
</pre>
<p>for free, which fails if the current rule would match again at this location.</p></li>
</ul>

<p>The following tokens include angles but are not required to balance:</p>
<ul>
		<li><p>A <code>&lt;(</code> token indicates the start of the match's overall capture, while the
corresponding <code>)&gt;</code> token indicates its endpoint.  When matched,
these behave as assertions that are always true, but have the side
effect of setting the <code>.from</code> and <code>.to</code> attributes of the match
object.  That is:</p>
<pre>/ foo &lt;( \d+ )&gt; bar /
</pre>
<p>is equivalent to:</p>
<pre>/ &lt;?after foo&gt; \d+ &lt;?before bar&gt; /
</pre>
<p>except that the scan for &quot;<code>foo</code>&quot; can be done in the forward direction,
while a lookbehind assertion would presumably scan for <code>\d+</code> and then
match &quot;<code>foo</code>&quot; backwards.  The use of <code>&lt;(...)&gt;</code> affects only the
meaning the positions of the beginning and
ending of the match, and anything calculated based on those positions.
For instance, after the match above, <code>$()</code> contains
only the digits matched, and <code>$/.to</code> is pointing to after the digits.
Other captures (named or numbered) are unaffected and may be accessed
through <code>$/</code>.</p>
<p>These tokens are considered declarative, but may force backtracking behavior.	</p></li>
		<li><p>A <code>«</code> or <code>&lt;&lt;</code> token indicates a left word boundary.  A <code>»</code> or
<code>&gt;&gt;</code> token indicates a right word boundary.  (As separate tokens,
these need not be balanced.)  Perl 5's <code>\b</code> is replaced by a <code>&lt;?wb&gt;</code>
&quot;word boundary&quot; assertion, while <code>\B</code> becomes <code>&lt;!wb&gt;</code>.  (None of
these are dependent on the definition of <code>&lt;.ws&gt;</code>, but only on the <code>\w</code>
definition of &quot;word&quot; characters.)</p></li>
</ul>
</div>
<h2 id="Predefined_Subrules">Predefined Subrules</h2>
<div id="Predefined_Subrules_CONTENT">
<p>These are the predefined subrules for any grammar or regex:</p>
<dl>
	<dt>* ident</dt>
	<dd>
		<p>Match an identifier.</p>
	</dd>
	<dt>* upper</dt>
	<dd>
		<p>Match a single uppercase character.</p>
	</dd>
	<dt>* lower</dt>
	<dd>
		<p>Match a single lowercase character.</p>
	</dd>
	<dt>* alpha</dt>
	<dd>
		<p>Match a single alphabetic character.</p>
	</dd>
	<dt>* digit</dt>
	<dd>
		<p>Match a single digit.</p>
	</dd>
	<dt>* xdigit</dt>
	<dd>
		<p>Match a single hexadecimal digit.</p>
	</dd>
	<dt>* print</dt>
	<dd>
		<p>Match a single printable character.</p>
	</dd>
	<dt>* graph</dt>
	<dd>
		<p>Match a single &quot;graphical&quot; character.</p>
	</dd>
	<dt>* cntrl</dt>
	<dd>
		<p>Match a single &quot;control&quot; character. A control character is usually one that doesn't produce output as such but instead controls the terminal somehow: for example newline and backspace are control characters. All characters with ord() less than 32 are usually classified as control characters (assuming ASCII, the ISO Latin character sets, and Unicode), as is the character with the ord() value of 127 (DEL ).</p>
	</dd>
	<dt>* punct</dt>
	<dd>
		<p>Match a single punctuation character.</p>
	</dd>
	<dt>* alnum</dt>
	<dd>
		<p>Match a single alphanumeric character. This is equivalent to &lt;+alpha +digit&gt; .</p>
	</dd>
	<dt>* wb</dt>
	<dd>
		<p>Returns a zero-width match that is true at word boundaries.  A word
boundary is a spot with a &quot;\w&quot; on one side and a &quot;\W&quot; on the other
side (in either order), counting the beginning and end of the string
as matching &quot;\W&quot;.</p>
	</dd>
	<dt>* ww</dt>
	<dd>
		<p>Matches between two word characters (zero-width match).</p>
	</dd>
	<dt>* ws</dt>
	<dd>
		<p>Matches required whitespace between two word characters, optional
whitespace otherwise.  This is roughly equivalent to  <code>&lt;!ww&gt; \s*</code>
(<code>ws</code> isn't required to use the <code>ww</code> subrule).</p>
	</dd>
	<dt>* space</dt>
	<dd>
		<p>Match a single whitespace character (same as <code> \s </code> ).</p>
	</dd>
	<dt>* blank</dt>
	<dd>
		<p>Match a single &quot;blank&quot; character -- in most locales, this corresponds
to space and tab.</p>
	</dd>
	<dt>* before <code>pattern</code></dt>
	<dd>
		<p>Perform lookahead -- i.e., check if we're at a position where
<code>pattern</code> matches.  Returns a zero-width <code>Match</code> object on
success.</p>
	</dd>
	<dt>* after <code>pattern</code></dt>
	<dd>
		<p>Perform lookbehind -- i.e., check if the string before the
current position matches &lt;pattern&gt; (anchored at the end).
Returns a zero-width <code>Match</code> object on success.</p>
	</dd>
	<dt>* &lt;?&gt;</dt>
	<dd>
		<p>Match a null string, viz., always returns true</p>
	</dd>
	<dt>* &lt;!&gt;</dt>
	<dd>
		<p>Inverse of &lt;?&gt;, viz., always returns false.</p>
	</dd>
</dl>
</div>
<h1 id="Backslash_reform">Backslash reform</h1>
<div id="Backslash_reform_CONTENT">
<ul>
		<li><p>The <code>\p</code> and <code>\P</code> properties become intrinsic grammar rules such as
(<code>&lt;alpha&gt;</code> and <code>&lt;-alpha&gt;</code>).  They may be combined using the
above-mentioned character class notation: <code>&lt;[_]+alpha+digit&gt;</code>.
Regardless of the higher-level character class names, low-level
Unicode properties are always available with a prefix of <code>is</code>.
Hence, <code>&lt;+isLu+isLt&gt;</code> is equivalent to <code>&lt;+upper+title&gt;</code>.
If you define your own &quot;is&quot; properties they hide any Unicode properties
of the same name.	</p></li>
		<li><p>The <code>\L...\E</code>, <code>\U...\E</code>, and <code>\Q...\E</code> sequences are gone.  In the
rare cases that need them you can use <code>&lt;{ lc $regex }&gt;</code> etc.	</p></li>
		<li><p>The <code>\G</code> sequence is gone.  Use <code>:p</code> instead.  (Note, however,
that it makes no sense to use <code>:p</code> within a pattern, since every
internal pattern is implicitly anchored to the current position.)
See the <code>at</code> assertion below.	</p></li>
		<li><p>Backreferences (e.g. <code>\1</code>, <code>\2</code>, etc.) are gone; <code>$0</code>, <code>$1</code>, etc. can be
used instead, because variables are no longer interpolated.</p>
<p>Numeric variables are assumed to change every time and therefore are
considered procedural, unlike normal variables.	</p></li>
		<li><p>New backslash sequences, <code>\h</code> and <code>\v</code>, match horizontal and vertical
whitespace respectively, including Unicode.	</p></li>
		<li><p><code>\s</code> now matches any Unicode whitespace character.	</p></li>
		<li><p>The new backslash sequence <code>\N</code> matches anything except a logical
newline; it is the negation of <code>\n</code>.	</p></li>
		<li><p>A series of other new capital backslash sequences are also the negation
of their lower-case counterparts:		<li><p>
			<ul>
					<li><p><code>\H</code> matches anything but horizontal whitespace.				</p></li>
					<li><p><code>\V</code> matches anything but vertical whitespace.				</p></li>
					<li><p><code>\T</code> matches anything but a tab.				</p></li>
					<li><p><code>\R</code> matches anything but a return.				</p></li>
					<li><p><code>\F</code> matches anything but a formfeed.				</p></li>
					<li><p><code>\E</code> matches anything but an escape.				</p></li>
					<li><p><code>\X...</code> matches anything but the specified character (specified in
hexadecimal).</p></li>
</ul>

		</p></li>
</p></li>
</ul>
</div>
<h1 id="Regexes_are_now_first_class_language">Regexes are now first-class language, not strings</h1>
<div id="Regexes_are_now_first_class_language-2">
<ul>
		<li><p>The Perl 5 <code>qr/pattern/</code> regex constructor is gone.	</p></li>
		<li><p>The Perl 6 equivalents are:</p>
<pre> regex { pattern }    # always takes {...} as delimiters
 rx    / pattern /    # can take (almost) any chars as delimiters
</pre>
<p>You may not use whitespace or alphanumerics for delimiters.  Space is
optional unless needed to distinguish from modifier arguments or
function parens.  So you may use parens as your <code>rx</code> delimiters,
but only if you interpose whitespace:</p>
<pre> rx ( pattern )      # okay
 rx( 1,2,3 )         # tries to call rx function
</pre>
<p>(This is true for all quotelike constructs in Perl 6.)	</p></li>
		<li><p>If either form needs modifiers, they go before the opening delimiter:</p>
<pre> $regex = regex :g:s:i { my name is (.*) };
 $regex = rx:g:s:i     / my name is (.*) /;    # same thing
</pre>
<p>Space is necessary after the final modifier if you use any
bracketing character for the delimiter.  (Otherwise it would be taken as
an argument to the modifier.)	</p></li>
		<li><p>You may not use colons for the delimiter.  Space is allowed between
modifiers:</p>
<pre> $regex = rx :g :s :i / my name is (.*) /;
</pre>	</p></li>
		<li><p>The name of the constructor was changed from <code>qr</code> because it's no
longer an interpolating quote-like operator.  <code>rx</code> is short for <i>regex</i>,
(not to be confused with regular expressions, except when they are).	</p></li>
		<li><p>As the syntax indicates, it is now more closely analogous to a <code>sub {...}</code>
constructor.  In fact, that analogy runs <i>very</i> deep in Perl 6.	</p></li>
		<li><p>Just as a raw <code>{...}</code> is now always a closure (which may still
execute immediately in certain contexts and be passed as an object
in others), so too a raw <code>/.../</code> is now always a <code>Regex</code> object (which
may still match immediately in certain contexts and be passed as an
object in others).	</p></li>
		<li><p>Specifically, a <code>/.../</code> matches immediately in a value context (void,
Boolean, string, or numeric), or when it is an explicit argument of
a <code>~~</code>.  Otherwise it's a <code>Regex</code> constructor identical to the explicit
<code>regex</code> form.  So this:</p>
<pre> $var = /pattern/;
</pre>
<p>no longer does the match and sets <code>$var</code> to the result.
Instead it assigns a <code>Regex</code> object to <code>$var</code>.	</p></li>
		<li><p>The two cases can always be distinguished using <code>m{...}</code> or <code>rx{...}</code>:</p>
<pre> $match = m{pattern};    # Match regex immediately, assign result
 $regex = rx{pattern};   # Assign regex expression itself
</pre>	</p></li>
		<li><p>Note that this means that former magically lazy usages like:</p>
<pre> @list = split /pattern/, $str;
</pre>
<p>are now just consequences of the normal semantics.	</p></li>
		<li><p>It's now also possible to set up a user-defined subroutine that acts
like <code>grep</code>:</p>
<pre> sub my_grep($selector, *@list) {
     given $selector {
         when Regex { ... }
         when Code  { ... }
         when Hash  { ... }
         # etc.
     }
 }
</pre>
<p>When you call <code>my_grep</code>, the first argument is bound in item context,
so passing <code>{...}</code> or <code>/.../</code> produces a <code>Code</code> or <code>Regex</code> object,
which the switch statement then selects upon.  (Normal <code>grep</code> just
lets a smartmatch operator do all the work.)	</p></li>
		<li><p>Just as <code>rx</code> has variants, so does the <code>regex</code> declarator.
In particular, there are two special variants for use in grammars:
<code>token</code> and <code>rule</code>.</p>
<p>A token declaration:</p>
<pre>token ident { [ &lt;alpha&gt; | _ ] \w* }
</pre>
<p>never backtracks by default.  That is, it likes to commit to whatever
it has scanned so far.  The above is equivalent to</p>
<pre>regex ident { [ &lt;alpha&gt;: | _: ]: \w*: }
</pre>
<p>but rather easier to read.  The bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers
never backtrack in a <code>token</code> unless some outer regex has specified a
<code>:panic</code> option that applies.  If you want to prevent even that, use
<code>*:</code>, <code>+:</code>, or <code>?:</code> to prevent any backtracking into the quantifier.
If you want to explicitly backtrack, append either a <code>?</code> or a <code>!</code>
to the quantifier.   The <code>?</code> forces minimal matching as usual,
while the <code>!</code> forces greedy matching.  The <code>token</code> declarator is
really just short for</p>
<pre>regex :ratchet { ... }
</pre>
<p>The other is the <code>rule</code> declarator, for declaring non-terminal
productions in a grammar.  Like a <code>token</code>, it also does not backtrack
by default.  In addition, a <code>rule</code> regex also assumes <code>:sigspace</code>.
A <code>rule</code> is really short for:</p>
<pre>regex :ratchet :sigspace { ... }
</pre>	</p></li>
		<li><p>The Perl 5 <code>?...?</code> syntax (<i>succeed once</i>) was rarely used and can be
now emulated more cleanly with a state variable:</p>
<pre>$result = do { state $x ||= m/ pattern /; }    # only matches first time
</pre>
<p>To reset the pattern, simply say <code>$x = 0</code>.  Though if you want <code>$x</code> visible
you'd have to avoid using a block:</p>
<pre>$result = state $x ||= m/ pattern /;
...
$x = 0;
</pre></p></li>
</ul>
</div>
<h1 id="Backtracking_control">Backtracking control</h1>
<div id="Backtracking_control_CONTENT">
<p>Within those portions of a pattern that are considered procedural rather
than declarative, you may control the backtracking behavior.</p>
<ul>
		<li><p>By default, backtracking is greedy in <code>rx</code>, <code>m</code>, <code>s</code>, and the like.
It's also greedy in ordinary <code>regex</code> declarations.  In <code>rule</code>
and <code>token</code> declarations, backtracking must be explicit.	</p></li>
		<li><p>To force the preceding atom to do eager backtracking,
append a <code>:?</code> or <code>?</code> to the atom.  If the preceding token is
a quantifier, the <code>:</code> may be omitted, so <code>*?</code> works just as
in Perl 5.	</p></li>
		<li><p>To force the preceding atom to do greedy backtracking in a
spot that would default otherwise, append a <code>:!</code> to the atom.
If the preceding token is a quantifier, the <code>:</code> may be omitted.
(Perl 5 has no corresponding construct because backtracking always
defaults to greedy in Perl 5.)	</p></li>
		<li><p>To force the preceding atom to do no backtracking, use a single <code>:</code>
without a subsequent <code>?</code> or <code>!</code>.
Backtracking over a single colon causes the regex engine not to retry
the preceding atom:</p>
<pre> mm/ \( &lt;expr&gt; [ , &lt;expr&gt; ]*: \) /
</pre>
<p>(i.e. there's no point trying fewer <code>&lt;expr&gt;</code> matches, if there's
no closing parenthesis on the horizon)</p>
<p>To force all the atoms in an expression not to backtrack by default,
use <code>:ratchet</code> or <code>rule</code> or <code>token</code>.	</p></li>
		<li><p>Backtracking over a double colon causes the immediately surrounding
group (usually but not always a group of alternations) to immediately
fail:</p>
<pre> mm/ [ if :: &lt;expr&gt; &lt;block&gt;
     | for :: &lt;list&gt; &lt;block&gt;
     | loop :: &lt;loop_controls&gt;? &lt;block&gt;
     ]
 /
</pre>
<p>(i.e. there's no point trying to match a different keyword if one was
already found but failed).  Note that you can still back into such
an alternation, so you may also need to put <code>:</code> after it if you
also want to disable that.  If an explicit or implicit <code>:ratchet</code>
has disabled backtracking by supplying an implicit <code>:</code>, you need to
put an explicit <code>!</code> after the alternation to enable backing into
another alternative if the first pick fails.</p>
<p>The <code>::</code> also has the effect of hiding any constant string on the right
from &quot;longest token&quot; processing by <code>|</code>.  Only the left side is evaluated
for initial constancy.	</p></li>
		<li><p>Backtracking over a triple colon causes the current regex to fail
outright (no matter where in the regex it occurs):</p>
<pre> regex ident {
       ( [&lt;alpha&gt;|_] \w* ) ::: { fail if %reserved{$0} }
     || &quot; [&lt;alpha&gt;|_] \w* &quot;
 }

 mm/ get &lt;ident&gt;? /
</pre>
<p>(i.e. using an unquoted reserved word as an identifier is not permitted)	</p></li>
		<li><p>Backtracking over a <code>&lt;commit&gt;</code> assertion causes the entire match
to fail outright, no matter how many subrules down it happens:</p>
<pre> regex subname {
     ([&lt;alpha&gt;|_] \w*) &lt;commit&gt; { fail if %reserved{$0} }
 }
 mm/ sub &lt;subname&gt;? &lt;block&gt; /
</pre>
<p>(i.e. using a reserved word as a subroutine name is instantly fatal
to the <i>surrounding</i> match as well)</p>
<p>If commit is given an argument, it's the name of a calling rule that
should be committed:</p>
<pre>&lt;commit('infix')&gt;
</pre>	</p></li>
		<li><p>A <code>&lt;cut&gt;</code> assertion always matches successfully, and has the
side effect of logically deleting the parts of the string already
matched.  Whether this actually frees up the memory immediately may
depend on various interactions among your backreferences, the string
implementation, and the garbage collector.  In any case, the string
will report that it has been chopped off on the front.  It's illegal
to use <code>&lt;cut&gt;</code> on a string that you do not have write access to.</p>
<p>Attempting to backtrack past a <code>&lt;cut&gt;</code> causes the complete
match to fail (like backtracking past a <code>&lt;commit&gt;</code>). This is
because there's now no preceding text to backtrack into.  This is
useful for throwing away successfully processed input when matching
from an input stream or an iterator of arbitrary length.</p></li>
</ul>
</div>
<h1 id="Regex_Routines_Named_and_Anonymous">Regex Routines, Named and Anonymous</h1>
<div id="Regex_Routines_Named_and_Anonymous_C">
<ul>
		<li><p>The analogy between <code>sub</code> and <code>regex</code> extends much further.	</p></li>
		<li><p>Just as you can have anonymous subs and named subs...	</p></li>
		<li><p>...so too you can have anonymous regexes and <i>named</i> regexes (and tokens,
and rules):</p>
<pre> token ident { [&lt;alpha&gt;|_] \w* }

 # and later...

 @ids = grep /&lt;ident&gt;/, @strings;
</pre>	</p></li>
		<li><p>As the above example indicates, it's possible to refer to named regexes,
such as:</p>
<pre> regex serial_number { &lt;[A..Z]&gt; \d**8 }
 token type { alpha | beta | production | deprecated | legacy }
</pre>
<p>in other regexes as named assertions:</p>
<pre> rule identification { [soft|hard]ware &lt;type&gt; &lt;serial_number&gt; }
</pre>
<p>These keyword-declared regexes are officially of type <code>Method</code>,
which is derived from <code>Routine</code>.</p>
<p>In general, the anchoring of any subrule call is controlled by context.
When a regex, token, or rule method is called as a subrule, the
front is anchored to the current position (as with <code>:p</code>), while
the end is not anchored, since the calling context will likely wish
to continue parsing.  However, when such a method is smartmatched
directly, it is automatically anchored on both ends to the beginning
and end of the string.  Thus, you can do direct pattern matching
by using an anonymous regex routine as a standalone pattern:</p>
<pre>$string ~~ regex { \d+ }
$string ~~ token { \d+ }
$string ~~ rule { \d+ }
</pre>
<p>and these are equivalent to</p>
<pre>$string ~~ m/^ \d+ $/;
$string ~~ m/^ \d+: $/;
$string ~~ m/^ &lt;.ws&gt; \d+: &lt;.ws&gt; $/;
</pre>
<p>The basic rule of thumb is that the keyword-defined methods never
do implicit <code>.*?</code>-like scanning, while the <code>m//</code> and <code>s//</code>
quotelike forms do such scanning in the absence of explicit anchoring.</p>
<p>The <code>rx//</code> and <code>//</code> forms can go either way: they scan when used
directly within a smartmatch or boolean context, but when called
indirectly as a subrule they do not scan.  That is, the object returned
by <code>rx//</code> behaves like <code>m//</code> when used directly, but like <code>regex</code>
<code>{}</code> when used as a subrule:</p>
<pre>$pattern = rx/foo/;
$string ~~ $pattern;                  # equivalent to m/foo/;
$string ~~ /'[' &lt;$pattern&gt; ']'/       # equivalent to /'[foo]'/
</pre></p></li>
</ul>
</div>
<h1 id="Nothing_is_illegal">Nothing is illegal</h1>
<div id="Nothing_is_illegal_CONTENT">
<ul>
		<li><p>The empty pattern is now illegal.	</p></li>
		<li><p>To match whatever the prior successful regex matched, use:</p>
<pre> / &lt;prior&gt; /
</pre>	</p></li>
		<li><p>To match the zero-width string, you must use some explicit
representation of the null match:</p>
<pre>/ '' /;
/ &lt;?&gt; /;
</pre>
<p>For example:</p>
<pre> split /''/, $string
</pre>
<p>splits between characters.  But then, so does this:</p>
<pre> split '', $string
</pre>	</p></li>
		<li><p>Likewise, to match a empty alternative, use something like:</p>
<pre> /a|b|c|&lt;?&gt;/
 /a|b|c|''/
</pre>
<p>This makes it easier to catch errors like this:</p>
<pre>/a|b|c|/
</pre>
<p>As a special case, however, the first null alternative in a match like</p>
<pre> mm/ [
     | if :: &lt;expr&gt; &lt;block&gt;
     | for :: &lt;list&gt; &lt;block&gt;
     | loop :: &lt;loop_controls&gt;? &lt;block&gt;
     ]
 /
</pre>
<p>is simply ignored.  Only the first alternative is special that way.
If you write:</p>
<pre> mm/ [
         if :: &lt;expr&gt; &lt;block&gt;              |
         for :: &lt;list&gt; &lt;block&gt;             |
         loop :: &lt;loop_controls&gt;? &lt;block&gt;  |
     ]
 /
</pre>

<p>it's still an error.	</p></li>
		<li><p>However, it's okay for a non-null syntactic construct to have a degenerate
case matching the null string:</p>
<pre> $something = &quot;&quot;;
 /a|b|c|$something/;
</pre>
<p>In particular, <code>&lt;?&gt;</code> always matches the null string successfully,
and <code>&lt;!&gt;</code> always fails to match anything.</p></li>
</ul>
</div>
<h1 id="Longest_token_matching">Longest-token matching</h1>
<div id="Longest_token_matching_CONTENT">
<p>Instead of representing temporal alternation, <code>|</code> now represents
logical alternation with declarative longest-token semantics.  (You may
now use <code>||</code> to indicate the old temporal alternation.  That is, <code>|</code>
and <code>||</code> now work within regex syntax much the same as they do outside
of regex syntax, where they represent junctional and short-circuit OR.
This includes the fact that <code>|</code> has tighter precedence than <code>||</code>.)</p>
<p>Historically regex processing has proceeded in Perl via a backtracking
NFA algorithm.  This is quite powerful, but many parsers work more
efficiently by processing rules in parallel rather than one after
another, at least up to a point.  If you look at something like a
yacc grammar, you find a lot of pattern/action declarations where the
patterns are considered in parallel, and eventually the grammar decides
which action to fire off.  While the default Perl view of parsing is
essentially top-down (perhaps with a bottom-up &quot;middle layer&quot; to handle
operator precedence), it is extremely useful for user understanding
if at least the token processing proceeds deterministically.  So for
regex matching purposes we define token patterns as those patterns
that can be matched without potential side effects or self-reference.
(Since whitespace often has side effects at line transitions, it
is usually excluded from such patterns, give or take a little
lookahead.)  Basically, Perl automatically derives a lexer
from the grammar without you having to write one yourself.</p>
<p>To that end, every regex in Perl 6 is required to be able to
distinguish its &quot;pure&quot; patterns from its actions, and return its
list of initial token patterns (transitively including the token
patterns of any subrule called by the &quot;pure&quot; part of that regex, but
not including any subrule more than once, since that would involve
self reference, which is not allowed in traditional regular
expressions).  A logical alternation using <code>|</code> then takes two or
more of these lists and dispatches to the alternative that matches
the longest token prefix.  This may or may not be the alternative
that comes first lexically.</p>
<p>However, if two alternatives match at the same length, the tie is
broken first by specificity.  The alternative that starts with the
longest fixed string wins; that is, an exact match counts as closer
than a match made using character classes.  If that doesn't work, the tie
broken by one of two methods.  If the alternatives are in different
grammars, standard MRO (method resolution order) determines which
one to try first.  If the alternatives are in the same grammar file, the
textually earlier alternative takes precedence.  (If a grammar's rules
are defined in more than one file, the order is undefined, and an explicit
assertion must be used to force failure if the wrong one is tried first.)</p>
<p>This longest token prefix corresponds roughly to the notion of &quot;token&quot;
in other parsing systems that use a lexer, but in the case of Perl
this is largely an epiphenomenon derived automatically from the grammar
definition.  However, despite being automatically calculated, the set of
tokens can be modified by the user; various
constructs within a regex declaratively tell the grammar engine that
it is finished with the pattern part and starting in on the side effects,
so by inserting such constructs the user controls what is considered
a token and what is not.  The constructs deemed to terminate a token
declaration and start the &quot;action&quot; part of the pattern include:</p>
<ul>
		<li><p>Any :: or ::: backtracking control (but not the : possessive modifier).	</p></li>
		<li><p>Any atom that is quantified with a minimal match (using the <code>?</code> modifier).	</p></li>
		<li><p>Any <code>{...}</code> action, but not an assertion containing a closure.
The closure form of the general <code>**{...}</code> quantifier terminates the
longest token, but not the closureless forms.	</p></li>
		<li><p>Any sequential control flow operator such as <code>||</code> or <code>&amp;&amp;</code>.	</p></li>
		<li><p>As a consequence of the previous point, and because the standard
grammar's <code>&lt;ws&gt;</code> rule defines whitespace using <code>||</code>, the
longest token is also terminated by any part of the regex or rule
that <i>might</i> match whitespace using that rule, including whitespace
implicitly matched via <code>:sigspace</code>.  (However, token declarations are
specifically allowed to recognize whitespace within a token by using
such lower-level primitives as <code>\h+</code> or other character classes.)</p></li>
</ul>

<p>Subpatterns (captures) specifically do not terminate the token pattern,
but may require a reparse of the token to find the location
of the subpatterns.  Likewise assertions may need to be checked out
after the longest token is determined.  (Alternately, if DFA semantics
are simulated in any of various ways, such as by Thompson NFA, it may
be possible to know when to fire off the assertions without backchecks.)</p>
<p>Greedy quantifiers and character classes do not terminate a token pattern.
Zero-width assertions such as word boundaries are also okay.</p>
<p>Because such assertions can be part of the token, the lexer engine must
be able to recover from the failure of such an assertion and backtrack
to the next best token candidate, which might be the same length or shorter,
but can never be longer than the current candidate.</p>
<p>For a pattern that starts with a positive lookahead assertion,
the assertion is assumed to be more specific than the subsequent
pattern, so the lookahead's pattern is treated as the longest token;
the longest-token matcher will be smart enough to rematch any text
traversed by the lookahead when (and if) it continues the match.</p>
<p>Oddly enough, the <code>token</code> keyword specifically does not determine
the scope of a token, except insofar as a token pattern usually
doesn't do much matching of whitespace.  In contrast, the <code>rule</code>
keyword (which assumes <code>:sigspace</code>) defines a pattern that tends
to disqualify itself on the first whitespace.  So most of the token
patterns will end up coming from <code>token</code> declarations.  For instance,
a token declaration such as</p>
<pre>token list_composer { \[ &lt;expr&gt; \] }
</pre>
<p>considers its &quot;longest token&quot; to be just the left square bracket, because
the first thing the <code>expr</code> rule will do is traverse optional whitespace.</p>
<p>The initial token matcher must take into account case sensitivity
(or any other canonicalization primitives) and do the right thing even
when propagated up to rules that don't have the same canonicalization.
That is, they must continue to represent the set of matches that the
lower rule would match.</p>
<p>The <code>||</code> form has the old short-circuit semantics, and will not
attempt to match its right side unless all possibilities (including
all <code>|</code> possibilities) are exhausted on its left.  The first <code>||</code>
in a regex makes the token patterns on its left available to the
outer longest-token matcher, but hides any subsequent tests from
longest-token matching.  Every <code>||</code> establishes a new longest-token
matcher.  That is, if you use <code>|</code> on the right side of <code>||</code>, that
right side establishes a new top level scope for longest-token processing
for this subexpression and any called subrules.  The right side's
longest-token automaton is invisible to the left of the <code>||</code> or outside
the regex containing the <code>||</code>.</p>
</div>
<h1 id="Return_values_from_matches">Return values from matches</h1>
<div id="Return_values_from_matches_CONTENT">
</div>
<h2 id="Match_objects">Match objects</h2>
<div id="Match_objects_CONTENT">
<ul>
		<li><p>A match always returns a <code>Match</code> object, which is also available
as <code>$/</code>, which is a contextual lexical declared in the outer
subroutine that is calling the regex.  (A regex declares its own
lexical <code>$/</code> variable, which always refers to the most recent
submatch within the rule, if any.)  The current match state is
kept in the regex's <code>$¢</code> variable which will eventually get
processed into the user's <code>$/</code> variable when the match completes.	</p></li>
		<li><p>Notionally, a match object contains (among other things) a boolean
success value, an array of ordered submatch objects, and a hash of named
submatch objects.  (It also optionally carries an <i>abstract object</i> normally
used to build up an abstract syntax tree,)  To provide convenient
access to these various values, the match object evaluates differently
in different contexts:		<li><p>
			<ul>
					<li><p>In boolean context it evaluates as true or false (i.e. did the match
succeed?):</p>
<pre> if /pattern/ {...}
 # or:
 /pattern/; if $/ {...}
</pre>
<p>With <code>:global</code> or <code>:overlap</code> or <code>:exhaustive</code> the boolean is
allowed to return true on the first match.  The <code>Match</code> object can
produce the rest of the results lazily if evaluated in list context.				</p></li>
					<li><p>In string context it evaluates to the stringified value of its match,
which is usually the entire matched string:</p>
<pre> print %hash{ &quot;{$text ~~ /&lt;.ident&gt;/}&quot; };
 # or equivalently:
 $text ~~ /&lt;.ident&gt;/  &amp;&amp;  print %hash{~$/};
</pre>
<p>But generally you should say <code>~$/</code> if you mean <code>~$/</code>.				</p></li>
					<li><p>In numeric context it evaluates to the numeric value of its match,
which is usually the entire matched string:</p>
<pre> $sum += /\d+/;
 # or equivalently:
 /\d+/; $sum = $sum + $/;
</pre>				</p></li>
					<li><p>When used as a scalar, a <code>Match</code> object evaluates to itself.</p>
<p>However, sometimes you would like an alternate scalar value to
ride along with the match.  The <code>Match</code> object itself describes
a concrete parse tree, so this extra value is called an <i>abstract</i>
object; it rides along as an attribute of the <code>Match</code> object.  <code>$()</code>
is a shorthand for <code>$($/.ast)</code>.  The <code>.ast</code> method by default just
returns the string between the <code>$/.from</code> and <code>$/.to</code> positions.</p>
<p>Therefore <code>$()</code> is usually just the entire match string, but
you can override that by calling <code>make</code> inside a regex:</p>
<pre>my $moose = $(m:{
    &lt;antler&gt; &lt;body&gt;
    { make Moose.new( body =&gt; $&lt;body&gt;.attach($&lt;antler&gt;) ) }
    # match succeeds -- ignore the rest of the regex
});
</pre>
<p>This puts the new abstract node into <code>$/.ast</code>.  If the abstract object is
returned that way, it may be of any type, not just a string.
This makes it convenient to build up an abstract syntax tree of
arbitrary node types.</p>
<p>You may also capture a subset of the match as the abstract object using
the <code>&lt;(...)&gt;</code> construct:</p>
<pre>&quot;foo123bar&quot; ~~ / foo &lt;( \d+ )&gt; bar /
say $();    # says 123
</pre>
<p>In this case the abstract object is always a string when doing string
matching, and a list of one or more elements when doing list matching.				</p></li>
					<li><p>When used as an array, a <code>Match</code> object pretends to be an array of all
its positional captures.  Hence</p>
<pre> ($key, $val) = mm/ (\S+) =&gt; (\S+)/;
</pre>
<p>can also be written:</p>
<pre> $result = mm/ (\S+) '=&gt;' (\S+)/;
 ($key, $val) = @$result;
</pre>
<p>To get a single capture into a string, use a subscript:</p>
<pre> $mystring = &quot;{ mm/ (\S+) '=&gt;' (\S+)/[0] }&quot;;
</pre>
<p>To get all the captures into a string, use a <i>zen</i> slice:</p>
<pre> $mystring = &quot;{ mm/ (\S+) '=&gt;' (\S+)/[] }&quot;;
</pre>
<p>Or cast it into an array:</p>
<pre> $mystring = &quot;@( mm/ (\S+) '=&gt;' (\S+)/ )&quot;;
</pre>
<p>Note that, as a scalar variable, <code>$/</code> doesn't automatically flatten
in list context.  Use <code>@()</code> as a shorthand for <code>@($/)</code> to flatten
the positional captures under list context.  Note that a <code>Match</code> object
is allowed to evaluate its match lazily in list context.  Use <code>eager @()</code>
to force an eager match.				</p></li>
					<li><p>When used as a hash, a <code>Match</code> object pretends to be a hash of all its named
captures.  The keys do not include any sigils, so if you capture to
variable <code>@&lt;foo&gt;</code> its real name is <code>$/{'foo'}</code> or <code>$/&lt;foo&gt;</code>.
However, you may still refer to it as <code>@&lt;foo&gt;</code> anywhere <code>$/</code>
is visible.  (But it is erroneous to use the same name for two different
capture datatypes.)</p>
<p>Note that, as a scalar variable, <code>$/</code> doesn't automatically flatten
in list context.  Use <code>%()</code> as a shorthand for <code>%($/)</code> to flatten as a
hash, or bind it to a variable of the appropriate type.  As with <code>@()</code>,
it's possible for <code>%()</code> to produce its pairs lazily in list context.				</p></li>
					<li><p>The numbered captures may be treated as named, so <code>$&lt;0 1 2&gt;</code>
is equivalent to <code>$/[0,1,2]</code>.  This allows you to write slices of
intermixed named and numbered captures.				</p></li>
					<li><p>In ordinary code, variables <code>$0</code>, <code>$1</code>, etc. are just aliases into
<code>$/[0]</code>, <code>$/[1]</code>, etc.  Hence they will all be undefined if the
last match failed (unless they were explicitly bound in a closure without
using the <code>let</code> keyword).</p></li>
</ul>

		</p></li>
	</p></li>
		<li><p><code>Match</code> objects have methods that provide additional information about
the match. For example:</p>
<pre> if m/ def &lt;ident&gt; &lt;codeblock&gt; / {
     say &quot;Found sub def from index $/.from.bytes &quot;,
         &quot;to index $/.to.bytes&quot;;
 }
</pre>
<p>The currently defined methods are</p>
<pre>$/.from     # the initial match position
$/.to       # the final match position
$/.chars    # $/.to - $/.from
$/.orig     # the original match string
$/.Str      # substr($/.orig, $/.from, $/.chars)
$/.ast      # the abstract result associated with this node
$/.caps     # sequential captures
$/.chunks   # sequential tokenization
</pre>
<p>Within the regex the current match state <code>$¢</code> also provides</p>
<pre>.pos        # the current match position
</pre>
<p>This last value may correspond to either <code>$¢.from</code> or <code>$¢.to</code> depending
on whether the match is proceeding in a forward or backward direction
(the latter case arising inside an <code>&lt;?after ...&gt;</code> assertion).	</p></li>
		<li><p>As described above, a <code>Match</code> in list context returns its positional
captures.  However, sometimes you'd rather get a flat list of tokens
in the order they occur in the text.  The <code>.caps</code> method returns
a list of every capture in order, regardless of how it was otherwise
bound into named or numbered captures.  (Other than order, there is
no new information here; all the elements of the list are the very
same <code>Match</code> objects that bound elsewhere.)  The bindings are actually
returned as key/value pairs where the key is the name or number under which
the match object was bound, and the value is the match object itself.</p>
<p>In addition to returning those captured <code>Match</code> objects, the
<code>.chunks</code> method also returns all the interleaved &quot;noise&quot; between
the captures.  As with <code>.caps</code>, the list elements are in the order
they were originally in the text.  The interleaved bits are also
returned as pairs, where the key is '~' and the value
is a simple <code>Match</code> object containing only the string, even if unbound
subrules such as <code>.ws</code> were called to traverse the text in the first
place.  Calling <code>.ast</code> on such a <code>Match</code> object always returns a <code>Str</code>.</p>
<p>A warning will be issued if either <code>.caps</code> or <code>.chunks</code> discovers
that it has overlapping bindings.  In the absence of such overlap,
<code>.chunks</code> guarantees to map every part of its matched string (between
<code>.from</code> and <code>.to</code>) to exactly one element of its returned matches,
so coverage is complete.</p>
<p>[Conjecture: we could also have <code>.deepcaps</code> and <code>.deepchunks</code> that
recursively expand any capture containing submatches.  Presumably the
keys of such returned chunks would indicate the &quot;pedigree&quot; of bindings
in the parse tree.]	</p></li>
		<li><p>All match attempts--successful or not--against any regex, subrule, or
subpattern (see below) return an object of class <code>Match</code>. That is:</p>
<pre> $match_obj = $str ~~ /pattern/;
 say &quot;Matched&quot; if $match_obj;
</pre>	</p></li>
		<li><p>This returned object is also automatically bound to the lexical
<code>$/</code> variable of the current surroundings regardless of success. That is:</p>
<pre> $str ~~ /pattern/;
 say &quot;Matched&quot; if $/;
</pre>	</p></li>
		<li><p>Inside a regex, the <code>$¢</code> variable holds the current regex's incomplete
<code>Match</code> object, known as a match state (of type <code>Cursor</code>).  Generally this should not
be modified unless you know how to create and propagate match states.
All regexes actually return match states even when you think they're
returning something else, because the match states keep track of
the success and failures of the pattern for you.</p>
<p>Fortunately, when you just want to return a different abstract result along with
the default concrete <code>Match</code> object, you may associate your return value with
the current match state using the <code>make</code> function, which works something
like a <code>return</code>, but doesn't clobber the match state:</p>
<pre>$str ~~ / foo                 # Match 'foo'
           { make 'bar' }     # But pretend we matched 'bar'
         /;
say $();                      # says 'bar'
</pre>
<p>The abstract object of any <code>Match</code> object is available via the <code>.ast</code> method.</p></li>
</ul>
</div>
<h2 id="Subpattern_captures">Subpattern captures</h2>
<div id="Subpattern_captures_CONTENT">
<ul>
		<li><p>Any part of a regex that is enclosed in capturing parentheses is called a
<i>subpattern</i>. For example:</p>
<pre>    #               subpattern
    #  _________________/\___________________
    # |                                      |
    # |       subpattern  subpattern         |
    # |          __/\__    __/\__            |
    # |         |      |  |      |           |
  mm/ (I am the (walrus), ( khoo )**2  kachoo) /;
</pre>
<p>


	</p></li>
		<li><p>Each subpattern in a regex produces a <code>Match</code> object if it is
successfully matched.	</p></li>
		<li><p>Each subpattern's <code>Match</code> object is pushed onto the array inside
the outer <code>Match</code> object belonging to the surrounding scope (known as
its <i>parent <code>Match</code> object</i>). The surrounding scope may be either the
innermost surrounding subpattern (if the subpattern is nested) or else
the entire regex itself.	</p></li>
		<li><p>Like all captures, these assignments to the array are hypothetical, and
are undone if the subpattern is backtracked.	</p></li>
		<li><p>For example, if the following pattern matched successfully:</p>
<pre>    #                subpat-A
    #  _________________/\__________________
    # |                                     |
    # |         subpat-B  subpat-C          |
    # |          __/\__    __/\__           |
    # |         |      |  |      |          |
  mm/ (I am the (walrus), ( khoo )**2 kachoo) /;
</pre>
<p>then the <code>Match</code> objects representing the matches made by <i>subpat-B</i>
and <i>subpat-C</i> would be successively pushed onto the array inside <i>subpat-
A</i>'s <code>Match</code> object. Then <i>subpat-A</i>'s <code>Match</code> object would itself be
pushed onto the array inside the <code>Match</code> object for the entire regex
(i.e. onto <code>$/</code>'s array).	</p></li>
		<li><p>As a result of these semantics, capturing parentheses in Perl 6 are
hierarchical, not linear (see <a href="#Nested_subpattern_captures">Nested subpattern captures</a>).</p></li>
</ul>
</div>
<h2 id="Accessing_captured_subpatterns">Accessing captured subpatterns</h2>
<div id="Accessing_captured_subpatterns_CONTE">
<ul>
		<li><p>The array elements of a <code>Match</code> object are referred to using either the
standard array access notation (e.g. <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>, etc.)
or else via the corresponding lexically scoped numeric aliases (i.e.
<code>$0</code>, <code>$1</code>, <code>$2</code>, etc.) So:</p>
<pre> say &quot;$/[1] was found between $/[0] and $/[2]&quot;;
</pre>
<p>is the same as:</p>
<pre> say &quot;$1 was found between $0 and $2&quot;;
</pre>	</p></li>
		<li><p>Note that, in Perl 6, the numeric capture variables start from $0, not
$1, with the numbers corresponding to the element's index inside <code>$/</code>.	</p></li>
		<li><p>The array elements of the regex's <code>Match</code> object (i.e. <code>$/</code>)
store individual <code>Match</code> objects representing the substrings that were
matched and captured by the first, second, third, etc. <i>outermost</i>
(i.e. unnested) subpatterns. So these elements can be treated like fully
fledged match results. For example:</p>
<pre> if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ {
       ($yr, $mon, $day) = $/[0..2];
       $era = &quot;$3&quot; if $3;                    # stringify/boolify
       @datepos = ( $0.from() .. $2.to() );  # Call Match methods
 }
</pre>
<p>


</p></li>
</ul>
</div>
<h2 id="Nested_subpattern_captures">Nested subpattern captures</h2>
<div id="Nested_subpattern_captures_CONTENT">
<ul>
		<li><p>Substrings matched by <i>nested</i> subpatterns (i.e. nested capturing
parens) are assigned to the array inside the nested subpattern's parent <code>Match</code>
object, not to the array of <code>$/</code>.	</p></li>
		<li><p>This behavior is quite different from Perl 5 semantics:</p>
<pre>  # Perl 5...
  #
  # $1---------------------  $4---------  $5------------------
  # |   $2---------------  | |          | | $6----  $7------  |
  # |   |         $3--   | | |          | | |     | |       | |
  # |   |         |   |  | | |          | | |     | |       | |
 m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;
</pre>	</p></li>
		<li><p>In Perl 6, nested parens produce properly nested captures:</p>
<pre>  # Perl 6...
  #
  # $0---------------------  $1---------  $2------------------
  # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |
  # |   |       $0[0][0] | | |          | | |     | |       | |
  # |   |         |   |  | | |          | | |     | |       | |
 m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;
</pre>
<p>


</p></li>
</ul>
</div>
<h2 id="Quantified_subpattern_captures">Quantified subpattern captures</h2>
<div id="Quantified_subpattern_captures_CONTE">
<ul>
		<li><p>If a subpattern is directly quantified (using <i>any</i> quantifier), it no
longer produces a single <code>Match</code> object. Instead, it produces a list
of <code>Match</code> objects corresponding to the sequence of individual matches
made by the repeated subpattern (or a <code>Nil</code> if it matched zero times).	</p></li>
		<li><p>Because a quantified subpattern returns a list of <code>Match</code> objects, the
corresponding array element for the quantified capture will store a
(nested) array rather than a single <code>Match</code> object.  For example:</p>
<pre> if m/ (\w+) \: (\w+ \s+)* / {
     say &quot;Key:    $0&quot;;         # Unquantified --&gt; single Match
     say &quot;Values: @($1)&quot;;      # Quantified   --&gt; array of Match
 }
</pre>
<p>


</p></li>
</ul>
</div>
<h2 id="Indirectly_quantified_subpattern_cap">Indirectly quantified subpattern captures</h2>
<div id="Indirectly_quantified_subpattern_cap-2">
<ul>
		<li><p>A subpattern may sometimes be nested inside a quantified non-capturing
structure:</p>
<pre>  #       non-capturing       quantifier
  #  __________/\____________  __/\__
  # |                        ||      |
  # |   $0         $1        ||      |
  # |  _^_      ___^___      ||      |
  # | |   |    |       |     ||      |
 m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /
</pre>
<p>Non-capturing brackets <i>don't</i> create a separate nested lexical scope,
so the two subpatterns inside them are actually still in the regex's
top-level scope, hence their top-level designations: <code>$0</code> and <code>$1</code>.	</p></li>
		<li><p>However, because the two subpatterns are inside a quantified
structure, <code>$0</code> and <code>$1</code> will each contain an array.
The elements of that array will be the submatches returned by the
corresponding subpatterns on each iteration of the non-capturing
parentheses. For example:</p>
<pre> my $text = &quot;foo:food fool\nbar:bard barb&quot;;

           #   $0--     $1------
           #   |   |    |       |
 $text ~~ m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /;

 # Because they're in a quantified non-capturing block...
 # $0 contains the equivalent of:
 #
 #       [ Match.new(str=&gt;'foo'), Match.new(str=&gt;'bar') ]
 #
 # and $1 contains the equivalent of:
 #
 #       [ Match.new(str=&gt;'food '),
 #         Match.new(str=&gt;'fool' ),
 #         Match.new(str=&gt;'bard '),
 #         Match.new(str=&gt;'barb' ),
 #       ]
</pre>
<p>


	</p></li>
		<li><p>In contrast, if the outer quantified structure is a <i>capturing</i>
structure (i.e. a subpattern) then it <i>will</i> introduce a nested
lexical scope. That outer quantified structure will then
return an array of <code>Match</code> objects representing the captures
of the inner parens for <i>every</i> iteration (as described above). That is:</p>
<pre> my $text = &quot;foo:food fool\nbar:bard barb&quot;;

           # $0-----------------------
           # |                        |
           # | $0[0]    $0[1]---      |
           # | |   |    |       |     |
 $text ~~ m/ ( (\w+) \: (\w+ \h*)* \n ) ** 2..* /;

 # Because it's in a quantified capturing block,
 # $0 contains the equivalent of:
 #
 #       [ Match.new( str=&gt;&quot;foo:food fool\n&quot;,
 #                    arr=&gt;[ Match.new(str=&gt;'foo'),
 #                           [
 #                               Match.new(str=&gt;'food '),
 #                               Match.new(str=&gt;'fool'),
 #                           ]
 #                         ],
 #                  ),
 #         Match.new( str=&gt;'bar:bard barb',
 #                    arr=&gt;[ Match.new(str=&gt;'bar'),
 #                           [
 #                               Match.new(str=&gt;'bard '),
 #                               Match.new(str=&gt;'barb'),
 #                           ]
 #                         ],
 #                  ),
 #       ]
 #
 # and there is no $1
</pre>	</p></li>
		<li><p>In other words, quantified non-capturing parens collect their components
into handy flattened lists, whereas quantified capturing parens collect
their components in a handy hierarchical structure.</p></li>
</ul>
</div>
<h2 id="Subpattern_numbering">Subpattern numbering</h2>
<div id="Subpattern_numbering_CONTENT">
<ul>
		<li><p>The index of a given subpattern can always be statically determined, but
is not necessarily unique nor always monotonic. The numbering of subpatterns
restarts in each lexical scope (either a regex, a subpattern, or the
branch of an alternation).	</p></li>
		<li><p>In particular, the index of capturing parentheses restarts after each
<code>|</code> or <code>||</code> (but not after each <code>&amp;</code> or <code>&amp;&amp;</code>). Hence:</p>
<pre>              # $0      $1    $2   $3    $4           $5
 $tune_up = rx/ (&quot;don't&quot;) (ray) (me) (for) (solar tea), (&quot;d'oh!&quot;)
              # $0      $1      $2    $3        $4
              | (every) (green) (BEM) (devours) (faces)
              /;
</pre>
<p>This means that if the second alternation matches, the <code>@$/</code> array will
contain <code>('every', 'green', 'BEM', 'devours', 'faces')</code> rather than
<code>(undef, undef, undef, undef, undef, undef, 'every', 'green', 'BEM',
'devours', 'faces')</code> (as the same regex would in Perl 5).	</p></li>
		<li><p>Note that it is still possible to mimic the monotonic Perl 5 capture
indexing semantics.  See <a href="#Numbered_scalar_aliasing">Numbered scalar aliasing</a> below for details.</p>
<p>


</p></li>
</ul>
</div>
<h2 id="Subrule_captures">Subrule captures</h2>
<div id="Subrule_captures_CONTENT">
<ul>
		<li><p>Any call to a named <code>&lt;regex&gt;</code> within a pattern is known as a
<i>subrule</i>, whether that regex is actually defined as a <code>regex</code> or
<code>token</code> or <code>rule</code> or even an ordinary <code>method</code> or <code>multi</code>.	</p></li>
		<li><p>Any bracketed construct that is aliased (see <a href="#Aliasing">Aliasing</a> below) to a
named variable is also a subrule.	</p></li>
		<li><p>For example, this regex contains three subrules:</p>
<pre>  # subrule       subrule     subrule
  #  __^__    _______^_____    __^__
  # |     |  |             |  |     |
 m/ &lt;ident&gt;  $&lt;spaces&gt;=(\s*)  &lt;digit&gt;+ /
</pre>	</p></li>
		<li><p>Just like subpatterns, each successfully matched subrule within a regex
produces a <code>Match</code> object. But, unlike subpatterns, that <code>Match</code>
object is not assigned to the array inside its parent <code>Match</code> object.
Instead, it is assigned to an entry of the hash inside its parent <code>Match</code>
object. For example:</p>
<pre>  #  .... $/ .....................................
  # :                                             :
  # :              .... $/[0] ..................  :
  # :             :                             : :
  # : $/&lt;ident&gt;   :        $/[0]&lt;ident&gt;         : :
  # :   __^__     :           __^__             : :
  # :  |     |    :          |     |            : :
  mm/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /
</pre>
<p>


</p></li>
</ul>
</div>
<h2 id="Accessing_captured_subrules">Accessing captured subrules</h2>
<div id="Accessing_captured_subrules_CONTENT">
<ul>
		<li><p>The hash entries of a <code>Match</code> object can be referred to using any of the
standard hash access notations (<code>$/{'foo'}</code>, <code>$/&lt;bar&gt;</code>, <code>$/«baz»</code>,
etc.), or else via corresponding lexically scoped aliases (<code>$&lt;foo&gt;</code>,
<code>$«bar»</code>, <code>$&lt;baz&gt;</code>, etc.)  So the previous example also implies:</p>
<pre>  #    $&lt;ident&gt;             $0&lt;ident&gt;
  #     __^__                 __^__
  #    |     |               |     |
  mm/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /
</pre>	</p></li>
		<li><p>Note that it makes no difference whether a subrule is angle-bracketed
(<code>&lt;ident&gt;</code>) or aliased internally (<code>&lt;ident=name&gt;</code>) or aliased
externally (<code>$&lt;ident&gt;=(&lt;alpha&gt;\w*)</code>). The name's the thing.</p>
<p>


</p></li>
</ul>
</div>
<h2 id="Repeated_captures_of_the_same_subrul">Repeated captures of the same subrule</h2>
<div id="Repeated_captures_of_the_same_subrul-2">
<ul>
		<li><p>If a subrule appears two (or more) times in any branch of a lexical
scope (i.e. twice within the same subpattern and alternation), or if the
subrule is quantified anywhere within a given scope, then its
corresponding hash entry is always assigned an array of
<code>Match</code> objects rather than a single <code>Match</code> object.	</p></li>
		<li><p>Successive matches of the same subrule (whether from separate calls, or
from a single quantified repetition) append their individual <code>Match</code>
objects to this array. For example:</p>
<pre> if mm/ mv &lt;file&gt; &lt;file&gt; / {
     $from = $&lt;file&gt;[0];
     $to   = $&lt;file&gt;[1];
 }
</pre>
<p>(Note, for clarity we are ignoring whitespace subtleties here--the
normal sigspace rules would require space only between alphanumeric
characters, which is wrong.  Assume that our file subrule deals
with whitespace on its own.)</p>
<p>Likewise, with a quantified subrule:</p>
<pre> if mm/ mv &lt;file&gt; ** 2 / {
     $from = $&lt;file&gt;[0];
     $to   = $&lt;file&gt;[1];
 }
</pre>
<p>And with a mixture of both:</p>
<pre> if mm/ mv &lt;file&gt;+ &lt;file&gt; / {
     $to   = pop @($&lt;file&gt;);
     @from = @($&lt;file&gt;);
 }
</pre>	</p></li>
		<li><p>However, if a subrule is explicitly renamed (or aliased -- see <a href="#Aliasing">Aliasing</a>),
then only the <i>new</i> name counts when deciding whether it is or isn't
repeated. For example:</p>
<pre> if mm/ mv &lt;file&gt; &lt;dir=file&gt; / {
     $from = $&lt;file&gt;;  # Only one subrule named &lt;file&gt;, so scalar
     $to   = $&lt;dir&gt;;   # The Capture Formerly Known As &lt;file&gt;
 }
</pre>

<p>Likewise, neither of the following constructions causes <code>&lt;file&gt;</code> to
produce an array of <code>Match</code> objects, since none of them has two or more
<code>&lt;file&gt;</code> subrules in the same lexical scope:</p>
<pre> if mm/ (keep) &lt;file&gt; | (toss) &lt;file&gt; / {
     # Each &lt;file&gt; is in a separate alternation, therefore &lt;file&gt;
     # is not repeated in any one scope, hence $&lt;file&gt; is
     # not an Array object...
     $action = $0;
     $target = $&lt;file&gt;;
 }

 if mm/ &lt;file&gt; \: (&lt;file&gt;|none) / {
     # Second &lt;file&gt; nested in subpattern which confers a
     # different scope...
     $actual  = $/&lt;file&gt;;
     $virtual = $/[0]&lt;file&gt; if $/[0]&lt;file&gt;;
 }
</pre>	</p></li>
		<li><p>On the other hand, unaliased square brackets don't confer a separate
scope (because they don't have an associated <code>Match</code> object). So:</p>
<pre> if mm/ &lt;file&gt; \: [&lt;file&gt;|none] / { # Two &lt;file&gt;s in same scope
     $actual  = $/&lt;file&gt;[0];
     $virtual = $/&lt;file&gt;[1] if $/&lt;file&gt;[1];
 }
</pre>
<p>


</p></li>
</ul>
</div>
<h2 id="Aliasing">Aliasing</h2>
<div id="Aliasing_CONTENT">
<p>Aliases can be named or numbered. They can be scalar-, array-, or hash-like.
And they can be applied to either capturing or non-capturing constructs. The
following sections highlight special features of the semantics of some
of those combinations.</p>
</div>
<h3 id="Named_scalar_aliasing_to_subpatterns">Named scalar aliasing to subpatterns</h3>
<div id="Named_scalar_aliasing_to_subpatterns-2">
<ul>
		<li><p>If a named scalar alias is applied to a set of <i>capturing</i> parens:</p>
<pre>    #         _____/capturing parens\_____
    #        |                            |
    #        |                            |
  mm/ $&lt;key&gt;=( (&lt;[A..E]&gt;) (\d**3..6) (X?) ) /;
</pre>
<p>then the outer capturing parens no longer capture into the array of
<code>$/</code> as unaliased parens would. Instead the aliased parens capture
into the hash of <code>$/</code>; specifically into the hash element
whose key is the alias name.	</p></li>
		<li><p>So, in the above example, a successful match sets
<code>$&lt;key&gt;</code> (i.e. <code>$/&lt;key&gt;</code>), but <i>not</i> <code>$0</code> (i.e. not <code>$/[0]</code>).	</p></li>
		<li><p>More specifically:		<li><p>
			<ul>
					<li><p><code>$/&lt;key&gt;</code> will contain the <code>Match</code> object that would previously have
been placed in <code>$/[0]</code>.				</p></li>
					<li><p><code>$/&lt;key&gt;[0]</code> will contain the A-E letter,				</p></li>
					<li><p><code>$/&lt;key&gt;[1]</code> will contain the digits,				</p></li>
					<li><p><code>$/&lt;key&gt;[2]</code> will contain the optional X.</p></li>
</ul>

		</p></li>
	</p></li>
		<li><p>Another way to think about this behavior is that aliased parens create
a kind of lexically scoped named subrule; that the contents of the
parentheses are treated as if they were part of a separate subrule whose
name is the alias.</p>
<p>


</p></li>
</ul>
</div>
<h3 id="Named_scalar_aliases_applied_to_non_">Named scalar aliases applied to non-capturing brackets</h3>
<div id="Named_scalar_aliases_applied_to_non_-2">
<ul>
		<li><p>If a named scalar alias is applied to a set of <i>non-capturing</i> brackets:</p>
<pre>    #         __/non-capturing brackets\__
    #        |                            |
    #        |                            |
  mm/ $&lt;key&gt;=[ (&lt;[A..E]&gt;) (\d**3..6) (X?) ] /;
</pre>
<p>then the corresponding <code>$/&lt;key&gt;</code> <code>Match</code> object contains only the string
matched by the non-capturing brackets.	</p></li>
		<li><p>In particular, the array of the <code>$/&lt;key&gt;</code> entry is empty. That's
because square brackets do not create a nested lexical scope, so the
subpatterns are unnested and hence correspond to $0, $1, and $2, and
<i>not</i> to <code>$/&lt;key&gt;[0]</code>, <code>$/&lt;key&gt;[1]</code>, and <code>$/&lt;key&gt;[2]</code>.	</p></li>
		<li><p>In other words:		<li><p>
			<ul>
					<li><p><code>$/&lt;key&gt;</code> will contain the complete substring matched by the square
brackets (in a <code>Match</code> object, as described above),				</p></li>
					<li><p><code>$0</code> will contain the A-E letter,				</p></li>
					<li><p><code>$1</code> will contain the digits,				</p></li>
					<li><p><code>$2</code> will contain the optional X.</p></li>
</ul>

		</p></li>
</p>
<p>


</p></li>
</ul>
</div>
<h3 id="Named_scalar_aliasing_to_subrules">Named scalar aliasing to subrules</h3>
<div id="Named_scalar_aliasing_to_subrules_CO">
<ul>
		<li><p>If a subrule is aliased, it assigns its <code>Match</code> object to the hash
entry whose key is the name of the alias. And it <i>no longer</i> assigns
anything to the hash entry whose key is the subrule name. That is:</p>
<pre> if m/ ID\: &lt;id=ident&gt; / {
     say &quot;Identified as $/&lt;id&gt;&quot;;    # $/&lt;ident&gt; is undefined
 }
</pre>	</p></li>
		<li><p>Hence aliasing a subrule <i>changes</i> the destination of the subrule's <code>Match</code>
object. This is particularly useful for differentiating two or more calls to
the same subrule in the same scope. For example:</p>
<pre> if mm/ mv &lt;file&gt;+ &lt;dir=file&gt; / {
     @from = @($&lt;file&gt;);
     $to   = $&lt;dir&gt;;
 }
</pre></p></li>
</ul>
</div>
<h3 id="Numbered_scalar_aliasing">Numbered scalar aliasing</h3>
<div id="Numbered_scalar_aliasing_CONTENT">
<ul>
		<li><p>If a numbered alias is used instead of a named alias:</p>
<pre> m/ $1=(&lt;-[:]&gt;*) \:  $0=&lt;ident&gt; /
</pre>
<p>the behavior is exactly the same as for a named alias (i.e. the various
cases described above), except that the resulting <code>Match</code> object is
assigned to the corresponding element of the appropriate array rather
than to an element of the hash.	</p></li>
		<li><p>If any numbered alias is used, the numbering of subsequent unaliased
subpatterns in the same scope automatically increments from that
alias number (much like enum values increment from the last explicit
value). That is:</p>
<pre>  #  --$1---    -$2-    --$6---    -$7-
  # |       |  |    |  |       |  |    |
 m/ $1=(food)  (bard)  $6=(bazd)  (quxd) /;
</pre>	</p></li>
		<li><p>This <i>follow-on</i> behavior is particularly useful for reinstituting
Perl5 semantics for consecutive subpattern numbering in alternations:</p>
<pre> $tune_up = rx/ (&quot;don't&quot;) (ray) (me) (for) (solar tea), (&quot;d'oh!&quot;)
              | $6 = (every) (green) (BEM) (devours) (faces)
              #              $7      $8    $9        $10
              /;
</pre>	</p></li>
		<li><p>It also provides an easy way in Perl 6 to reinstitute the unnested
numbering semantics of nested Perl 5 subpatterns:</p>
<pre>  # Perl 5...
  #               $1
  #  _____________/\___________
  # |    $2        $3      $4  |
  # |  __/\___   __/\___   /\  |
  # | |       | |       | |  | |
 m/ ( ( [A-E] ) (\d{3,6}) (X?) ) /x;

  # Perl 6...
  #                $0
  #  ______________/\______________
  # |   $0[0]       $0[1]    $0[2] |
  # |  ___/\___   ____/\____   /\  |
  # | |        | |          | |  | |
 m/ ( (&lt;[A..E]&gt;) (\d ** 3..6) (X?) ) /;

  # Perl 6 simulating Perl 5...
  #                 $1
  #  _______________/\________________
  # |        $2          $3       $4  |
  # |     ___/\___   ____/\____   /\  |
  # |    |        | |          | |  | |
 m/ $1=[ (&lt;[A..E]&gt;) (\d ** 3..6) (X?) ] /;
</pre>
<p>The non-capturing brackets don't introduce a scope, so the subpatterns within
them are at regex scope, and hence numbered at the top level. Aliasing the
square brackets to <code>$1</code> means that the next subpattern at the same level
(i.e. the <code>(&lt;[A..E]&gt;)</code>) is numbered sequentially (i.e. <code>$2</code>), etc.</p>
<p>


</p></li>
</ul>
</div>
<h3 id="Scalar_aliases_applied_to_quantified">Scalar aliases applied to quantified constructs</h3>
<div id="Scalar_aliases_applied_to_quantified-2">
<ul>
		<li><p>All of the above semantics apply equally to aliases which are bound to
quantified structures.	</p></li>
		<li><p>The only difference is that, if the aliased construct is a subrule or
subpattern, that quantified subrule or subpattern will have returned a
list of <code>Match</code> objects (as described in <a href="#Quantified_subpattern_captures">Quantified subpattern captures</a> and <a href="#Repeated_captures_of_the_same_subrul">Repeated captures of the same subrule</a>).
So the corresponding array element or hash entry for the alias will
contain an array, instead of a single <code>Match</code> object.	</p></li>
		<li><p>In other words, aliasing and quantification are completely orthogonal.
For example:</p>
<pre> if mm/ mv $0=&lt;file&gt;+ / {
     # &lt;file&gt;+ returns a list of Match objects,
     # so $0 contains an array of Match objects,
     # one for each successful call to &lt;file&gt;

     # $/&lt;file&gt; does not exist (it's pre-empted by the alias)
 }

 if m/ mv \s+ $&lt;from&gt;=(\S+ \s+)* / {
     # Quantified subpattern returns a list of Match objects,
     # so $/&lt;from&gt; contains an array of Match
     # objects, one for each successful match of the subpattern

     # $0 does not exist (it's pre-empted by the alias)
 }
</pre>	</p></li>
		<li><p>Note, however, that a set of quantified <i>non-capturing</i> brackets always
returns a single <code>Match</code> object which contains only the complete
substring that was matched by the full set of repetitions of the
brackets (as described in <a href="#Named_scalar_aliases_applied_to_non_">Named scalar aliases applied to non-capturing brackets</a>). For example:</p>
<pre> &quot;coffee fifo fumble&quot; ~~ m/ $&lt;effs&gt;=[f &lt;-[f]&gt; ** 1..2 \s*]+ /;

 say $&lt;effs&gt;;    # prints &quot;fee fifo fum&quot;
</pre>
<p>


</p></li>
</ul>
</div>
<h3 id="Array_aliasing">Array aliasing</h3>
<div id="Array_aliasing_CONTENT">
<ul>
		<li><p>An alias can also be specified using an array as the alias instead of a scalar.
For example:</p>
<pre> m/ mv \s+ @&lt;from&gt;=[(\S+) \s+]* &lt;dir&gt; /;
</pre>	</p></li>
		<li><p>Using the <code>@alias=</code> notation instead of a <code>$alias=</code>
mandates that the corresponding hash entry or array element <i>always</i>
receives an array of <code>Match</code> objects, even if the
construct being aliased would normally return a single <code>Match</code> object.
This is useful for creating consistent capture semantics across
structurally different alternations (by enforcing array captures in all
branches):</p>
<pre> mm/ Mr?s? @&lt;names&gt;=&lt;ident&gt; W\. @&lt;names&gt;=&lt;ident&gt;
    | Mr?s? @&lt;names&gt;=&lt;ident&gt;
    /;

 # Aliasing to @names means $/&lt;names&gt; is always
 # an Array object, so...

 say @($/&lt;names&gt;);
</pre>	</p></li>
		<li><p>For convenience and consistency, <code>@&lt;key&gt;</code> can also be used outside a
regex, as a shorthand for <code>@( $/&lt;key&gt; )</code>. That is:</p>
<pre> mm/ Mr?s? @&lt;names&gt;=&lt;ident&gt; W\. @&lt;names&gt;=&lt;ident&gt;
    | Mr?s? @&lt;names&gt;=&lt;ident&gt;
    /;

 say @&lt;names&gt;;
</pre>	</p></li>
		<li><p>If an array alias is applied to a quantified pair of non-capturing
brackets, it captures the substrings matched by each repetition of the
brackets into separate elements of the corresponding array. That is:</p>
<pre> mm/ mv $&lt;files&gt;=[ f.. \s* ]* /; # $/&lt;files&gt; assigned a single
                                 # Match object containing the
                                 # complete substring matched by
                                 # the full set of repetitions
                                 # of the non-capturing brackets

 mm/ mv @&lt;files&gt;=[ f.. \s* ]* /; # $/&lt;files&gt; assigned an array,
                                 # each element of which is a
                                 # Match object containing
                                 # the substring matched by Nth
                                 # repetition of the non-
                                 # capturing bracket match
</pre>	</p></li>
		<li><p>If an array alias is applied to a quantified pair of capturing parens
(i.e. to a subpattern), then the corresponding hash or array element is
assigned a list constructed by concatenating the array values of each
<code>Match</code> object returned by one repetition of the subpattern. That is,
an array alias on a subpattern flattens and collects all nested
subpattern captures within the aliased subpattern. For example:</p>
<pre> if mm/ $&lt;pairs&gt;=( (\w+) \: (\N+) )+ / {
     # Scalar alias, so $/&lt;pairs&gt; is assigned an array
     # of Match objects, each of which has its own array
     # of two subcaptures...

     for @($&lt;pairs&gt;) -&gt; $pair {
         say &quot;Key: $pair[0]&quot;;
         say &quot;Val: $pair[1]&quot;;
     }
 }

 if mm/ @&lt;pairs&gt;=( (\w+) \: (\N+) )+ / {
     # Array alias, so $/&lt;pairs&gt; is assigned an array
     # of Match objects, each of which is flattened out of
     # the two subcaptures within the subpattern

     for @($&lt;pairs&gt;) -&gt; $key, $val {
         say &quot;Key: $key&quot;;
         say &quot;Val: $val&quot;;
     }
 }
</pre>	</p></li>
		<li><p>Likewise, if an array alias is applied to a quantified subrule, then the
hash or array element corresponding to the alias is assigned a list
containing the array values of each <code>Match</code> object returned by each
repetition of the subrule, all flattened into a single array:</p>
<pre> rule pair { (\w+) \: (\N+) \n }

 if mm/ $&lt;pairs&gt;=&lt;pair&gt;+ / {
     # Scalar alias, so $/&lt;pairs&gt; contains an array of
     # Match objects, each of which is the result of the
     # &lt;pair&gt; subrule call...

     for @($&lt;pairs&gt;) -&gt; $pair {
         say &quot;Key: $pair[0]&quot;;
         say &quot;Val: $pair[1]&quot;;
     }
 }

 if mm/ mv @&lt;pairs&gt;=&lt;pair&gt;+ / {
     # Array alias, so $/&lt;pairs&gt; contains an array of
     # Match objects, all flattened down from the
     # nested arrays inside the Match objects returned
     # by each match of the &lt;pair&gt; subrule...

     for @($&lt;pairs&gt;) -&gt; $key, $val {
         say &quot;Key: $key&quot;;
         say &quot;Val: $val&quot;;
     }
 }
</pre>	</p></li>
		<li><p>In other words, an array alias is useful to flatten into a single array
any nested captures that might occur within a quantified subpattern or subrule.
Whereas a scalar alias is useful to preserve within a top-level array
the internal structure of each repetition.	</p></li>
		<li><p>It is also possible to use a numbered variable as an array alias.
The semantics are exactly as described above, with the sole difference
being that the resulting array of <code>Match</code> objects is assigned into the
appropriate element of the regex's match array rather than to a key of
its match hash. For example:</p>
<pre> if m/ mv  \s+  @0=((\w+) \s+)+  $1=((\W+) (\s*))* / {
     #          |                |
     #          |                |
     #          |                 \_ Scalar alias, so $1 gets an
     #          |                    array, with each element
     #          |                    a Match object containing
     #          |                    the two nested captures
     #          |
     #           \___ Array alias, so $0 gets a flattened array of
     #                just the (\w+) captures from each repetition

     @from     = @($0);      # Flattened list

     $to_str   = $1[0][0];   # Nested elems of
     $to_gap   = $1[0][1];   #    unflattened list
 }
</pre>	</p></li>
		<li><p>Note again that, outside a regex, <code>@0</code> is simply a shorthand for
<code>@($0)</code>, so the first assignment above could also have been written:</p>
<pre> @from = @0;
</pre>
<p>


</p></li>
</ul>
</div>
<h3 id="Hash_aliasing">Hash aliasing</h3>
<div id="Hash_aliasing_CONTENT">
<ul>
		<li><p>An alias can also be specified using a hash as the alias variable,
instead of a scalar or an array. For example:</p>
<pre> m/ mv %&lt;location&gt;=( (&lt;ident&gt;) \: (\N+) )+ /;
</pre>	</p></li>
		<li><p>A hash alias causes the corresponding hash or array element in the
current scope's <code>Match</code> object to be assigned a (nested) Hash object
(rather than an <code>Array</code> object or a single <code>Match</code> object).	</p></li>
		<li><p>If a hash alias is applied to a subrule or subpattern then the first nested
numeric capture becomes the key of each hash entry and any remaining numeric
captures become the values (in an array if there is more than one).	</p></li>
		<li><p>As with array aliases it is also possible to use a numbered variable as
a hash alias. Once again, the only difference is where the resulting
<code>Match</code> object is stored:</p>
<pre> rule one_to_many {  (\w+) \: (\S+) (\S+) (\S+) }

 if mm/ %0=&lt;one_to_many&gt;+ / {
     # $/[0] contains a hash, in which each key is provided by
     # the first subcapture within C&lt;one_to_many&gt;, and each
     # value is an array containing the
     # subrule's second, third, fourth, etc. subcaptures...

     for %($/[0]) -&gt; $pair {
         say &quot;One:  $pair.key()&quot;;
         say &quot;Many: { @($pair.value) }&quot;;
     }
 }
</pre>	</p></li>
		<li><p>Outside the regex, <code>%0</code> is a shortcut for <code>%($0)</code>:</p>
<pre>     for %0 -&gt; $pair {
         say &quot;One:  $pair.key()&quot;;
         say &quot;Many: @($pair.value)&quot;;
     }
</pre>
<p>


</p></li>
</ul>
</div>
<h3 id="External_aliasing">External aliasing</h3>
<div id="External_aliasing_CONTENT">
<ul>
		<li><p>Instead of using internal aliases like:</p>
<pre> m/ mv  @&lt;files&gt;=&lt;ident&gt;+  $&lt;dir&gt;=&lt;ident&gt; /
</pre>
<p>the name of an ordinary variable can be used as an <i>external</i> alias, like so:</p>
<pre> m/ mv  @OUTER::files=&lt;ident&gt;+  $OUTER::dir=&lt;ident&gt; /
</pre>	</p></li>
		<li><p>In this case, the behavior of each alias is exactly as described in the
previous sections, except that any resulting capture is bound
directly (but still hypothetically) to the variable of the specified
name that must already exist in the scope in which the regex is declared.</p>
<p>


</p></li>
</ul>
</div>
<h2 id="Capturing_from_repeated_matches">Capturing from repeated matches</h2>
<div id="Capturing_from_repeated_matches_CONT">
<ul>
		<li><p>When an entire regex is successfully matched with repetitions
(specified via the <code>:x</code> or <code>:g</code> flag) or overlaps (specified via the
<code>:ov</code> or <code>:ex</code> flag), it will usually produce a series
of distinct matches.	</p></li>
		<li><p>A successful match under any of these flags still returns a single
<code>Match</code> object in <code>$/</code>. However, this object may represent a partial
evaluation of the regex.   Moreover, the values of this match object
are slightly different from those provided by a non-repeated match:		<li><p>
			<ul>
					<li><p>The boolean value of <code>$/</code> after such matches is true or false, depending on
whether the pattern matched.				</p></li>
					<li><p>The string value is the substring from the start of the first match to
the end of the last match (<i>including</i> any intervening parts of the
string that the regex skipped over in order to find later matches).				</p></li>
					<li><p>Subcaptures are returned as a multidimensional list, which the user can
choose to process in either of two ways.  If you refer to
<code>@()</code>, the multidimensionality is ignored and all the matches are returned
flattened (but still lazily).  If you refer to <code>@@()</code>, you can
get each individual sublist as a <code>Capture</code> object. (That is, there is a <code>@@()</code>
coercion operator that happens, like <code>@()</code>, to default to <code>$/</code>.)
As with any multidimensional list, each sublist can be lazy separately.</p></li>
</ul>

		</p></li>
</p>
<p>For example:</p>
<pre> if $text ~~ mm:g/ (\S+:) &lt;rocks&gt; / {
     say &quot;Full match context is: [$/]&quot;;
 }
</pre>
<p>But the list of individual match objects corresponding to each separate
match is also available:</p>
<pre> if $text ~~ mm:g/ (\S+:) &lt;rocks&gt; / {
     say &quot;Matched { +@@() } times&quot;;    # Note: forced eager here

     for @@() -&gt; $m {
         say &quot;Match between $m.from() and $m.to()&quot;;
         say 'Right on, dude!' if $m[0] eq 'Perl';
         say &quot;Rocks like $m&lt;rocks&gt;&quot;;
     }
 }
</pre></p></li>
</ul>
</div>
<h2 id="code_keepall_code"><code>:keepall</code></h2>
<div id="code_keepall_code_CONTENT">
<ul>
		<li><p>All regexes remember everything if <code>:keepall</code> is in effect
anywhere in the outer dynamic scope.  In this case everything inside
the angles is used as part of the key.  Suppose the earlier example
parsed whitespace:</p>
<pre> / &lt;key&gt; &lt;.ws&gt; '=&gt;' &lt;.ws&gt; &lt;value&gt; { %hash{$key} = $value } /
</pre>
<p>The two instances of <code>&lt;.ws&gt;</code> above would store an array of two
values accessible as <code>@&lt;.ws&gt;</code>.  It would also store the literal
match into <code>$&lt;'=\&gt;'&gt;</code>.  Just to make sure nothing is forgotten,
under <code>:keepall</code> any text or whitespace not otherwise remembered is
attached as an extra property on the subsequent node. (The name of
that property is &quot;<code>pretext</code>&quot;.)</p></li>
</ul>
</div>
<h1 id="Grammars">Grammars</h1>
<div id="Grammars_CONTENT">
<ul>
		<li><p>Your private <code>ident</code> rule shouldn't clobber someone else's
<code>ident</code> rule.  So some mechanism is needed to confine rules to a namespace.	</p></li>
		<li><p>If subs are the model for rules, then modules/classes are the obvious
model for aggregating them.  Such collections of rules are generally
known as <i>grammars</i>.	</p></li>
		<li><p>Just as a class can collect named actions together:</p>
<pre> class Identity {
     method name { &quot;Name = $.name&quot; }
     method age  { &quot;Age  = $.age&quot;  }
     method addr { &quot;Addr = $.addr&quot; }

     method desc {
         print &amp;.name(), &quot;\n&quot;,
               &amp;.age(),  &quot;\n&quot;,
               &amp;.addr(), &quot;\n&quot;;
     }

     # etc.
 }
</pre>
<p>so too a grammar can collect a set of named rules together:</p>
<pre> grammar Identity {
     rule name { Name '=' (\N+) }
     rule age  { Age  '=' (\d+) }
     rule addr { Addr '=' (\N+) }
     rule desc {
         &lt;name&gt; \n
         &lt;age&gt;  \n
         &lt;addr&gt; \n
     }

     # etc.
 }
</pre>	</p></li>
		<li><p>Like classes, grammars can inherit:</p>
<pre> grammar Letter {
     rule text     { &lt;greet&gt; &lt;body&gt; &lt;close&gt; }

     rule greet { [Hi|Hey|Yo] $&lt;to&gt;=(\S+?) , $$}

     rule body     { &lt;line&gt;+? }   # note: backtracks forwards via +?

     rule close { Later dude, $&lt;from&gt;=(.+) }

     # etc.
 }

 grammar FormalLetter is Letter {

     rule greet { Dear $&lt;to&gt;=(\S+?) , $$}

     rule close { Yours sincerely, $&lt;from&gt;=(.+) }

 }
</pre>	</p></li>
		<li><p>Just like the methods of a class, the rule definitions of a grammar are
inherited (and polymorphic!). So there's no need to respecify <code>body</code>,
<code>line</code>, etc.	</p></li>
		<li><p>Perl 6 will come with at least one grammar predefined:</p>
<pre> grammar STD {    # Perl's own standard grammar

     rule prog { &lt;statement&gt;* }

     rule statement {
               | &lt;decl&gt;
               | &lt;loop&gt;
               | &lt;label&gt; [&lt;cond&gt;|&lt;sideff&gt;|;]
     }

     rule decl { &lt;sub&gt; | &lt;class&gt; | &lt;use&gt; }

     # etc. etc. etc.
 }
</pre>	</p></li>
		<li><p>Hence:</p>
<pre> given $source_code {
     $parsetree = m:keepall/&lt;Perl::prog&gt;/;
 }
</pre>	</p></li>
		<li><p>To switch to a different grammar in the middle of a regex, you may use the <code>:lang</code> adverb.
For example, to match an expression &lt;expr&gt; from $funnylang that is embedded in curlies, say:</p>
<pre>token funnylang { '{' [ :lang($funnylang.unbalanced('}')) &lt;expr&gt; ] '}' }
</pre>	</p></li>
		<li><p>A string can be matched against a grammar by calling <code>.parse</code> on the grammar,
and optionally pass an <i>action</i> object to that grammar:</p>
<pre>MyGrammar.parse($str, :action($action-object))
</pre>
<p>Whenever a closure within the grammar returns a <code>Whatever</code> object, the
grammar engine tries to call a method of the same name as the name of the
current regex on the action object, passing along the current <code>Match</code>
object as the first positional argument, and the tag of the reduction (if
any) as the second argument.  The tag is supplied via a <code>#=</code> comment later
on the same line as the <code>{*}</code>.  There must be whitespace between the <code>#=</code>
and the tag, but the tag itself may contain spaces.</p>
<pre>   grammar Integer {
   token TOP {
       | 0b&lt;[01]&gt;+ {*}  #= binary
       | \d+       {*}  #= decimal
   }
   }
   class Twice {
   multi method TOP($match, $tag) {
       my $text = ~$match;
       $text = :2($text) if $tag eq 'binary'
       make $text;
   }
   multi method TOP($match) {
       make 2 * $match.ast;
   }
   }
   Integer.parse('21', :action(Twice.new)).ast      # 42
</pre>
<p>A <code>{*}</code> is assumed at the end of every rule, and the method is
called with no tag argument.  Note that the implicit <code>{*}</code> is
<i>outside</i> the alternation in the <code>TOP</code> rule above, despite
the fact that no explicit square brackets were used.</p></li>
</ul>
</div>
<h1 id="Syntactic_categories">Syntactic categories</h1>
<div id="Syntactic_categories_CONTENT">
<p>For writing your own backslash and assertion subrules, you may augment
(your copy of) the Regex sublanguage, using the following syntactic
categories:</p>
<pre>augment slang Regex {
    token backslash:sym&lt;y&gt; { ... }   # define your own \y and \Y
    token assertion:sym&lt;*&gt; { ... }   # define your own &lt;*stuff&gt;
    token metachar:sym&lt;,&gt; { ... }    # define a new metacharacter

    multi method tweak (:$x) {...}   # define your own :x modifier
}
</pre>
</div>
<h1 id="Pragmas">Pragmas</h1>
<div id="Pragmas_CONTENT">
<p>Various pragmas may be used to control various aspects of regex
compilation and usage not otherwise provided for.  These are tied
to the particular declarator in question:</p>
<pre>use s :foo;         # control s defaults
use m :foo;         # control m defaults
use rx :foo;        # control rx defaults
use regex :foo;     # control regex defaults
use token :foo;     # control token defaults
use rule :foo;      # control rule defaults
</pre>
<p>(It is a general policy in Perl 6 that any pragma designed to influence
the surface behavior of a keyword is identical to the keyword itself, unless
there is good reason to do otherwise.  On the other hand, pragmas designed
to influence deep semantics should not be named identically, though of
course some similarity is good.)</p>
</div>
<h1 id="Transliteration">Transliteration</h1>
<div id="Transliteration_CONTENT">
<ul>
		<li><p>The <code>tr///</code> quote-like operator now also has a method form called
<code>trans()</code>.  Its argument is a list of pairs.  You can use anything that
produces a pair list:</p>
<pre> $str.trans( %mapping.pairs.sort );
</pre>
<p>Use the <code>.=</code> form to do a translation in place:</p>
<pre> $str.=trans( %mapping.pairs.sort );
</pre>
<p>(Perl 6 does not support the <code>y///</code> form, which was only in <code>sed</code> because
they were running out of single letters.)	</p></li>
		<li><p>The two sides of any pair can be strings interpreted as <code>tr///</code> would:</p>
<pre> $str.=trans( 'A..C' =&gt; 'a..c', 'XYZ' =&gt; 'xyz' );
</pre>
<p>As a degenerate case, each side can be individual characters:</p>
<pre> $str.=trans( 'A'=&gt;'a', 'B'=&gt;'b', 'C'=&gt;'c' );
</pre>
<p>Whitespace characters are taken literally as characters to be
translated from or to.  The <code>..</code> range sequence is the only metasyntax
recognized within a string, though you may of course use backslash
interpolations in double quotes.  If the right side is too short, the
final character is replicated out to the length of the left string.
If there is no final character because the right side is the null
string, the result is deletion instead.	</p></li>
		<li><p>Either or both sides of the pair may also be Array objects:</p>
<pre> $str.=trans( ['A'..'C'] =&gt; ['a'..'c'], &lt;X Y Z&gt; =&gt; &lt;x y z&gt; );
</pre>
<p>The array version is the underlying primitive form: the semantics of
the string form is exactly equivalent to first doing <code>..</code> expansion
and then splitting the string into individual characters and then
using that as an array.	</p></li>
		<li><p>The array version can map one-or-more characters to one-or-more
characters:</p>
<pre> $str.=trans( [' ',      '&lt;',    '&gt;',    '&amp;'    ] =&gt;
              ['&amp;nbsp;', '&amp;lt;', '&amp;gt;', '&amp;amp;' ]);
</pre>
<p>In the case that more than one sequence of input characters matches,
the longest one wins.  In the case of two identical sequences the
first in order wins.</p>
<p>As with the string form, missing righthand elements replicate the
final element, and a null array results in deletion instead.	</p></li>
		<li><p>The recognition done by the string and array forms is very basic.
To achieve greater power, any recognition element of the left side
may be specified by a regex that can do character classes, lookahead,
etc.</p>

<pre>$str.=trans( [/ \h /,   '&lt;',    '&gt;',    '&amp;'    ] =&gt;
             ['&amp;nbsp;', '&amp;lt;', '&amp;gt;', '&amp;amp;' ]);

$str.=trans( / \s+ / =&gt; ' ' );  # squash all whitespace to one space
$str.=trans( / &lt;!alpha&gt; / =&gt; '' );  # delete all non-alpha
</pre>
<p>These submatches are mixed into the overall match in exactly the same way that
they are mixed into parallel alternation in ordinary regex processing, so
longest token rules apply across all the possible matches specified to the
transliteration operator.  Once a match is made and transliterated, the parallel
matching resumes at the new position following the end of the previous match,
even if it matched multiple characters.	</p></li>
		<li><p>If the right side of the arrow is a closure, it is evaluated to
determine the replacement value.  If the left side was matched by a
regex, the resulting match object is available within the closure.</p></li>
</ul>
</div>
<h1 id="Substitution">Substitution</h1>
<div id="Substitution_CONTENT">
<p>There are also method forms of <code>m//</code> and <code>s///</code>:</p>
<pre> $str.match(/pat/);
 $str.subst(/pat/, &quot;replacement&quot;);
 $str.subst(/pat/, {&quot;replacement&quot;});
 $str.=subst(/pat/, &quot;replacement&quot;);
 $str.=subst(/pat/, {&quot;replacement&quot;});
</pre>
<p>There is no syntactic sugar here, so in order to get deferred
evaluation of the replacement you must put it into a closure.  The
syntactic sugar is provided only by the quotelike forms.  First there
is the standard &quot;triple quote&quot; form:</p>
<pre>s/pattern/replacement/
</pre>
<p>Only non-bracket characters may be used for the &quot;triple quote&quot;.  The
right side is always evaluated as if it were a double-quoted string
regardless of the quote chosen.</p>
<p>As with Perl 5, a bracketing form is also supported, but unlike Perl 5,
Perl 6 uses the brackets <i>only</i> around the pattern.  The replacement
is then specified as if it were an ordinary item assignment, with ordinary
quoting rules.  To pick your own quotes on the right just use one of the <code>q</code>
forms.  The substitution above is equivalent to:</p>
<pre>s[pattern] = &quot;replacement&quot;
</pre>
<p>or</p>
<pre>s[pattern] = qq[replacement]
</pre>
<p>This is not a normal assigment, since the right side is evaluated each
time the substitution matches (much like the pseudo-assignment to declarators
can happen at strange times).  It is therefore treated as a &quot;thunk&quot;, that is,
as if it has implicit curlies around it.  In fact, it makes no sense at
all to say</p>
<pre>s[pattern] = { doit }
</pre>
<p>because that would try to substitute a closure into the string.</p>
<p>Any scalar assignment operator may be used; the substitution macro
knows how to turn</p>
<pre>$target ~~ s:g[pattern] op= expr
</pre>
<p>into something like:</p>
<pre>$target.subst(rx:g[pattern], { $() op expr })
</pre>
<p>So, for example, you can multiply every dollar amount by 2 with:</p>
<pre>s:g[\$ &lt;( \d+ )&gt;] *= 2
</pre>
<p>(Of course, the optimizer is free to do something faster than an actual
method call.)</p>
<p>You'll note from the last example that substitutions only happen on
the &quot;official&quot; string result of the match, that is, the portion of
the string between the <code>$/.from</code> and <code>$/.to</code> positions.
(Here we set those explicitly using the <code>&lt;(...)&gt;</code> pair; otherwise we
would have had to use lookbehind to match the <code>$</code>.)</p>
</div>
<h1 id="Positional_matching_fixed_width_type">Positional matching, fixed width types</h1>
<div id="Positional_matching_fixed_width_type-2">
<ul>
		<li><p>To anchor to a particular position in the general case you can use
the <code>&lt;at($pos)&gt;</code> assertion to say that the current position
is the same as the position object you supply.  You may set the
current match position via the <code>:c</code> and <code>:p</code> modifiers.</p>
<p>However, please remember that in Perl 6 string positions are generally
<i>not</i> integers, but objects that point to a particular place in
the string regardless of whether you count by bytes or codepoints or
graphemes.  If used with an integer, the <code>at</code> assertion will assume
you mean the current lexically scoped Unicode level, on the assumption
that this integer was somehow generated in this same lexical scope.
If this is outside the current string's allowed Unicode abstraction levels, an
exception is thrown.  See S02 for more discussion of string positions.	</p></li>
		<li><p><code>Buf</code> types are based on fixed-width cells and can therefore
handle integer positions just fine, and treat them as array indices.
In particular, <code>buf8</code> (also known as <code>buf</code>) is just an old-school byte string.
Matches against <code>Buf</code> types are restricted to ASCII semantics in
the absence of an <i>explicit</i> modifier asking for the array's values
to be treated as some particular encoding such as UTF-32.  (This is
also true for those compact arrays that are considered isomorphic to
<code>Buf</code> types.)  Positions within <code>Buf</code> types are always integers,
counting one per unit cell of the underlying array.  Be aware that
&quot;from&quot; and &quot;to&quot; positions are reported as being between elements.
If matching against a compact array <code>@foo</code>, a final position of 42
indicates that <code>@foo[42]</code> was the first element <i>not</i> included.</p></li>
</ul>
</div>
<h1 id="Matching_against_non_strings">Matching against non-strings</h1>
<div id="Matching_against_non_strings_CONTENT">
<ul>
		<li><p>Anything that can be tied to a string can be matched against a
regex. This feature is particularly useful with input streams:</p>
<pre> my $stream := cat $fh.lines;       # tie scalar to filehandle

 # and later...

 $stream ~~ m/pattern/;         # match from stream
</pre>	</p></li>
		<li><p>Any non-compact array of mixed strings or objects can be matched
against a regex as long as you present them as an object with the <code>Str</code>
interface, which does not preclude the object having other interfaces
such as <code>Array</code>.  Normally you'd use <code>cat</code> to generate such an object:</p>
<pre>@array.cat ~~ / foo &lt;,&gt; bar &lt;elem&gt;* /;
</pre>
<p>The special <code>&lt;,&gt;</code> subrule matches the boundary between elements.
The <code>&lt;elem&gt;</code> assertion matches any individual array element.
It is the equivalent of the &quot;dot&quot; metacharacter for the whole element.</p>
<p>If the array elements are strings, they are concatenated virtually into
a single logical string.  If the array elements are tokens or other
such objects, the objects must provide appropriate methods for the
kinds of subrules to match against.  It is an assertion failure to match
a string-matching assertion against an object that doesn't provide
a stringified view.  However, pure object lists can be parsed as long as
the match (including any subrules) restricts itself to assertions like:</p>
<pre> &lt;.isa(Dog)&gt;
 &lt;.does(Bark)&gt;
 &lt;.can('scratch')&gt;
</pre>
<p>It is permissible to mix objects and strings in an array as long as they're
in different elements.  You may not embed objects in strings, however.
Any object may, of course, pretend to be a string element if it likes,
and so a <code>Cat</code> object may be used as a substring with the same restrictions
as in the main string.</p>
<p>Please be aware that the warnings on <code>.from</code> and <code>.to</code> returning
opaque objects goes double for matching against an array, where a
particular position reflects both a position within the array and
(potentially) a position within a string of that array.  Do not
expect to do math with such values.  Nor should you expect to be
able to extract a substr that crosses element boundaries.
[Conjecture: Or should you?]	</p></li>
		<li><p>To match against every element of an array, use a hyper operator:</p>
<pre> @array».match($regex);
</pre>	</p></li>
		<li><p>To match against any element of the array, it suffices to use ordinary
smartmatching:</p>
<pre>@array ~~ $regex;
</pre></p></li>
</ul>
</div>
<h1 id="When_code_code_is_valid">When <code>$/</code> is valid</h1>
<div id="When_code_code_is_valid_CONTENT">
<p>To provide implementational freedom, the <code>$/</code> variable is not
guaranteed to be defined until the pattern reaches a sequence
point that requires it (such as completing the match, or calling an
embedded closure, or even evaluating a submatch that requires a Perl
expression for its argument).  Within regex code, <code>$/</code> is officially
undefined, and references to <code>$0</code> or other capture variables may
be compiled to produce the current value without reference to <code>$/</code>.
Likewise a reference to <code>$&lt;foo&gt;</code> does not necessarily mean <code>$/&lt;foo&gt;</code> within the regex proper.  During the execution of a match,
the current match state is likely to be stored in a <code>$_</code> variable
lexically scoped to an appropriate portion of the match, but that is
not guaranteed to behave the same as the <code>$/</code> object, because <code>$/</code>
is of type <code>Match</code>, while the match state is of type <code>Cursor</code>.
(It really depends on the implementation of the pattern matching
engine.)</p>
<p>In any case this is all transparent to the user for simple matches;
and outside of regex code (and inside closures within the regex)
the <code>$/</code> variable is guaranteed to represent the state of the match
at that point.  That is, normal Perl code can always depend on <code>$&lt;foo&gt;</code> meaning <code>$/&lt;foo&gt;</code>, and <code>$0</code> meaning <code>$/[0]</code>, whether
that code is embedded in a closure within the regex or outside the
regex after the match completes.</p>
</div>
</div>
</body>
</html>
