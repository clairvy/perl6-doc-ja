<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>DRAFT: Synopsis 32: Setting Library - IO</title>
</head>
<div class="pod">
<h1 id="TITLE">TITLE</h1>
<div id="TITLE_CONTENT">
<p>DRAFT: Synopsis 32: Setting Library - IO</p>
</div>
<h1 id="AUTHORS">AUTHORS</h1>
<div id="AUTHORS_CONTENT">
<pre>The authors of the related Perl 5 docs
Rod Adams &lt;rod@rodadams.net&gt;
Larry Wall &lt;larry@wall.org&gt;
Aaron Sherman &lt;ajs@ajs.com&gt;
Mark Stosberg &lt;mark@summersault.com&gt;
Carl Mäsak &lt;cmasak@gmail.com&gt;
Moritz Lenz &lt;moritz@faui2k3.org&gt;
Tim Nelson &lt;wayland@wayland.id.au&gt;
Daniel Ruoso &lt;daniel@ruoso.com&gt;
Lyle Hopkins &lt;webmaster@cosmicperl.com&gt;
</pre>
</div>
<h1 id="VERSION">VERSION</h1>
<div id="VERSION_CONTENT">
<pre>Created: 19 Feb 2009 extracted from S29-functions.pod; added stuff from S16-IO later

Last Modified: 20 Apr 2009
Version: 6
</pre>
<p>The document is a draft.</p>
<p>If you read the HTML version, it is generated from the pod in the pugs
repository under /docs/Perl6/Spec/S32-setting-library/IO.pod so edit it there in
the SVN repository if you would like to make changes.</p>
</div>
<h2 id="IO">IO</h2>
<div id="IO_CONTENT">
<p>[Note: if a method declaration indicates a method name qualified by
type, it should be taken as shorthand to say which role or class the
method is actually declared in.]</p>
<dl>
	<dt>open
<span id="open">open</span></dt>
	<dd>
<pre>multi open (Str $name,
    Bool :$rw = False,
    Bool :$bin = False,
    Str  :$enc = &quot;Unicode&quot;,
    Any  :$nl = &quot;\n&quot;,
    Bool :$chomp = True,
    ...
    --&gt; IO
) is export
</pre>
		<p>A convenience method/function that hides most of the OO complexity.
It will only open normal files.  Text is the default.  Note that
the &quot;Unicode&quot; encoding implies figuring out which actual UTF is
in use, either from a BOM or other heuristics.  If heuristics are
inconclusive, UTF-8 will be assumed.  (No 8-bit encoding will ever
be picked implicitly.)  A file opened with <code>:bin</code> may still be
processed line-by-line, but IO will be in terms of <code>Buf</code> rather
than <code>Str</code> types.</p>
		<p>TODO: document read/write/append modes (:r, :w, :a)</p>
	</dd>
	<dt>getc
<span id="getc">getc</span></dt>
	<dd>
<pre>method getc (Int $chars = 1 --&gt; Char)
</pre>
		<p>See below for details.</p>
	</dd>
	<dt>print
<span id="print">print</span></dt>
	<dd>
<pre>method print (*@LIST --&gt; Bool)
multi print (*@LIST --&gt; Bool)
method Str::print (IO $io --&gt; Bool)
method Array::print (IO $io --&gt; Bool)
method Hash::print (IO $io --&gt; Bool)
</pre>
		<p>See below for details.</p>
	</dd>
	<dt>say
<span id="say">say</span></dt>
	<dd>
<pre>method say (*@LIST --&gt; Bool)
multi say (*@LIST --&gt; Bool)
method Str::say (IO $io --&gt; Bool)
method Array::say (IO $io --&gt; Bool)
method Hash::say (IO $io --&gt; Bool)
</pre>
		<p>See below for details.</p>
	</dd>
	<dt>printf
<span id="printf">printf</span></dt>
	<dd>
<pre>method printf (Str $fmt, *@LIST --&gt; Bool)
multi printf (Str $fmt, *@LIST --&gt; Bool)
</pre>
		<p>See below for details.</p>
	</dd>
	<dt>uri
<span id="uri">uri</span><span id="ftp">ftp</span><span id="http">http</span></dt>
	<dd>
<pre>method uri(Str $uri --&gt; IO::Streamable);
sub uri(Str $uri --&gt; IO::Streamable);
</pre>
		<p>Returns an appropriate <code>IO::Streamable</code> descendant, with the type depending on the uri
passed in.  Here are some example mappings:</p>
<pre>URI type IO type
======== =======
file:    IO::File or IO::Directory
ftp:     IO::Socket::INET (data channel)
http:    IO::Socket::INET
</pre>
		<p>These can naturally be overridden or added to by other modules.</p>
	</dd>
	<dt>%*PROTOCOLS context variable</dt>
	<dd>
		<p>For each protocol, stores a type name that should be instantiated by calling the <code>uri</code>
constructor on that type, and passing in the appropriate uri.</p>
	</dd>
</dl>
</div>
<h1 id="Roles">Roles</h1>
<div id="Roles_CONTENT">
<p>The functionality of <code>IO</code> objects is broken down into several roles,
which should identify the features each object supports.</p>
</div>
<h2 id="IO-2">IO</h2>
<div id="IO_CONTENT-2">
<p>The base role only tags that this is an <code>IO</code> object for more generic
purposes. It doesn't specify any methods or attributes.</p>
</div>
<h2 id="IO_Readable">IO::Readable</h2>
<div id="IO_Readable_CONTENT">
<p>This role provides unbuffered read access to the data stream.</p>
<pre>role IO::Readable {
    has $.isReadable;
    method read($buf is rw, Int $bytes --&gt; Int)
}
</pre>
<p>When the <code>$.isReadable</code> is set, it tries to change the readability of the filehandle.  This
is not always possible, but can be done in a number of cases.  <code>IO::Socket</code> can remove
readability by calling <code>shutdown</code>, for example.</p>
<dl>
	<dt>method read($buf is rw, Int $bytes --&gt; Int)</dt>
	<dd>
		<p>Tries to read <code>$bytes</code> bytes and store in <code>$buf</code>. The contents of <code>$buf</code>
are replaced and the actual number of bytes read is returned. A return
of 0 means end of file. It might return unthrown failures, to be
specified by each <code>IO</code> implementation.</p>
		<p>It is important to realize that this is &quot;raw&quot; read. You're going to
have plain octets stored in <code>$buf</code>, if this is actually encoded data,
you're going to need to encode it later, or use &quot;getc&quot; or other
<code>IO::Readable::Encoded</code> methods.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Writeable">IO::Writeable</h2>
<div id="IO_Writeable_CONTENT">
<p>This role provides unbuffered write access to the data stream.</p>
<pre>role IO::Writeable {
    has $.isWriteable;
    method write($buf, Int $bytes --&gt; Int)
}
</pre>
<p>When the <code>$.isWriteable</code> is set, it tries to change the writeability of the filehandle.
This is not always possible, but can be done in a number of cases.  <code>IO::Socket</code> can remove
writeability by calling shutdown(), for example.</p>
<dl>
	<dt>method write($buf, Int $bytes --&gt; Int)</dt>
	<dd>
		<p>Tries to write <code>$bytes</code> bytes of <code>$buf</code>. The actual number of bytes
written is returned. It might return unthrown failures, to be
specified by each <code>IO</code> implementation.</p>
		<p>It is important to realize that this is &quot;raw&quot; write. <code>$buf</code> should
contain plain octets that are going to be sent. If <code>$buf</code> contains
encoded data, you should decode it first, or use &quot;print&quot; or other
<code>IO::Writeable::Encoded</code> methods.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Seekable">IO::Seekable</h2>
<div id="IO_Seekable_CONTENT">
<dl>
	<dt>method eoi( --&gt; Bool)</dt>
	<dd>
		<p>EOI = End Of Input -- equivalent to End Of File, but applies to other kinds of sockets as
well.</p>
		<p>Returns true if it's the end of the input (ie. end of file or whatever), returns false if
not, returns undef if we can't say for certain.</p>
	</dd>
	<dt>method seek(Int $position --&gt; Bool)</dt>
	<dd>
		<p>Position this stream into <code>$position</code>. The meaning of this position is
always in &quot;octets&quot;.</p>
	</dd>
	<dt>method tell( --&gt; Int)</dt>
	<dd>
		<p>Returns the current raw position in the stream in number of &quot;octets&quot;.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Buffered">IO::Buffered</h2>
<div id="IO_Buffered_CONTENT">
<p>Indicates that this object performs buffering. The management of the
buffer is completely implementation specific.</p>
<dl>
	<dt>method flush( --&gt; Bool)</dt>
	<dd>
		<p>Flushes the buffers associated with this object.</p>
	</dd>
	<dt>method autoflush( --&gt; Bool) is rw</dt>
	<dd>
		<p>Forces this object to keep its buffers empty</p>
		<p>If set to nonzero, forces a flush right away and after every write
or print on the currently selected output channel.
Default is 0 (regardless of whether the channel is really buffered
by the system or not;
<code>$OUT_FH.autoflush</code> tells you only whether you've asked Perl
explicitly to flush after each write).
<code>$*OUT</code> will typically be line buffered if output is to the
terminal and block buffered otherwise.
Setting this variable is useful primarily when you are
outputting to a pipe or socket,
such as when you are running a Perl program under rsh
and want to see the output as it's happening.
This has no effect on input buffering.</p>




	</dd>
</dl>
</div>
<h2 id="IO_Streamable">IO::Streamable</h2>
<div id="IO_Streamable_CONTENT">
<p>This role represents objects that depend on some external resource,
which means that data might not be available at request.</p>
<pre>role IO::Streamable does IO {...}
</pre>
<dl>
	<dt>new()</dt>
	<dd>
<pre>method new(
    Bool :$NoOpen,
    Bool :$Blocking,
    --&gt; IO::Streamable
) {...}
</pre>
		<p>Unless the NoOpen option is passed, an open will be done on the <code>IO</code> object when it is
created.</p>
		<p>If blocking is passed in, .blocking() is called (see below).</p>
	</dd>
	<dt>method blocking( --&gt; Bool) is rw</dt>
	<dd>
		<p>This allows the user to control whether this object should do a
blocking wait or immediatly return in the case of not having data
available.</p>
	</dd>
	<dt>uri</dt>
	<dd>
<pre>method uri(Str $uri --&gt; IO::Streamable) {...}
</pre>
		<p>This should be callable on the class, and act like a kind of &quot;new()&quot; function.  When given
a URI, it returns an <code>IO::Streamable</code> of the appropriate type, and throws an error when an
inappropriate type is passed in.  For example, calling <code>IO::File.uri('http://....')</code> will
throw an error (but will suggest using just uri('http://...') instead).</p>
	</dd>
</dl>
</div>
<h2 id="IO_Encoded">IO::Encoded</h2>
<div id="IO_Encoded_CONTENT">
<p>This is a generic role for encoded data streams.</p>
<dl>
	<dt>method encoding( --&gt; Str) is rw</dt>
	<dt>method locale( --&gt; Str) is rw</dt>
	<dd>
		<p>Encoding and locale are required for sane conversions.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Readable_Encoded">IO::Readable::Encoded</h2>
<div id="IO_Readable_Encoded_CONTENT">
<p>This role provides encoded access to a readable data stream, implies
<code>IO::Encoded</code>. Might imply <code>IO::Buffered</code>, but that's not a requirement.</p>
<dl>
	<dt>method ins( --&gt; Int)</dt>
	<dd>
		<p>Returns the number of lines or records that have been input.
Now with cleaned-up localization usage.</p>
	</dd>
	<dt>method input-line-separator( --&gt; Str) is rw</dt>
	<dd>
		<p>This regulates how &quot;get&quot; and &quot;lines&quot; behave.</p>
		<p>The input line (record) separator, newline by default.
This influences Perl's idea of what a ``line'' is.
Works like awk's RS variable, including treating empty lines
as a terminator if set to the null string.
(An empty line cannot contain any spaces or tabs.)
You may set it to a multi-character string to match a multi-character
terminator, or to undef to read through the end of file.
Setting it to &quot;\n\n&quot; means something slightly different
than setting to &quot;&quot;, if the file contains consecutive empty lines.
Setting to &quot;&quot; will treat two or more consecutive empty lines
as a single empty line. Setting to &quot;\n\n&quot; will blindly assume
that the next input character belongs to the next paragraph,
even if it's a newline.</p>
		<p>You may also set it to a regular expression.  The value of <code>$/</code>
will be (temporarily) set to the matched separator upon input,
if you care about the contents of the separator.</p>
	</dd>
	<dt>method input-field-separator( --&gt; Str) is rw</dt>
	<dd>
		<p>[Deprecated.]</p>
	</dd>
	<dt>method input-escape( --&gt; Str) is rw</dt>
	<dd>
		<p>[Deprecated.]</p>
	</dd>
	<dt>method get( --&gt; Str)</dt>
	<dd>
		<p>Reads the stream before it finds a <code>$.input-line-separator</code> and
returns it (autochomped by default).</p>
	</dd>
	<dt>method readfield( --&gt; Str)</dt>
	<dd>
		<p>[Deprecated. Use split or comb or an ILS regex.]</p>
	</dd>
	<dt>method getc( --&gt; Char)</dt>
	<dd>
		<p>Reads the next character in the set <code>$.encoding</code>,
or <code>Failure</code> at end of file, or if there was
an error (in either case <code>$!</code> is set).  Note that this
function cannot be used interactively as a <code>readkey()</code> function, since under
Unicode you can't tell the end of a grapheme until you
see the beginning of the next one.</p>
		<p>[TODO someone needs to define something like <code>readkey()</code> for terminal IO.
Though most event-based programs will just want to feed keystrokes into the
event queue.]</p>
	</dd>
	<dt>multi method comb ( Regex $matcher, Int $limit = * )</dt>
	<dd>
		<p>Reads everything into a string, and calls <code>.comb</code> on it with the same
parameters. See <code>Str::comb</code>.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Writeable_Encoded">IO::Writeable::Encoded</h2>
<div id="IO_Writeable_Encoded_CONTENT">
<p>This role provides encoded access to a writeable data stream, implies
<code>IO::Encoded</code>. Might imply <code>IO::Buffered</code>, but that's not a requirement.</p>
<p>If these are called in their non-object form, they operate on <code>$*OUT</code>, except in the
case of warn(), which operates on <code>$*ERR</code>.  The form with leading dot prints <code>$_</code> to
the appropriate handle unless <code>$_</code> happens to be a filehandle.</p>
<dl>
	<dt>Int method outs()</dt>
	<dd>
		<p>Returns the number of lines or records that have been output so far.</p>
	</dd>
	<dt>method output-line-separator( --&gt; Str) is rw</dt>
	<dd>
		<p>This regulates how say behaves.</p>
	</dd>
	<dt>method output-field-separator( --&gt; Str) is rw</dt>
	<dd>
		<p>[Deprecated.]</p>
	</dd>
	<dt>method output-escape( --&gt; Str) is rw</dt>
	<dd>
		<p>[Deprecated.]</p>
	</dd>
	<dt>method Str::print (IO $io = $*OUT --&gt; Bool)</dt>
	<dt>method Str::say (IO $io = $*OUT --&gt; Bool)</dt>
	<dt>method Array::print(IO $io = $*OUT --&gt; Bool)</dt>
	<dt>method Array::say(IO $io = $*OUT --&gt; Bool)</dt>
	<dt>method Hash::print(IO $io = $*OUT --&gt; Bool)</dt>
	<dt>method Hash::say(IO $io = $*OUT --&gt; Bool)</dt>
	<dd>
		<p>Stringifies the invocant (if necessary) and then sends it to the output.
<code>say</code> should add an additional <code>$.output-line-separator</code>.</p>




	</dd>
	<dt>method print (*@LIST --&gt; Bool)</dt>
	<dt>multi print (*@LIST --&gt; Bool)</dt>
	<dd>




		<p>Stringifies each element, concatenates those strings, and sends the
result to the output.
Returns <code>Bool::True</code> if successful, <code>Failure</code> otherwise.</p>
		<p>It is a compiler error to use a bare <code>print</code> without arguments.
(However, it's fine if you have an explicit argument list that evaluates to
the empty list at runtime.)</p>
	</dd>
	<dt>method say (*@LIST --&gt; Bool)</dt>
	<dt>multi say (*@LIST --&gt; Bool)</dt>
	<dd>
		<p>This is identical to print() except that it auto-appends the <code>output-line-separator</code> after
the final argument.</p>
<pre>Was:    print &quot;Hello, world!\n&quot;;
Now:    say   &quot;Hello, world!&quot;;
</pre>
		<p>As with <code>print</code>, it is a compiler error to use a bare <code>say</code> without
arguments.</p>
	</dd>
	<dt>method printf ($self: Str $fmt, *@LIST --&gt; Bool)</dt>
	<dt>multi printf (Str $fmt, *@LIST --&gt; Bool)</dt>
	<dd>
		<p>The function form works as in Perl 5 and always prints to <code>$*OUT</code>.</p>
	</dd>
</dl>
<p>For any handle marked as textual, all these output calls intercept any newline
character and translate it to the current <code>output-line-separator</code> if it
is defined as something other than newline.  No such translation is done on
binary handles, though you may still specify a record separator.  In any case,
escaping separators is the responsibility of the programmer.</p>
</div>
<h2 id="IO_Closeable">IO::Closeable</h2>
<div id="IO_Closeable_CONTENT">
<p>This role indicates that this object can be closed.</p>
<dl>
	<dt>method close( --&gt; Bool)</dt>
	<dd>
		<p>Closes the file or pipe associated with the object.</p>
		<p>Returns <code>True</code> on success, but might return an unthrown <code>Failure</code>.
Returns true only if <code>IO</code> buffers are successfully flushed and closes the system
file descriptor.</p>
		<p>Unlike in Perl 5, an <code>IO</code> object is not a special symbol table entry
neither this object is available magically anywhere else. But as in
Perl 5, unless stated otherwise, <code>IO::Closeable</code> objects always close
themselves during destruction.</p>
	</dd>
</dl>
</div>
<h2 id="IO_Socket">IO::Socket</h2>
<div id="IO_Socket_CONTENT">
<pre>role IO::Socket
    does IO::Closeable
    does IO::Readable
    does IO::Writeable
    does IO::Streamable
{
    has %.options;
    has Bool $.Listener;
    ...
}
</pre>
<p>Accessing the <code>%.options</code> would on Unix be done with <i>getsockopt(2)</i>/<i>setsockopt(2)</i>.</p>
<p>The $.Listener attribute indicates whether the socket will be a listening socket when
opened, rather than indicating whether it is currently listening.</p>
<dl>
	<dt>new</dt>
	<dd>
<pre>method new(
    :$Listener, # initialises $.Listener
)
</pre>
		<p>The initial value of the $.Listener attribute is defined according to the following rules:</p>
<pre> * If $Listener is passed to .new(), then that value is used
 * If neither a local address nor a remote address are passed in, throw an exception
 * If no remote address is passed, then $.Listener is set to SOMAXCONN
 * If no local address is used, then $Listener is set to 0
 * If both local and remote addresses are used, throw an exception that asks people to
   specify $Listener
</pre>
	</dd>
	<dt>open</dt>
	<dd>
<pre>method open()
</pre>
		<p>If $.Listener is true, does a <i>bind(2)</i> and a <i>listen(2)</i>, otherwise does a
<i>connect(2)</i>.</p>
		<p>It's end-user use case is intended for the case where NoOpen is passed to .new().  .new()
itself will presumably also call it.</p>
	</dd>
	<dt>close</dt>
	<dd>
<pre>method close()
</pre>
		<p>Implements the close() function from IO::Closeable by doing a shutdown on the connection
(see below) with @how set to ('Readable', 'Writeable').</p>
	</dd>
	<dt>shutdown</dt>
	<dd>
<pre>method shutdown(Array of Str @how)
</pre>
		<p>Does a <i>shutdown(2)</i> on the connection.  See also IO::Readable.isReadable and
IO::Writeable.isWriteable.</p>
		<p>$how can contain 1 or more of the strings 'Readable' and 'Writeable'.</p>
	</dd>
	<dt>accept</dt>
	<dd>
<pre>method accept( --&gt; IO::Socket)
</pre>
	</dd>
	<dt>method read($buf is rw, Int $bytes --&gt; Int)</dt>
	<dd>
		<p>Implementes the IO::Readable interface by doing a <i>recv(2)</i>.</p>
	</dd>
	<dt>method write($buf, Int $bytes --&gt; Int)</dt>
	<dd>
		<p>Implementes the IO::Writeable interface by doing  a <i>send(2)</i>.</p>
	</dd>
	<dt>getpeername</dt>
</dl>
</div>
<h2 id="IO_FileDescriptor">IO::FileDescriptor</h2>
<div id="IO_FileDescriptor_CONTENT">
<p>This role indicates that this object actually represents an open file
descriptor in the os level.</p>
<dl>
	<dt>method int fileno()</dt>
	<dd>
		<p>File descriptors are always native integers, conforming to C89.</p>
	</dd>
</dl>
</div>
<h1 id="Classes">Classes</h1>
<div id="Classes_CONTENT">
</div>
<h2 id="IO_File">IO::File</h2>
<div id="IO_File_CONTENT">
<p>This does file input and output.</p>
<pre>class IO::File does IO::Streamable {
    ...
}
</pre>
<dl>
	<dt>new</dt>
	<dd>
<pre>method new(
    FSNode :$FSNode,
    Str :$Filename,
    :$fd
    Bool :$NoOpen,
    :$Writeable,
    :$Readable
);
</pre>
		<p>The <code>FSNode</code>, <code>Filename</code> and <code>fd</code> options are mutually exclusive.  If &quot;<code>use portable</code>&quot; is in
effect, the <code>Filename</code> option throws an error; use an <code>FSNode</code> instead.</p>
		<p><code>NoOpen</code> is passed to <code>IO::Streamable.new()</code></p>
		<p>Examples:</p>
<pre># Read -- throws errors with 'use portable'
$fobj = new IO::File(Filename =&gt; $filename);

# Write -- works with 'use portable'
$fobj = new IO::File(
    FSNode =&gt; IO::FSNode.new(type =&gt; 'Unix', Filename =&gt; $filename),
    Writeable =&gt; 1
);

# Read using file descriptor
$fobj = new IO::File(fd =&gt; $fd);
</pre>
		<p>This final example associates an <code>IO</code> object with an already-open file descriptor,
presumably passed in from the parent process.</p>
	</dd>
	<dt>open()</dt>
	<dd>
		<p>This function opens a file that had the <code>NoOpen</code> option passed to the <code>new</code> method.</p>
	</dd>
	<dt>IO.truncate</dt>
	<dt>IO.fcntl</dt>
	<dd>
		<p>Available only as a handle method.</p>
	</dd>
</dl>
</div>
<h2 id="IO_FileSystem">IO::FileSystem</h2>
<div id="IO_FileSystem_CONTENT">
<p>This represents the filesystem.</p>
<pre>class IO::FileSystem does IO::Streamable {
    has Str $.fstype; # ext3, ntfs, vfat, reiserfs, etc
    has Str $.illegal-chars; # ie. /\x0
    has Int $.max-path;
...
}
</pre>
<dl>
	<dt>glob</dt>
	<dd>
		<p>Returns <code>FSNode</code> objects.</p>
	</dd>
	<dt>find</dt>
	<dd>
		<p>Returns <code>FSNode</code> objects.</p>
	</dd>
	<dt>rename</dt>
</dl>
</div>
<h2 id="IO_FSNode">IO::FSNode</h2>
<div id="IO_FSNode_CONTENT">
<pre>class IO::FSNode {
    has Array of IO::FSNodeACL @.ACLs;
    has Hash of %.times;
...
}
</pre>
<p>The <code>%times</code> has keys that can be eg. <code>ctime</code>, <code>Modification</code>, and <code>Access</code> (and maybe others on
other operating systems), and the values are all <code>Temporal::Instant</code> objects.</p>
<p>When <code>.path</code> is implemented, it should return the path that this was opened with.</p>
<dl>
	<dt>IO ~~ :X
<span id="r">:r</span><span id="w">:w</span><span id="x">:x</span><span id="o">:o</span><span id="R">:R</span><span id="W">:W</span><span id="X">:X</span><span id="O">:O</span><span id="e">:e</span><span id="z">:z</span><span id="s">:s</span><span id="f">:f</span><span id="d">:d</span><span id="l">:l</span><span id="p">:p</span>
<span id="S">:S</span><span id="b">:b</span><span id="c">:c</span><span id="t">:t</span><span id="u">:u</span><span id="g">:g</span><span id="k">:k</span><span id="T">:T</span><span id="B">:B</span><span id="M">:M</span><span id="A">:A</span><span id="C">:C</span></dt>
	<dt>EXPR ~~ :X</dt>
	<dd>
<pre>  $file.:X
  $file ~~ :X
</pre>
		<p>A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about it.</p>
		<p>A <code>Pair</code> used as a pattern is treated as a file test.</p>
<pre>:r  File is readable by effective uid/gid.
:w  File is writable by effective uid/gid.
:x  File is executable by effective uid/gid.
:o  File is owned by effective uid.

:R  File is readable by real uid/gid.
:W  File is writable by real uid/gid.
:X  File is executable by real uid/gid.
:O  File is owned by real uid.

:e  File exists.
:z  File has zero size (is empty).
:s  File has nonzero size (returns size in bytes).

:f  File is a plain file.
:d  File is a directory.
:l  File is a symbolic link.
:p  File is a named pipe (FIFO), or Filehandle is a pipe.
:S  File is a socket.
:b  File is a block special file.
:c  File is a character special file.
:t  Filehandle is opened to a tty.

:u  File has setuid bit set.
:g  File has setgid bit set.
:k  File has sticky bit set.

:T  File is an ASCII text file (heuristic guess).
:B  File is a &quot;binary&quot; file (opposite of :T).

:M  Script start time minus file modification time, in days.
:A  Same for access time.
:C  Same for inode change time (Unix, may differ for other platforms)
</pre>
		<p>The interpretation of the file permission operators <code>:r</code>, <code>:R</code>,
<code>:w</code>, <code>:W</code>, <code>:x</code>, and <code>:X</code> is by default based on:</p>
		<p>
			<dl>
				<dt>* The mode of the file and the uids and gids of the user</dt>
				<dt>* ACLs (access control lists)</dt>
				<dt>* read-only filesystems</dt>
			</dl>
		</p>
		<p>There may be other reasons you can't actually read, write, or execute
the file.  Such reasons may be for example network filesystem access
controls and unrecognized executable formats.</p>
		<p>Also note that, for the superuser on the local filesystems, the <code>:r</code>,
<code>:R</code>, <code>:w</code>, and <code>:W</code> tests always return 1, and <code>:x</code> and <code>:X</code> return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a <code>stat</code> to determine the actual mode of the file,
or temporarily set their effective uid to something else.</p>
		<p>The <code>:T</code> and <code>:B</code> switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many strange characters (&gt;30%)
are found, it's a <code>:B</code> file; otherwise it's a <code>:T</code> file.  Also, any file
containing null in the first block is considered a binary file.  If <code>:T</code>
or <code>:B</code> is used on a filehandle, the current <code>IO</code> buffer is examined
rather than the first block.  Both <code>:T</code> and <code>:B</code> return true on a null
file, or a file at EOF when testing a filehandle.  Because you have to
read a file to do the <code>:T</code> test, on most occasions you want to use a <code>:f</code>
against the file first, as in <code>next unless $file ~~ :f  &amp;&amp; $file ~~ :T </code>.</p>
		<p>You can test multiple features using junctions:</p>
<pre>  if -$filename ~~ :r &amp; :w &amp; :x  {...}
</pre>
		<p>Or pass multiple tests together in OO style:</p>
<pre>  if $filename.TEST(:e,:x) {...}



</pre>
	</dd>
	<dt>realpath</dt>
	<dd>
<pre>method realpath( --&gt; Str);
</pre>
		<p>Gets the real path to the object, resolving softlinks/shortcuts, etc</p>
	</dd>
	<dt>=== operator</dt>
	<dd>
<pre>method infix:&lt;===&gt;(Str $filename);
</pre>
		<p>Test whether the specified filename is the same file as this file.  On a Unix system,
this would presumably be done by comparing inode numbers or something.</p>
	</dd>
	<dt>new</dt>
	<dd>
		<p>This is called automatically on object creation.</p>
<pre>multi method new(Array of Str :@PathElements);
multi method new(Str :$Type, Str :$Path, Str :$Create);
multi method new(Str :$Path);
</pre>
		<p>This last throws an error if &quot;<code>use portable</code>&quot; pragma is used.</p>
		<p>If the <code>Create</code> option is passed in, and the node doesn't exist in the filesystem, it
attempts to create the node; this can be used for <i>mkdir</i>, <i>link</i>, and similar
functionality.</p>
		<p>Examples:</p>
<pre>$fsnode = new IO::FSNode(PathElements =&gt; ['home', 'wayland']);
$fsnode = new IO::FSNode(Type =&gt; 'Unix', Path =&gt; '/home/wayland');
$fsnode = new IO::FSNode(Path =&gt; '/home/wayland'); # portability error
</pre>
	</dd>
	<dt>delete</dt>
	<dd>
		<p>This deletes the <code>FSNode</code> from the filesystem.  If the node has children, it throws an error
unless the <code>Recursive</code> option is specified.  Returns the number of nodes deleted.</p>
	</dd>
</dl>
</div>
<h2 id="IO_FSNodeACL">IO::FSNodeACL</h2>
<div id="IO_FSNodeACL_CONTENT">
<p>This is a basic abstraction; for better control, use the operating-system specific
interfaces, over which this is a thin veneer.</p>
<pre>class IO::FSNodeACL {
    has Str $.type; # &quot;User&quot;, &quot;Group&quot;, &quot;Everyone&quot;, ???
    has Str $.id; # username or groupname; unused for $type eq &quot;Everyone&quot;
    has %.permissions;
            # Unsupported values may (or may not) throw
            # UnsupportedPermission when set or read
    has IO::FSNode $.owningObject;
    ...
}
</pre>
<p>The permissions used in <code>%permissions</code> are:</p>
<dl>
	<dt>Readable</dt>
	<dd>
		<p>Should be supported by all filesystems as an item to read from the hash for the group
&quot;Everyone&quot;.</p>
	</dd>
	<dt>Writeable</dt>
	<dd>
		<p>Should be supported by all filesystems as an item to read from the hash for the group
&quot;Everyone&quot;.</p>
	</dd>
	<dt>Executeable</dt>
	<dd>
		<p>Supported on most Unix systems, anyway.  Windows should be able to guess when this is
read, and throw an exception if written to.</p>
	</dd>
	<dt>Default</dt>
	<dd>
		<p>An ACL of User,fred,Default sets the user &quot;fred&quot; to be the owner of the file.  This can be
done with groups too.  Works on Unix, at least.</p>
	</dd>
</dl>
<p>The <code>$.owningObject</code> attribute of <code>FSNodeACL</code> shows what the ACL is set on.  On a
Windows system, this can be a parent directory, as permissions are inherited.</p>
</div>
<h2 id="IO_FileNode">IO::FileNode</h2>
<div id="IO_FileNode_CONTENT">
<pre>role IO::FileNode does IO::FSNode {
    ...
}
</pre>
<dl>
	<dt>lines</dt>
	<dd>
<pre>method lines ($handle:
    Any  $limit = *,
    Bool :$bin = False,
    Str  :$enc = &quot;Unicode&quot;,
    Any  :$nl = &quot;\n&quot;,
    Bool :$chomp = True,
    --&gt; List
) is export

multi lines (Str $filename,
    Any  $limit = *,
    Bool :$bin = False,
    Str  :$enc = &quot;Unicode&quot;,
    Any  :$nl = &quot;\n&quot;,
    Bool :$chomp = True,
    --&gt; List
)
</pre>
		<p>Returns some or all the lines of a file as a <code>List</code> regardless of context.
See also <code>slurp</code>.  Note that lists are lazy by default, but you
can always ask for <code>eager lines</code>.  Note that the limit semantics cannot be
duplicated by subscripting, since</p>
<pre>$fh.lines[^5]
</pre>
		<p>reads all the lines before the subscript gives you the first five,
whereas</p>
<pre>$fh.lines(5)
</pre>
		<p>reads only five lines from the handle.  Note that</p>
<pre>$fh.lines(1)
</pre>
		<p>is equivalent to</p>
<pre>$fh.get
</pre>
		<p>If fewer lines are available than the limit, it is not an error;
you just get the number of lines available.</p>
	</dd>
	<dt>slurp</dt>
	<dd>
<pre>method slurp ($handle:
    Bool :$bin = False,
    Str  :$enc = &quot;Unicode&quot;,
    --&gt; Str|Buf
) is export
multi slurp (Str $filename,
    Bool :$bin = False,
    Str  :$enc = &quot;Unicode&quot;,
    --&gt; Str|Buf
)
</pre>
		<p>Slurps the entire file into a <code>Str</code> (or <code>Buf</code> if <code>:bin</code>) regardless of context.
(See also <code>lines</code>.)</p>
	</dd>
</dl>
</div>
<h2 id="IO_DirectoryNode">IO::DirectoryNode</h2>
<div id="IO_DirectoryNode_CONTENT">
<pre>role IO::DirectoryNode does IO::FSNode {
    ...
}

$dir.open(
    Str  :$enc = &quot;Unicode&quot;,
);
</pre>
<p>Opens a directory for processing, if the <code>new</code> method was passed the <code>NoOpen</code> option.
Makes the directory looks like
a list of autochomped lines, so just use ordinary <code>IO</code> operators after the open.</p>
<p>Deletes the directory specified by FILENAME if that directory is
empty.  If it succeeds it returns true, otherwise it returns <code>Failure</code> and
sets <code>$!</code> (errno).</p>
<p>Changes the current working directory to the one specified by FILENAME.
If it succeeds it returns true, otherwise it returns <code>Failure</code> and
sets <code>$!</code> (errno).</p>
</div>
<h2 id="IO_LinkNode">IO::LinkNode</h2>
<div id="IO_LinkNode_CONTENT">
<pre>role IO::LinkNode does IO::FSNode {
    ...
}
</pre>
<p>Creates a new link in the filesystem.</p>
<pre>IO::LinkNode.new(
    Name =&gt; '/home/wayland/symlink.txt'
    Target =&gt; '/home/wayland/realfile.txt',
    Type =&gt; 'Hard', # Default is Symbolic
);
</pre>
<p>Reads in the previously created symlink.</p>
<pre>$link = IO::LinkNode.new(
    Name =&gt; '/home/wayland/symlink.txt',
);
print $link.target; # prints /home/wayland/realfile.txt
</pre>
<p>Neither of these is &quot;<code>use portable</code>&quot; compatible.</p>
</div>
<h2 id="IO_Socket_INET">IO::Socket::INET</h2>
<div id="IO_Socket_INET_CONTENT">
<pre>class IO::Socket::INET does IO::Socket {
    has Int $.Version = 4; # Whether to use IPv4 or IPv6
    has Str $.Protocol = 'TCP';
    has Str $.RemoteHost;
    has Int $.RemotePort;
    has Str $.LocalHost;
    has Int $.LocalPort;
    ...
}
</pre>
<dl>
	<dt>new</dt>
	<dd>
<pre>method new(
    Str  :$RemoteHost, # Initialises $.RemoteHost
    Str  :$RemotePort, # Initialises $.RemotePort (if it's not a numeric string, use getservbyname)
    Str  :$LocalHost,  # Initialises $.LocalHost
    Str  :$LocalPort,  # Initialises $.LocalPort (if it's not a numeric string, use getservbyname)
    Str  :$Protocol,   # Initialises $.Protocol
    Int  :$Version,    # Initialises $.Version (IPv4 vs. IPv6)

    Bool :$Listener,   # Passed to IO::Socket.new()

    Bool :$Blocking,   # Passed to IO::Streamable.new()
    Bool :$NoOpen,     # Passed to IO::Streamable.new()

    --&gt; IO::Socket::INET
) {...}
</pre>
	</dd>
</dl>
</div>
<h2 id="IO_Pipe">IO::Pipe</h2>
<div id="IO_Pipe_CONTENT">
<pre>class IO::Pipe does IO::Streamable does IO::Readable does IO::Writable {
    ...
}
</pre>
<p>Will need to set IO::Readable.isReadable and IO::Writable.isWriteable depending on opening
method.</p>
<dl>
	<dt>close()</dt>
	<dd>
		<p>If the file handle came from a piped open, <code>close</code> will additionally
return <code>Failure</code> (aliased to <code>$!</code>) if one of the other system calls involved fails, or if the
program exits with non-zero status.  The exception object will contain any
pertinent information.  Closing a pipe
also waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards, and
implicitly puts the exit status value into the <code>Failure</code> object if necessary.</p>
	</dd>
	<dt>IO::Pipe.to</dt>
	<dd>
<pre>method to(Str $command, *%opts --&gt; Bool)
method to(Str *@command, *%opts --&gt; Bool)
</pre>
		<p>Opens a one-way pipe writing to <code>$command</code>.  <code>IO</code> redirection for
stderr is specified with <code>:err(IO)</code> or <code>:err&lt;Str&gt;</code>.  Other <code>IO</code> redirection
is done with feed operators. XXX how to specify &quot;2&gt;&amp;1&quot;?</p>
	</dd>
	<dt>IO::Pipe.from</dt>
	<dd>
<pre>method from(Str $command, *%opts --&gt; Bool)
method from(Str *@command, *%opts --&gt; Bool)
</pre>
		<p>Opens a one-way pipe reading from $command.  <code>IO</code> redirection for
stderr is specified with <code>:err(IO)</code> or <code>:err&lt;Str&gt;</code>.  Other <code>IO</code> redirection
is done with feed operators. XXX how to specify &quot;2&gt;&amp;1&quot;?</p>
	</dd>
	<dt>IO::Pipe.pair</dt>
	<dd>
<pre>method pair(--&gt; List of IO::Pipe)
</pre>
		<p>A wrapper for <i>pipe(2)</i>, returns a pair of <code>IO</code> objects representing the
reader and writer ends of the pipe.</p>
<pre>   ($r, $w) = IO::Pipe.pair;
</pre>
	</dd>
</dl>
</div>
<h1 id="OS_specific_classes">OS-specific classes</h1>
<div id="OS_specific_classes_CONTENT">
</div>
<h2 id="Unix">Unix</h2>
<div id="Unix_CONTENT">
</div>
<h2 id="IO_FSNode_Unix">IO::FSNode::Unix</h2>
<div id="IO_FSNode_Unix_CONTENT">
<pre>multi chown ($uid = -1, $gid = -1, *@files --&gt; Int)
</pre>
<p>Changes the owner (and group) of a list of files.  The first
two elements of the list must be the numeric uid and gid, in
that order.  A value of -1 in either position is interpreted by
most systems to leave that value unchanged.  Returns the number
of files successfully changed.</p>
<pre>$count = chown $uid, $gid, ’foo’, ’bar’;
chown $uid, $gid, @filenames;
</pre>
<p>On systems that support <code>fchown</code>, you might pass file handles
among the files.  On systems that don’t support <code>fchown</code>, passing
file handles produces a fatal error at run time.</p>
<p>Here’s an example that looks up nonnumeric uids in the passwd
file:</p>
<pre>   $user = prompt &quot;User: &quot;;
   $pattern = prompt &quot;Files: &quot;;

   ($login,$pass,$uid,$gid) = getpwnam($user)
   or die &quot;$user not in passwd file&quot;;

   @ary = glob($pattern);      # expand filenames
   chown $uid, $gid, @ary;
</pre>
<p>On most systems, you are not allowed to change the ownership of
the file unless you’re the superuser, although you should be
able to change the group to any of your secondary groups.  On
insecure systems, these restrictions may be relaxed, but this
is not a portable assumption.  On POSIX systems, you can detect
this condition this way:</p>
<pre>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
$can-chown-giveaway = not sysconf(_PC_CHOWN_RESTRICTED);
</pre>
<p>Changes the permissions of a list of files.  The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should <i>not</i> be a string of octal digits:
<code>0o644</code> is okay, <code>0644</code> is not.  Returns the number of files
successfully changed.</p>
<pre>$cnt = chmod 0o755, 'foo', 'bar';
chmod 0o755, @executables;
$mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to --w----r-T
$mode = '0o644'; chmod $mode, 'foo';     # this is better
$mode = 0o644;   chmod $mode, 'foo';     # this is best

$node.stat(Bool :$link); # :link does an lstat instead
</pre>
<p>Returns a stat buffer.  If the lstat succeeds, the stat buffer evaluates
to true, and additional file tests may be performed on the value.  If
the stat fails, all subsequent tests on the stat buffer also evaluate
to false.</p>
</div>
<h2 id="IO_Socket_Unix">IO::Socket::Unix</h2>
<div id="IO_Socket_Unix_CONTENT">
<pre>role IO::Socket::Unix does IO::Socket {
    has Str $.RemoteAddr, # Remote Address
    has Str $.LocalAddr,  # Local Address
}
</pre>
<dl>
	<dt>new</dt>
	<dd>
<pre>method new(
    Str  :$RemoteAddr,
    Str  :$LocalAddr,

    Bool :$Listener,   # Passed to IO::Socket.new()

    Bool :$Blocking,   # Passed to IO::Streamable.new()
    Bool :$NoOpen,     # Passed to IO::Streamable.new()

    --&gt; IO::Socket::Unix
) {...}
</pre>
	</dd>
	<dt>pair</dt>
	<dd>
<pre>method pair(Int $domain, Int $type, Int $protocol --&gt; List of IO)
</pre>
		<p>A wrapper for <i>socketpair(2)</i>, returns a pair of <code>IO</code> objects representing the
reader and writer ends of the socket.</p>
<pre>   use IO::Socket;
   ($r, $w) = IO::Socket::Unix.pair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);



</pre>
	</dd>
</dl>
</div>
<h2 id="IO_POSIX">IO::POSIX</h2>
<div id="IO_POSIX_CONTENT">
<p>Indicates that this object can perform standard posix <code>IO</code>
operations. It implies <code>IO::Readable</code> and <code>IO::Writeable</code>.</p>
<dl>
	<dt>method dup( --&gt; IO)</dt>
	<dt>has Bool $.blocking is rw</dt>
	<dt>method flock(:$r,:$w --&gt; Bool)</dt>
	<dt>method funlock( --&gt; Bool)</dt>
	<dt>...</dt>
</dl>
</div>
<h1 id="Unfiled">Unfiled</h1>
<div id="Unfiled_CONTENT">
<dl>
	<dt>IO.ioctl</dt>
	<dd>
		<p>Available only as a handle method.</p>
	</dd>
	<dt>alarm</dt>
	<dt>prompt</dt>
	<dd>
<pre>multi prompt (Str $prompt --&gt; Str)
</pre>
		<p>Should there be an IO::Interactive role?</p>
	</dd>
	<dt>Str.readpipe</dt>
	<dt>sysopen</dt>
	<dt>IO.sysseek</dt>
	<dt>umask</dt>
</dl>
</div>
<h1 id="Removed_functions">Removed functions</h1>
<div id="Removed_functions_CONTENT">
<dl>
	<dt>IO.eof</dt>
	<dd>
		<p>Gone, see <code>IO::Endable</code>.</p>
	</dd>
	<dt>IO.fileno</dt>
	<dd>
		<p>See <code>IO::FileDescriptor</code>.</p>
	</dd>
	<dt>/(get|set)(host|net|proto|serv|sock).*/</dt>
	<dd>
		<p>Should be implemented by an external library.</p>
	</dd>
	<dt>lstat</dt>
	<dd>
		<p>Use <code>stat</code> with the <code>:link</code> option.</p>
	</dd>
	<dt>IO.name</dt>
	<dd>
		<p>Changed to <code>.path</code>, but we haven't gotten around to specifying this on all of them.</p>
		<p>The <code>.name</code> method returns the name of the file/socket/uri the handle
was opened with, if known.  Returns undef otherwise.  There is no
corresponding <code>name()</code> function.</p>
	</dd>
	<dt>pipe</dt>
	<dd>
		<p>Gone, see Pipe.pair</p>
	</dd>
	<dt>select(both)</dt>
	<dd>
		<p>Gone.  (Note: for subsecond sleep, just use sleep with a fractional argument.)</p>
	</dd>
	<dt>IO.shutdown()</dt>
	<dd>
		<p>Gone, see <code>IO::Socket.close()</code>, <code>$IO::Readable.isReadable</code>, and <code>$IO::Writeable.isWriteable</code></p>
	</dd>
	<dt>socketpair</dt>
	<dd>
		<p>Gone, see Socket.pair</p>
	</dd>
	<dt>IO.sysread</dt>
	<dd>
		<p>Gone, see <code>IO::Readable.read()</code>.</p>
	</dd>
	<dt>IO.syswrite</dt>
	<dd>
		<p>Gone, see <code>IO::Writeable.read()</code>.</p>
	</dd>
	<dt>utime</dt>
	<dd>
		<p>Gone, see <code>IO::FSNode.times</code>.</p>
	</dd>
</dl>
</div>
<h1 id="Additions">Additions</h1>
<div id="Additions_CONTENT">
<p>Please post errors and feedback to perl6-language.  If you are making
a general laundry list, please separate messages by topic.</p>
</div>
</div>
</body>
</html>
